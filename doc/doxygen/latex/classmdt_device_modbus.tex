\hypertarget{classmdt_device_modbus}{
\section{mdtDeviceModbus Class Reference}
\label{classmdt_device_modbus}\index{mdtDeviceModbus@{mdtDeviceModbus}}
}


Represent a MODBUS device.  




{\ttfamily \#include $<$mdtDeviceModbus.h$>$}



Inheritance diagram for mdtDeviceModbus:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=204pt]{classmdt_device_modbus__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtDeviceModbus:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{classmdt_device_modbus__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_device_modbus_ac69cfbe26681342ba05672ab63de2a1f}{mdtDeviceModbus} (QObject $\ast$parent=0)
\item 
\hypertarget{classmdt_device_modbus_aed892b501f8cbd372ccfda1a4fafa536}{
\hyperlink{classmdt_port_manager}{mdtPortManager} $\ast$ \hyperlink{classmdt_device_modbus_aed892b501f8cbd372ccfda1a4fafa536}{portManager} ()}
\label{classmdt_device_modbus_aed892b501f8cbd372ccfda1a4fafa536}

\begin{DoxyCompactList}\small\item\em Get internal port manager instance. \end{DoxyCompactList}\item 
\hypertarget{classmdt_device_modbus_ac547788aa95d46c00ddb1342eb46ef93}{
\hyperlink{classmdt_modbus_tcp_port_manager}{mdtModbusTcpPortManager} $\ast$ \hyperlink{classmdt_device_modbus_ac547788aa95d46c00ddb1342eb46ef93}{modbusTcpPortManager} ()}
\label{classmdt_device_modbus_ac547788aa95d46c00ddb1342eb46ef93}

\begin{DoxyCompactList}\small\item\em Get internal port manager instance. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_modbus_a64bfa566dbd8511e11d76c0b14191f17}{setHardwareNodeId} (int hwNodeId, int bitsCount, int startFrom=0)
\begin{DoxyCompactList}\small\item\em Set hardware node id. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_modbus_a4ec2b55127b7b853488f102f2c5215f8}{clearHardwareNodeId} ()
\begin{DoxyCompactList}\small\item\em Clear hardware node id. \end{DoxyCompactList}\item 
QVariant \hyperlink{classmdt_device_modbus_ab5e3f041a24d895dbe739a9229d4fd27}{hardwareNodeId} () const 
\begin{DoxyCompactList}\small\item\em Get hardware node id. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \hyperlink{classmdt_device_modbus_a3ca2a84163fed1380cbc8859a6b70db0}{connectToDevice} (const \hyperlink{classmdt_port_info}{mdtPortInfo} \&portInfo)
\begin{DoxyCompactList}\small\item\em Connect to physical device. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \hyperlink{classmdt_device_modbus_a093c6407ee69c4c7696a0c71d0acd88d}{connectToDevice} (const \hyperlink{classmdt_device_info}{mdtDeviceInfo} \&devInfo)
\begin{DoxyCompactList}\small\item\em Search and connect to physical device. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \hyperlink{classmdt_device_modbus_a323b16687f448a4e45eb0b313635b77f}{connectToDevice} (const QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \&scanResult, int hardwareNodeId, int bitsCount, int startFrom=0)
\begin{DoxyCompactList}\small\item\em Search and connect to physical device. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \hyperlink{classmdt_device_modbus_a08100215b37c0922ed177d1f99d07e97}{connectToDevice} (const QList$<$ int $>$ \&existingHwNodeIdList)
\begin{DoxyCompactList}\small\item\em Search and connect to physical device. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \hyperlink{classmdt_device_modbus_abfcab17fbf05aab7843ae689316dd01f}{connectToDevice} ()
\begin{DoxyCompactList}\small\item\em Search and connect to physical device. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_device_modbus_a89d41c6b33a3dd2a92a0956d8e6b3b14}{getRegisterValues} (int address, int n)
\begin{DoxyCompactList}\small\item\em Helper method for register service. \end{DoxyCompactList}\item 
const QList$<$ int $>$ \& \hyperlink{classmdt_device_modbus_a83cb2a28111653fbcbbe748f7a1a2e3d}{registerValues} () const 
\begin{DoxyCompactList}\small\item\em Helper method for register service. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_device_modbus_a4128420bde679c3666bdf8954a221a53}{setRegisterValues} (int startAddress, QList$<$ int $>$ \&values)
\begin{DoxyCompactList}\small\item\em Helper method for register service. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classmdt_device_modbus_aa2a024793ae2a5e81c7e92260a70cd9e}{readAnalogInput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Update (G)UI when device's state has changed. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a846af6dbf80bbf747f3f966420ef6f92}{readAnalogInputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all analog inputs on physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a30c815cbe5e603e8114dcbc09849e322}{readAnalogOutput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read one analog output on physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_ae02dd44f1d873fcc15ff75d781b62b0b}{readAnalogOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all analog outputs on physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_ac63297a31205759622f341525c34251f}{writeAnalogOutput} (int value, \hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write value on a analog output to physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_aa09d1682bef4bbc08b59b20110e613ff}{writeAnalogOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction, \hyperlink{classmdt_device_ios_segment}{mdtDeviceIosSegment} $\ast$segment)
\begin{DoxyCompactList}\small\item\em Write all analog outputs to physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a9dd05e51223ee5bb79970fbe84c501f9}{readDigitalInput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read one digital input on physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a3fba9e113092f9da187cf684fb62b132}{readDigitalInputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all digital inputs on physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a13a334ac86135751893f37064d8f548d}{readDigitalOutput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read one digital output on physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a8915a036472bff0f356756992c1eae51}{readDigitalOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all digital outputs on physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a6950c10fc521b193fb3c754223879694}{writeDigitalOutput} (bool state, \hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write state on a digital output to physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a6713edaee0bfba48791008124299b753}{writeDigitalOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction, \hyperlink{classmdt_device_ios_segment}{mdtDeviceIosSegment} $\ast$segment)
\begin{DoxyCompactList}\small\item\em Write all digital outputs to physical device. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_device_modbus_a3b83b926ed1f9c3bdf7024de2745c285}{queriesSequence} ()
\begin{DoxyCompactList}\small\item\em Sequence of queries to send periodically. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_device_modbus_a9ecbac63c29b229ab01f5fdb26008c95}{
\hyperlink{classmdt_modbus_tcp_port_manager}{mdtModbusTcpPortManager} $\ast$ {\bfseries pvTcpPortManager}}
\label{classmdt_device_modbus_a9ecbac63c29b229ab01f5fdb26008c95}

\item 
\hypertarget{classmdt_device_modbus_a2171d37ea720d546934f1c841e3c4d26}{
\hyperlink{classmdt_frame_codec_modbus}{mdtFrameCodecModbus} $\ast$ {\bfseries pvCodec}}
\label{classmdt_device_modbus_a2171d37ea720d546934f1c841e3c4d26}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Represent a MODBUS device. 

References:
\begin{DoxyItemize}
\item MODBUS Application Protocol Specification V1.1b
\item \href{http://www.Modbus-IDA.org}{\tt http://www.Modbus-\/IDA.org} 
\end{DoxyItemize}

Definition at line 42 of file mdtDeviceModbus.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_device_modbus_ac69cfbe26681342ba05672ab63de2a1f}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!mdtDeviceModbus@{mdtDeviceModbus}}
\index{mdtDeviceModbus@{mdtDeviceModbus}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{mdtDeviceModbus}]{\setlength{\rightskip}{0pt plus 5cm}mdtDeviceModbus::mdtDeviceModbus (
\begin{DoxyParamCaption}
\item[{QObject $\ast$}]{parent = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_modbus_ac69cfbe26681342ba05672ab63de2a1f}
\begin{Desc}
\item[\hyperlink{todo__todo000008}{Todo}]Provisoire ! \end{Desc}


Definition at line 34 of file mdtDeviceModbus.cpp.



\subsection{Member Function Documentation}
\hypertarget{classmdt_device_modbus_a4ec2b55127b7b853488f102f2c5215f8}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!clearHardwareNodeId@{clearHardwareNodeId}}
\index{clearHardwareNodeId@{clearHardwareNodeId}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{clearHardwareNodeId}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDeviceModbus::clearHardwareNodeId (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_modbus_a4ec2b55127b7b853488f102f2c5215f8}


Clear hardware node id. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_device_modbus_a64bfa566dbd8511e11d76c0b14191f17}{setHardwareNodeId()} . 
\end{DoxySeeAlso}


Definition at line 80 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a323b16687f448a4e45eb0b313635b77f}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!connectToDevice@{connectToDevice}}
\index{connectToDevice@{connectToDevice}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{connectToDevice}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtDeviceModbus::connectToDevice (
\begin{DoxyParamCaption}
\item[{const QList$<$ {\bf mdtPortInfo} $\ast$ $>$ \&}]{scanResult, }
\item[{int}]{hardwareNodeId, }
\item[{int}]{bitsCount, }
\item[{int}]{startFrom = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_modbus_a323b16687f448a4e45eb0b313635b77f}


Search and connect to physical device. 

Will try to connect to device listed in scanResult until hardwareNodeId is found.


\begin{DoxyParams}{Parameters}
{\em scanResult} & List of \hyperlink{classmdt_port_info}{mdtPortInfo} containing a port name in format host:port . \\
\hline
{\em hardwareNodeId} & See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{mdtModbusTcpPortManager::getHardwareNodeAddress()} . \\
\hline
{\em bitsCount} & See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{mdtModbusTcpPortManager::getHardwareNodeAddress()} . \\
\hline
{\em startFrom} & See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{mdtModbusTcpPortManager::getHardwareNodeAddress()} . \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A error listed in \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} (NoError on success) . 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
scanResult must contain valid pointers . 
\end{DoxyPrecond}


pvTcpPortManager-\/$>$setPortInfo($\ast$scanResult.at(i)); if(!pvTcpPortManager-\/$>$\hyperlink{classmdt_device_a721c5bf2cfa0eef5304333f08da182f7}{start()})\{ continue; \}

continue; 



Reimplemented in \hyperlink{classmdt_device_modbus_wago_a12ad1f1ef34b16be5903d1d6232a7c6d}{mdtDeviceModbusWago}.



Definition at line 176 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a08100215b37c0922ed177d1f99d07e97}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!connectToDevice@{connectToDevice}}
\index{connectToDevice@{connectToDevice}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{connectToDevice}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtDeviceModbus::connectToDevice (
\begin{DoxyParamCaption}
\item[{const QList$<$ int $>$ \&}]{existingHwNodeIdList}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_modbus_a08100215b37c0922ed177d1f99d07e97}


Search and connect to physical device. 

Will connect to device with hardwareNodeId set with \hyperlink{classmdt_device_modbus_a64bfa566dbd8511e11d76c0b14191f17}{setHardwareNodeId()} . This method will beginn to scan hosts in cache file (if exists) . If expcted device was not found, the network is also scanned .


\begin{DoxyParams}{Parameters}
{\em existingHwNodeIdList} & A list of hardwareNodeId to consider during scan . Once all devices contained in existingHwNodeIdList, and device with hardwareNodeId, are found, scan will break . \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A error listed in \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} (NoError on success) . 
\end{DoxyReturn}


Reimplemented in \hyperlink{classmdt_device_modbus_wago_aeebc68749c2e22beacd18d85cc0b313a}{mdtDeviceModbusWago}.



Definition at line 211 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_abfcab17fbf05aab7843ae689316dd01f}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!connectToDevice@{connectToDevice}}
\index{connectToDevice@{connectToDevice}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{connectToDevice}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtDeviceModbus::connectToDevice (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_modbus_abfcab17fbf05aab7843ae689316dd01f}


Search and connect to physical device. 

Will connect to device with hardwareNodeId set with \hyperlink{classmdt_device_modbus_a64bfa566dbd8511e11d76c0b14191f17}{setHardwareNodeId()} . This method will beginn to scan hosts in cache file (if exists) . If expcted device was not found, the network is also scanned .

If all devices that must be scanned have a known hardwareNodeId, please consider using \hyperlink{classmdt_device_modbus_a08100215b37c0922ed177d1f99d07e97}{connectToDevice(const QList$<$int$>$\&)} , wtch can be faster .

\begin{DoxyReturn}{Returns}
A error listed in \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} (NoError on success) .
\end{DoxyReturn}
\begin{Desc}
\item[\hyperlink{todo__todo000011}{Todo}]Not implemented yet . \end{Desc}


Definition at line 255 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a3ca2a84163fed1380cbc8859a6b70db0}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!connectToDevice@{connectToDevice}}
\index{connectToDevice@{connectToDevice}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{connectToDevice}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtDeviceModbus::connectToDevice (
\begin{DoxyParamCaption}
\item[{const {\bf mdtPortInfo} \&}]{portInfo}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_device_modbus_a3ca2a84163fed1380cbc8859a6b70db0}


Connect to physical device. 

This method can be reimplemented in subclass if specific tasks must be done during connection .


\begin{DoxyParams}{Parameters}
{\em portInfo} & \hyperlink{classmdt_port_info}{mdtPortInfo} object . The portName attribute of portInfo must contain host:port format (or ip:port) . \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A error listed in \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} (NoError on success) . 
\end{DoxyReturn}


Reimplemented in \hyperlink{classmdt_device_modbus_wago_ac15c95cee8dec98609278d0e0ab2b3ce}{mdtDeviceModbusWago}.



Definition at line 92 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a093c6407ee69c4c7696a0c71d0acd88d}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!connectToDevice@{connectToDevice}}
\index{connectToDevice@{connectToDevice}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{connectToDevice}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtDeviceModbus::connectToDevice (
\begin{DoxyParamCaption}
\item[{const {\bf mdtDeviceInfo} \&}]{devInfo}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_device_modbus_a093c6407ee69c4c7696a0c71d0acd88d}


Search and connect to physical device. 

Will scan available ports and open the first port that has device attached maching request.

\begin{DoxySeeAlso}{See also}
connectToDevice(mdtPortInfo\&) .
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em devInfo} & Requested device's informations (can be empty, no information is used in current version). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A error listed in \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} (NoError on success) 
\end{DoxyReturn}


pvTcpPortManager-\/$>$setPortInfo($\ast$portInfoList.at(i)); if(!pvTcpPortManager-\/$>$\hyperlink{classmdt_device_a721c5bf2cfa0eef5304333f08da182f7}{start()})\{ continue; \} Connected, check if device is a Wago 750 if(isWago750())\{ qDeleteAll(portInfoList); qDebug() $<$$<$ \char`\"{}mdtDeviceModbusWago::connectToDevice() : Is a Wago 750\char`\"{}; return \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eab898bd273effe5cb4ed1a399a2d4baad}{mdtAbstractPort::NoError}; \} pvTcpPortManager-\/$>$\hyperlink{classmdt_device_adc7ff8f01d68506283a3d0cc6bc25407}{stop()};

qDebug() $<$$<$ \char`\"{}mdtDeviceModbusWago::connectToDevice() : Trying \char`\"{} $<$$<$ portInfoList.at(i)-\/$>$portName() $<$$<$ \char`\"{} ...\char`\"{}; pvTcpPortManager-\/$>$setPortInfo($\ast$portInfoList.at(i)); if(!pvTcpPortManager-\/$>$\hyperlink{classmdt_device_a721c5bf2cfa0eef5304333f08da182f7}{start()})\{ continue; \} qDebug() $<$$<$ \char`\"{}mdtDeviceModbusWago::connectToDevice() : Running ...\char`\"{}; Connected, check if device is a Wago 750 if(isWago750())\{ pvTcpPortManager-\/$>$saveScanResult(portInfoList); qDeleteAll(portInfoList); qDebug() $<$$<$ \char`\"{}mdtDeviceModbusWago::connectToDevice() : Is a Wago 750\char`\"{}; return \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eab898bd273effe5cb4ed1a399a2d4baad}{mdtAbstractPort::NoError}; \} pvTcpPortManager-\/$>$\hyperlink{classmdt_device_adc7ff8f01d68506283a3d0cc6bc25407}{stop()};



Reimplemented from \hyperlink{classmdt_device_abab1b6e45af527880ce469ae318474c0}{mdtDevice}.



Reimplemented in \hyperlink{classmdt_device_modbus_wago_a025f0411a708a529054a0e3c0b6461cd}{mdtDeviceModbusWago}.



Definition at line 106 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a89d41c6b33a3dd2a92a0956d8e6b3b14}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!getRegisterValues@{getRegisterValues}}
\index{getRegisterValues@{getRegisterValues}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{getRegisterValues}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtDeviceModbus::getRegisterValues (
\begin{DoxyParamCaption}
\item[{int}]{address, }
\item[{int}]{n}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_modbus_a89d41c6b33a3dd2a92a0956d8e6b3b14}


Helper method for register service. 

Usefull to get resgister values (f.ex. configurations regsisters, ...).

Note: to get analog I/O values, the \hyperlink{classmdt_device}{mdtDevice} API should be used.

\begin{DoxyReturn}{Returns}
True on success. Values are the available with \hyperlink{classmdt_device_modbus_a83cb2a28111653fbcbbe748f7a1a2e3d}{registerValues()} 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
address and n must be $>$ 0 
\end{DoxyPrecond}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_modbus_tcp_port_manager_ab5e780409492b5f56326a870bc4262ec}{mdtModbusTcpPortManager::getRegisterValues()} 
\end{DoxySeeAlso}


Definition at line 261 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_ab5e3f041a24d895dbe739a9229d4fd27}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!hardwareNodeId@{hardwareNodeId}}
\index{hardwareNodeId@{hardwareNodeId}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{hardwareNodeId}]{\setlength{\rightskip}{0pt plus 5cm}QVariant mdtDeviceModbus::hardwareNodeId (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_device_modbus_ab5e3f041a24d895dbe739a9229d4fd27}


Get hardware node id. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_device_modbus_a64bfa566dbd8511e11d76c0b14191f17}{setHardwareNodeId()} . 
\end{DoxySeeAlso}


Definition at line 87 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a3b83b926ed1f9c3bdf7024de2745c285}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!queriesSequence@{queriesSequence}}
\index{queriesSequence@{queriesSequence}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{queriesSequence}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtDeviceModbus::queriesSequence (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a3b83b926ed1f9c3bdf7024de2745c285}


Sequence of queries to send periodically. 

This method is called from \hyperlink{classmdt_device_a14634fec6cd6bae810562b3bd88a5c05}{runQueries()}.

\begin{DoxyReturn}{Returns}
true if all queries are sent successfully.
\end{DoxyReturn}
Subclass notes:\par

\begin{DoxyItemize}
\item This default implementation does nothing and allways returns false.
\item This method can be reimplemented periodic queries must be sent to device. 
\end{DoxyItemize}

Reimplemented from \hyperlink{classmdt_device_acba50968d201ad95c4eaa2ab2ed48b4f}{mdtDevice}.



Definition at line 462 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_aa2a024793ae2a5e81c7e92260a70cd9e}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readAnalogInput@{readAnalogInput}}
\index{readAnalogInput@{readAnalogInput}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readAnalogInput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readAnalogInput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_aa2a024793ae2a5e81c7e92260a70cd9e}


Update (G)UI when device's state has changed. 

void onStateChanged(int state);

Read one analog input on physical device

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from getAnalogInput().


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details). 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with setIos(). 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_acecf7934ce29b3a957accb0f4c98c746}{mdtDevice}.



Definition at line 474 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a846af6dbf80bbf747f3f966420ef6f92}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readAnalogInputs@{readAnalogInputs}}
\index{readAnalogInputs@{readAnalogInputs}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readAnalogInputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readAnalogInputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a846af6dbf80bbf747f3f966420ef6f92}


Read all analog inputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a98cba3132db15317daf54eb701388e91}{getAnalogInputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with setIos(). 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_a40674e7bf0c367bb3edb407d73a5bd8e}{mdtDevice}.



Definition at line 491 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a30c815cbe5e603e8114dcbc09849e322}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readAnalogOutput@{readAnalogOutput}}
\index{readAnalogOutput@{readAnalogOutput}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readAnalogOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readAnalogOutput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a30c815cbe5e603e8114dcbc09849e322}


Read one analog output on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a163ee286d905feafe50b3e4351d4bf41}{getAnalogOutputValue()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with setIos(). 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_a7934063c3f41a742515f1232c9598c2a}{mdtDevice}.



Definition at line 508 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_ae02dd44f1d873fcc15ff75d781b62b0b}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readAnalogOutputs@{readAnalogOutputs}}
\index{readAnalogOutputs@{readAnalogOutputs}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readAnalogOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readAnalogOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_ae02dd44f1d873fcc15ff75d781b62b0b}


Read all analog outputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a163ee286d905feafe50b3e4351d4bf41}{getAnalogOutputValue()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with setIos(). 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_ab0232ac83c38bc93d3bc2aa91d94c291}{mdtDevice}.



Definition at line 525 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a9dd05e51223ee5bb79970fbe84c501f9}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readDigitalInput@{readDigitalInput}}
\index{readDigitalInput@{readDigitalInput}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readDigitalInput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readDigitalInput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a9dd05e51223ee5bb79970fbe84c501f9}


Read one digital input on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital inputs, this method should be implemented.

This method is called from getDigitalInputState().


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with setIos(). 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_af128b606050035abaf8d049bb2227015}{mdtDevice}.



Definition at line 578 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a3fba9e113092f9da187cf684fb62b132}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readDigitalInputs@{readDigitalInputs}}
\index{readDigitalInputs@{readDigitalInputs}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readDigitalInputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readDigitalInputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a3fba9e113092f9da187cf684fb62b132}


Read all digital inputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a6e338b959c86591b6b3401f925c49050}{getDigitalInputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with setIos(). 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_a150e3abae6db5bf1ad11017bf2b76c14}{mdtDevice}.



Definition at line 595 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a13a334ac86135751893f37064d8f548d}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readDigitalOutput@{readDigitalOutput}}
\index{readDigitalOutput@{readDigitalOutput}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readDigitalOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readDigitalOutput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a13a334ac86135751893f37064d8f548d}


Read one digital output on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from getDigitalOutputState().


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with setIos(). 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_a1faee6ab31b094731211ea0943544501}{mdtDevice}.



Definition at line 612 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a8915a036472bff0f356756992c1eae51}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readDigitalOutputs@{readDigitalOutputs}}
\index{readDigitalOutputs@{readDigitalOutputs}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readDigitalOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readDigitalOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a8915a036472bff0f356756992c1eae51}


Read all digital outputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_ab35b81b8eb68e161ac06ae882be39a25}{getDigitalOutputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with setIos(). 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_aac038c24c3b91757584bdf0d09fb8b02}{mdtDevice}.



Definition at line 629 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a83cb2a28111653fbcbbe748f7a1a2e3d}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!registerValues@{registerValues}}
\index{registerValues@{registerValues}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{registerValues}]{\setlength{\rightskip}{0pt plus 5cm}const QList$<$ int $>$ \& mdtDeviceModbus::registerValues (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_device_modbus_a83cb2a28111653fbcbbe748f7a1a2e3d}


Helper method for register service. 

Return result set by \hyperlink{classmdt_device_modbus_a89d41c6b33a3dd2a92a0956d8e6b3b14}{getRegisterValues()}. Note that values are keeped until next call of \hyperlink{classmdt_device_modbus_a89d41c6b33a3dd2a92a0956d8e6b3b14}{getRegisterValues()}.

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_modbus_tcp_port_manager_a99a13b5250a8523aa63869991581e56a}{mdtModbusTcpPortManager::registerValues()} 
\end{DoxySeeAlso}


Definition at line 266 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a64bfa566dbd8511e11d76c0b14191f17}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!setHardwareNodeId@{setHardwareNodeId}}
\index{setHardwareNodeId@{setHardwareNodeId}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{setHardwareNodeId}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDeviceModbus::setHardwareNodeId (
\begin{DoxyParamCaption}
\item[{int}]{hwNodeId, }
\item[{int}]{bitsCount, }
\item[{int}]{startFrom = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_modbus_a64bfa566dbd8511e11d76c0b14191f17}


Set hardware node id. 


\begin{DoxyParams}{Parameters}
{\em hardwareNodeId} & See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{mdtModbusTcpPortManager::getHardwareNodeAddress()} . \\
\hline
{\em bitsCount} & See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{mdtModbusTcpPortManager::getHardwareNodeAddress()} . \\
\hline
{\em startFrom} & See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{mdtModbusTcpPortManager::getHardwareNodeAddress()} . \\
\hline
\end{DoxyParams}


Definition at line 73 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a4128420bde679c3666bdf8954a221a53}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!setRegisterValues@{setRegisterValues}}
\index{setRegisterValues@{setRegisterValues}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{setRegisterValues}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtDeviceModbus::setRegisterValues (
\begin{DoxyParamCaption}
\item[{int}]{startAddress, }
\item[{QList$<$ int $>$ \&}]{values}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_modbus_a4128420bde679c3666bdf8954a221a53}


Helper method for register service. 

Usefull to set register values (f.ex. configurations regsisters, ...).

Note: to set analog I/O values, the \hyperlink{classmdt_device}{mdtDevice} API should be used.

\begin{DoxyReturn}{Returns}
True on success. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
startAddress must be $>$= 0 
\end{DoxyPrecond}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_modbus_tcp_port_manager_a746211413dfafb987a93145c9fa4876f}{mdtModbusTcpPortManager::setRegisterValues()} 
\end{DoxySeeAlso}


Definition at line 271 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_ac63297a31205759622f341525c34251f}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!writeAnalogOutput@{writeAnalogOutput}}
\index{writeAnalogOutput@{writeAnalogOutput}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{writeAnalogOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::writeAnalogOutput (
\begin{DoxyParamCaption}
\item[{int}]{value, }
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_ac63297a31205759622f341525c34251f}


Write value on a analog output to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a766d9adcf8c2274f61f120a4a5c5c6d9}{setAnalogOutputValue()}.


\begin{DoxyParams}{Parameters}
{\em value} & Value encoded regarding device format. \\
\hline
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with setIos(). 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_ae764634bba2b321ac2b4731c0353e45f}{mdtDevice}.



Definition at line 542 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_aa09d1682bef4bbc08b59b20110e613ff}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!writeAnalogOutputs@{writeAnalogOutputs}}
\index{writeAnalogOutputs@{writeAnalogOutputs}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{writeAnalogOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::writeAnalogOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction, }
\item[{{\bf mdtDeviceIosSegment} $\ast$}]{segment}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_aa09d1682bef4bbc08b59b20110e613ff}


Write all analog outputs to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a57e1cee7e670469035c57e3bd2ff4c9d}{setAnalogOutputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with setIos(). 

transaction must be a valid pointer. 
\end{DoxyPrecond}


pdu = pvCodec-\/$>$encodeWriteMultipleRegisters(transaction-\/$>$address(), \hyperlink{classmdt_device_adb7099877ad2080961fae5a40117e9e5}{ios()}-\/$>$analogOutputsValuesIntByAddressWrite()); 



Reimplemented from \hyperlink{classmdt_device_a2d82cb0920e4e0628186e59f9b4de7d4}{mdtDevice}.



Definition at line 559 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a6950c10fc521b193fb3c754223879694}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!writeDigitalOutput@{writeDigitalOutput}}
\index{writeDigitalOutput@{writeDigitalOutput}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{writeDigitalOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::writeDigitalOutput (
\begin{DoxyParamCaption}
\item[{bool}]{state, }
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a6950c10fc521b193fb3c754223879694}


Write state on a digital output to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from setDigitalOutputState().


\begin{DoxyParams}{Parameters}
{\em state} & State (ON/OFF). \\
\hline
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with setIos(). 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_a0fbe57503d86554829e708b2b83d73f1}{mdtDevice}.



Definition at line 646 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a6713edaee0bfba48791008124299b753}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!writeDigitalOutputs@{writeDigitalOutputs}}
\index{writeDigitalOutputs@{writeDigitalOutputs}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{writeDigitalOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::writeDigitalOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction, }
\item[{{\bf mdtDeviceIosSegment} $\ast$}]{segment}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a6713edaee0bfba48791008124299b753}


Write all digital outputs to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a7b86a816e55a91f0d62426e1741437c6}{setDigitalOutputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with setIos(). 

transaction must be a valid pointer. 
\end{DoxyPrecond}


pdu = pvCodec-\/$>$encodeWriteMultipleCoils(transaction-\/$>$address(), \hyperlink{classmdt_device_adb7099877ad2080961fae5a40117e9e5}{ios()}-\/$>$digitalOutputsStatesByAddressWrite()); 



Reimplemented from \hyperlink{classmdt_device_ae644ab1ef0ebb57d6d9d502829907ec1}{mdtDevice}.



Definition at line 663 of file mdtDeviceModbus.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtdevice/mdtDeviceModbus.h\item 
src/mdtdevice/mdtDeviceModbus.cpp\end{DoxyCompactItemize}
