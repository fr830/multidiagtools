<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Multi diag tools: mdtBuffer&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Multi diag tools
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmdt_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mdtBuffer&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Stockage d'éléments basé sur le principe du tampon circulaire.  
 <a href="classmdt_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mdt_buffer_8h_source.html">mdtBuffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a51bc78e5a9fc926c7b898160c6a2faa3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a51bc78e5a9fc926c7b898160c6a2faa3">mdtBuffer</a> ()</td></tr>
<tr class="memdesc:a51bc78e5a9fc926c7b898160c6a2faa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur.  <a href="#a51bc78e5a9fc926c7b898160c6a2faa3">More...</a><br/></td></tr>
<tr class="separator:a51bc78e5a9fc926c7b898160c6a2faa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6c140c02257fffb37016d019e412cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a4d6c140c02257fffb37016d019e412cf">mdtBuffer</a> (<a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:a4d6c140c02257fffb37016d019e412cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur de copie.  <a href="#a4d6c140c02257fffb37016d019e412cf">More...</a><br/></td></tr>
<tr class="separator:a4d6c140c02257fffb37016d019e412cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9a31eb29a39a2721205f13f80c1d8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#aba9a31eb29a39a2721205f13f80c1d8d">operator=</a> (<a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:aba9a31eb29a39a2721205f13f80c1d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opérateur de copie.  <a href="#aba9a31eb29a39a2721205f13f80c1d8d">More...</a><br/></td></tr>
<tr class="separator:aba9a31eb29a39a2721205f13f80c1d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54de4cebee3cab7b8c1b86bfc3bdad4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a54de4cebee3cab7b8c1b86bfc3bdad4f">~mdtBuffer</a> ()</td></tr>
<tr class="memdesc:a54de4cebee3cab7b8c1b86bfc3bdad4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructeur.  <a href="#a54de4cebee3cab7b8c1b86bfc3bdad4f">More...</a><br/></td></tr>
<tr class="separator:a54de4cebee3cab7b8c1b86bfc3bdad4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d081b06f666fec3ff6e12ec94b2a4fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a9d081b06f666fec3ff6e12ec94b2a4fd">init</a> (size_t size)</td></tr>
<tr class="memdesc:a9d081b06f666fec3ff6e12ec94b2a4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialisation du tampon.  <a href="#a9d081b06f666fec3ff6e12ec94b2a4fd">More...</a><br/></td></tr>
<tr class="separator:a9d081b06f666fec3ff6e12ec94b2a4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697920838a6c786209607c2b6ac0858a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a697920838a6c786209607c2b6ac0858a">clear</a> ()</td></tr>
<tr class="memdesc:a697920838a6c786209607c2b6ac0858a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efface le contenu du tampon.  <a href="#a697920838a6c786209607c2b6ac0858a">More...</a><br/></td></tr>
<tr class="separator:a697920838a6c786209607c2b6ac0858a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe03f0413ff7512d63d8df1408c66f63"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#abe03f0413ff7512d63d8df1408c66f63">put</a> (const T *data, size_t len)</td></tr>
<tr class="memdesc:abe03f0413ff7512d63d8df1408c66f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stockage d'un lot de données.  <a href="#abe03f0413ff7512d63d8df1408c66f63">More...</a><br/></td></tr>
<tr class="separator:abe03f0413ff7512d63d8df1408c66f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9fd3a6b593c2e874249aba5c305e34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a2b9fd3a6b593c2e874249aba5c305e34">putOne</a> (T data)</td></tr>
<tr class="memdesc:a2b9fd3a6b593c2e874249aba5c305e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stockage d'un élément par copie.  <a href="#a2b9fd3a6b593c2e874249aba5c305e34">More...</a><br/></td></tr>
<tr class="separator:a2b9fd3a6b593c2e874249aba5c305e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7beeb199f0cce529549e61ff949a9ffa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a7beeb199f0cce529549e61ff949a9ffa">putUntil</a> (const T *data, T token, size_t maxLen, bool IgnoreNullValues)</td></tr>
<tr class="memdesc:a7beeb199f0cce529549e61ff949a9ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stockage d'un lot de données jusqu'à la rencontre d'un élément.  <a href="#a7beeb199f0cce529549e61ff949a9ffa">More...</a><br/></td></tr>
<tr class="separator:a7beeb199f0cce529549e61ff949a9ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddc3c27c154fbfd077f83d5bfe82a19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a6ddc3c27c154fbfd077f83d5bfe82a19">tokenReached</a> ()</td></tr>
<tr class="memdesc:a6ddc3c27c154fbfd077f83d5bfe82a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne true si l'élément de fin de copie à été atteint.  <a href="#a6ddc3c27c154fbfd077f83d5bfe82a19">More...</a><br/></td></tr>
<tr class="separator:a6ddc3c27c154fbfd077f83d5bfe82a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6eddf7ccc533da855ebd112202a656f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#aa6eddf7ccc533da855ebd112202a656f">capacity</a> ()</td></tr>
<tr class="memdesc:aa6eddf7ccc533da855ebd112202a656f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capacité totale.  <a href="#aa6eddf7ccc533da855ebd112202a656f">More...</a><br/></td></tr>
<tr class="separator:aa6eddf7ccc533da855ebd112202a656f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e8317b6ba09e9c4e26358e27f75fd6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a78e8317b6ba09e9c4e26358e27f75fd6">remainCapacity</a> ()</td></tr>
<tr class="memdesc:a78e8317b6ba09e9c4e26358e27f75fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capacité restante.  <a href="#a78e8317b6ba09e9c4e26358e27f75fd6">More...</a><br/></td></tr>
<tr class="separator:a78e8317b6ba09e9c4e26358e27f75fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e2b6b5e7656a5285d0ea1d152ea499"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a63e2b6b5e7656a5285d0ea1d152ea499">full</a> ()</td></tr>
<tr class="memdesc:a63e2b6b5e7656a5285d0ea1d152ea499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Déterminer si le tampon est plein.  <a href="#a63e2b6b5e7656a5285d0ea1d152ea499">More...</a><br/></td></tr>
<tr class="separator:a63e2b6b5e7656a5285d0ea1d152ea499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ca1a2d00ba1623416ec747ba440adf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a24ca1a2d00ba1623416ec747ba440adf">available</a> ()</td></tr>
<tr class="memdesc:a24ca1a2d00ba1623416ec747ba440adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nombre d'éléments disponibles en lecture.  <a href="#a24ca1a2d00ba1623416ec747ba440adf">More...</a><br/></td></tr>
<tr class="separator:a24ca1a2d00ba1623416ec747ba440adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123a85c9cd59f80623aba5589709050e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a123a85c9cd59f80623aba5589709050e">get</a> (T *data, size_t len)</td></tr>
<tr class="memdesc:a123a85c9cd59f80623aba5589709050e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lecture d'un lot de données.  <a href="#a123a85c9cd59f80623aba5589709050e">More...</a><br/></td></tr>
<tr class="separator:a123a85c9cd59f80623aba5589709050e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e0f5bce9faea0f7c7195ff5377458c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a58e0f5bce9faea0f7c7195ff5377458c">take</a> (T *data, size_t len)</td></tr>
<tr class="memdesc:a58e0f5bce9faea0f7c7195ff5377458c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrait d'un lot de données.  <a href="#a58e0f5bce9faea0f7c7195ff5377458c">More...</a><br/></td></tr>
<tr class="separator:a58e0f5bce9faea0f7c7195ff5377458c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690e3f41a62175de48bc73c19f69208d"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a690e3f41a62175de48bc73c19f69208d">takeOne</a> ()</td></tr>
<tr class="memdesc:a690e3f41a62175de48bc73c19f69208d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrait d'un élément.  <a href="#a690e3f41a62175de48bc73c19f69208d">More...</a><br/></td></tr>
<tr class="separator:a690e3f41a62175de48bc73c19f69208d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class mdtBuffer&lt; T &gt;</h3>

<p>Stockage d'éléments basé sur le principe du tampon circulaire. </p>
<p>#if USE_ASSERT == 1 #undef NDEBUG #else #define NDEBUG #endif</p>
<p>Stockage d'éléments basé sur le principe du tampon circulaire Idéal pour le stockage temporaire si une taille maximale est connue. Evite de nombreuses allocations/libération mémoire </p>

<p>Definition at line <a class="el" href="mdt_buffer_8h_source.html#l00039">39</a> of file <a class="el" href="mdt_buffer_8h_source.html">mdtBuffer.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a51bc78e5a9fc926c7b898160c6a2faa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::<a class="el" href="classmdt_buffer.html">mdtBuffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur. </p>
<p>Constructeur, utiliser <a class="el" href="classmdt_buffer.html#a9d081b06f666fec3ff6e12ec94b2a4fd" title="Initialisation du tampon. ">init()</a> avant tout autre opération </p>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00007">7</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d6c140c02257fffb37016d019e412cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::<a class="el" href="classmdt_buffer.html">mdtBuffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur de copie. </p>
<p>Constructeur de copie. Effectue une copie des données vers l'autre instance </p>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00016">16</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

<p>References <a class="el" href="mdt_buffer_8cpp_source.html#l00236">mdtBuffer&lt; T &gt;::available()</a>, <a class="el" href="mdt_buffer_8cpp_source.html#l00221">mdtBuffer&lt; T &gt;::capacity()</a>, and <a class="el" href="mdt_buffer_8cpp_source.html#l00241">mdtBuffer&lt; T &gt;::get()</a>.</p>

</div>
</div>
<a class="anchor" id="a54de4cebee3cab7b8c1b86bfc3bdad4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::~<a class="el" href="classmdt_buffer.html">mdtBuffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructeur. </p>
<p>Destructeur </p>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00059">59</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a24ca1a2d00ba1623416ec747ba440adf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template size_t <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nombre d'éléments disponibles en lecture. </p>
<p>Nombre d'éléments disponibles en lecture</p>
<dl class="section return"><dt>Returns</dt><dd>Le nombre d'éléments qu'il est possible de lire </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00236">236</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

<p>Referenced by <a class="el" href="mdt_buffer_8cpp_source.html#l00016">mdtBuffer&lt; T &gt;::mdtBuffer()</a>, and <a class="el" href="mdt_buffer_8cpp_source.html#l00038">mdtBuffer&lt; T &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6eddf7ccc533da855ebd112202a656f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template size_t <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Capacité totale. </p>
<p>Capacité totale</p>
<dl class="section return"><dt>Returns</dt><dd>La capacité totale du tampon </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00221">221</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

<p>Referenced by <a class="el" href="mdt_buffer_8cpp_source.html#l00016">mdtBuffer&lt; T &gt;::mdtBuffer()</a>, and <a class="el" href="mdt_buffer_8cpp_source.html#l00038">mdtBuffer&lt; T &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a697920838a6c786209607c2b6ac0858a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Efface le contenu du tampon. </p>
<p>Efface le contenu du tampon. La quantité disponible ainsi que la capacité restante sont aussi ré-initialisés </p>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00088">88</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63e2b6b5e7656a5285d0ea1d152ea499"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::full </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Déterminer si le tampon est plein. </p>
<p>Déterminer si le tampon est plein</p>
<dl class="section return"><dt>Returns</dt><dd>True si le tampon est plein </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00231">231</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a123a85c9cd59f80623aba5589709050e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template size_t <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lecture d'un lot de données. </p>
<p>La copie, basée sur memcpy, est performante Le cusreur de lecture interne, ainsi que le quantité disponible et la capacité restante ne sont pas altérés (plusieurs appels à cette méthode renverrait chaque fois les même données)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointeur vers les données de destination </td></tr>
    <tr><td class="paramname">len</td><td>Nombre d'éléments à lire</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Le nombre d'éléments effectivement lus </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00241">241</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

<p>Referenced by <a class="el" href="mdt_buffer_8cpp_source.html#l00016">mdtBuffer&lt; T &gt;::mdtBuffer()</a>, and <a class="el" href="mdt_buffer_8cpp_source.html#l00038">mdtBuffer&lt; T &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d081b06f666fec3ff6e12ec94b2a4fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialisation du tampon. </p>
<p>Initialisation du tampon. Alloue la mémoire, initialise les données à une valeur nulle. Il est possible de ré-appeler cette fonction plusieurs fois, la zone mémoire étant alors ré-alouée</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Capacité du tampon [nombre d'éléments]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false en cas de problème d'allocation mémoire (true si tout s'est bien passé) </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00066">66</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba9a31eb29a39a2721205f13f80c1d8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; char &gt; &amp; <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opérateur de copie. </p>
<p>Opérateur de copie. Effectue une copie des données vers l'autre instance </p>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00038">38</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

<p>References <a class="el" href="mdt_buffer_8cpp_source.html#l00236">mdtBuffer&lt; T &gt;::available()</a>, <a class="el" href="mdt_buffer_8cpp_source.html#l00221">mdtBuffer&lt; T &gt;::capacity()</a>, and <a class="el" href="mdt_buffer_8cpp_source.html#l00241">mdtBuffer&lt; T &gt;::get()</a>.</p>

</div>
</div>
<a class="anchor" id="abe03f0413ff7512d63d8df1408c66f63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template size_t <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stockage d'un lot de données. </p>
<p>Stockage d'un lot de données par copie. La copie, basée sur memcpy, est performante</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointeur vers les données sources </td></tr>
    <tr><td class="paramname">len</td><td>Nombre d'éléments à stocker</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Le nombre d'éléments effectivement stockés </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00107">107</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b9fd3a6b593c2e874249aba5c305e34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::putOne </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stockage d'un élément par copie. </p>
<p>Stockage d'un élément par copie.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Elément à stocker</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True si Ok, false en cas d'erreur </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00155">155</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

<p>References <a class="el" href="mdt_buffer_8h_source.html#l00006">incWrCursor</a>.</p>

</div>
</div>
<a class="anchor" id="a7beeb199f0cce529549e61ff949a9ffa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template size_t <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::putUntil </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>IgnoreNullValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stockage d'un lot de données jusqu'à la rencontre d'un élément. </p>
<p>Stockage d'un lot de données par copie jusqu'à la rencontre d'un élément, ou maxLen si l'élément recherché n'est pas trouvé. L'élément de recherche est aussi stocké La copie, basée sur une boucle, est relativement lente (comparé à memcpy) Il est possible de ne pas stocker les caractères null ('\0')</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointeur vers les données sources </td></tr>
    <tr><td class="paramname">token</td><td>Elément désignant la fin de la copie </td></tr>
    <tr><td class="paramname">Maxlen</td><td>Nombre d'éléments maximal à stocker </td></tr>
    <tr><td class="paramname">IgnoreNullValues</td><td>Si true, les éléments null (0) ne seront pas stockés</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Le nombre d'éléments effectivement stockés </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00175">175</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

<p>References <a class="el" href="mdt_buffer_8h_source.html#l00006">incWrCursor</a>.</p>

</div>
</div>
<a class="anchor" id="a78e8317b6ba09e9c4e26358e27f75fd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template size_t <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::remainCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Capacité restante. </p>
<p>Capacité restante</p>
<dl class="section return"><dt>Returns</dt><dd>Le nombre d'éléments qu'il est encore possible de stocker </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00226">226</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58e0f5bce9faea0f7c7195ff5377458c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template size_t <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::take </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrait d'un lot de données. </p>
<p>Retrait d'un lot de données par copie. La copie, basée sur memcpy, et performante Le cusreur de lecture interne, ainsi que le quantité disponible et la capacité restante sont altérés</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointeur vers les données de destination </td></tr>
    <tr><td class="paramname">len</td><td>Nombre d'éléments à lire</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Le nombre d'éléments effectivement retirés </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00280">280</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a690e3f41a62175de48bc73c19f69208d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template std::string <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::takeOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrait d'un élément. </p>
<p>Retrait d'un élément Le cusreur de lecture interne, ainsi que le quantité disponible et la capacité restante sont altérés Test retour: 0 est retourné si aucun élément n'est disponible. Etant donnée que 0 peut très bien être un élément valide stocké dans le tampon, il faut utiliser une méthode de test avant le retrait. Voir <a class="el" href="classmdt_buffer.html#a24ca1a2d00ba1623416ec747ba440adf" title="Nombre d&#39;éléments disponibles en lecture. ">available()</a></p>
<dl class="section return"><dt>Returns</dt><dd>Un élément, ou 0 si aucune disponibilité </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00326">326</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

<p>References <a class="el" href="mdt_buffer_8h_source.html#l00013">incRdCursor</a>.</p>

</div>
</div>
<a class="anchor" id="a6ddc3c27c154fbfd077f83d5bfe82a19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::tokenReached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retourne true si l'élément de fin de copie à été atteint. </p>
<p>Retourne true si l'élément de fin de copie à été atteint Voir la méthode <a class="el" href="classmdt_buffer.html#a7beeb199f0cce529549e61ff949a9ffa" title="Stockage d&#39;un lot de données jusqu&#39;à la rencontre d&#39;un élément. ">putUntil()</a> Ce flag est effacé par un appel de la méthode <a class="el" href="classmdt_buffer.html#a58e0f5bce9faea0f7c7195ff5377458c" title="Retrait d&#39;un lot de données. ">take()</a> , même si l'élément n'est pas "consommé" <a class="el" href="classmdt_buffer.html#a697920838a6c786209607c2b6ac0858a" title="Efface le contenu du tampon. ">clear()</a> efface aussi ce flag</p>
<dl class="section return"><dt>Returns</dt><dd>True si l'élément de fin à été atteint </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00216">216</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/mdtutils/<a class="el" href="mdt_buffer_8h_source.html">mdtBuffer.h</a></li>
<li>src/mdtutils/<a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 27 2015 17:17:44 for Multi diag tools by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
