\hypertarget{classmdt_usb_port}{
\section{mdtUsbPort Class Reference}
\label{classmdt_usb_port}\index{mdtUsbPort@{mdtUsbPort}}
}


USB port I/O port class.  




{\ttfamily \#include $<$mdtUsbPort.h$>$}



Inheritance diagram for mdtUsbPort:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=168pt]{classmdt_usb_port__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtUsbPort:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=324pt]{classmdt_usb_port__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_usb_port_a311650f4b2d29b6f16336c8777196d1c}{
{\bfseries mdtUsbPort} (QObject $\ast$parent=0)}
\label{classmdt_usb_port_a311650f4b2d29b6f16336c8777196d1c}

\item 
\hypertarget{classmdt_usb_port_afa9f1942ca4ae384887441e01b362c16}{
\hyperlink{classmdt_usb_port_afa9f1942ca4ae384887441e01b362c16}{$\sim$mdtUsbPort} ()}
\label{classmdt_usb_port_afa9f1942ca4ae384887441e01b362c16}

\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_af2399348faf1abc20130eab20cfc36ee}{reconnect} (int timeout)
\begin{DoxyCompactList}\small\item\em Reconnect device. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_a44ed5024a81a573b5196b8f64c42cd6a}{setReadTimeout} (int timeout)
\begin{DoxyCompactList}\small\item\em Set the read data timeout. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_a592af88bd7e7f45dd80df0ecab375ace}{setWriteTimeout} (int timeout)
\begin{DoxyCompactList}\small\item\em Set the write data timeout. \end{DoxyCompactList}\item 
QQueue$<$ \hyperlink{classmdt_frame_usb_control}{mdtFrameUsbControl} $\ast$ $>$ \& \hyperlink{classmdt_usb_port_af146b08006ddbe18fb537ae1a75b622e}{controlFramesPool} ()
\begin{DoxyCompactList}\small\item\em Get the control pool queue. \end{DoxyCompactList}\item 
QQueue$<$ \hyperlink{classmdt_frame_usb_control}{mdtFrameUsbControl} $\ast$ $>$ \& \hyperlink{classmdt_usb_port_afbb20c403e7a5885d5e4221bab9f304e}{controlQueryFrames} ()
\begin{DoxyCompactList}\small\item\em Get the control query queue. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_a4fbcd0fcc179335c55c6d7ccc40a7c31}{addControlRequest} (\hyperlink{classmdt_frame_usb_control}{mdtFrameUsbControl} $\ast$frame, bool setwIndexAsbInterfaceNumber=false)
\begin{DoxyCompactList}\small\item\em Add a control request. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_a274b6fd10bd84027bb66773ed805de2a}{submitControlQuery} ()
\begin{DoxyCompactList}\small\item\em Submit a control query. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a6566e654df8a1c3503941702593db3c5}{cancelControlTransfer} ()
\begin{DoxyCompactList}\small\item\em Cancel current control transfer. \end{DoxyCompactList}\item 
QQueue$<$ \hyperlink{classmdt_frame_usb_control}{mdtFrameUsbControl} $\ast$ $>$ \& \hyperlink{classmdt_usb_port_a304825c7d9173a3dcb5e26a412f1038b}{controlResponseFrames} ()
\begin{DoxyCompactList}\small\item\em Get the control responses queue. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_a719fc7b43461a3e2d9a4926d3e3961c2}{requestReadUntilShortPacketReceived} ()
\begin{DoxyCompactList}\small\item\em Request to read until a short packet is received. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_usb_port_a3c0685d67fe608abe24c140c2858779c}{readUntilShortPacketReceivedRequestPending} ()
\begin{DoxyCompactList}\small\item\em Check if a request to read until a short packet is received is pending. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_a9f4f09dac3f09b1766072cd9c1292ab1}{addbTagToAbort} (quint8 bTag)
\begin{DoxyCompactList}\small\item\em add a bulk IN bTag to abort \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usb_port_a43e3102b004f213ecc01b17f31607957}{takebTagToAbort} ()
\begin{DoxyCompactList}\small\item\em Get a bTag to abort in pending queue. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usb_port_af546a031ed8621fee1d5e9498cbcd174}{readBufferSize} () const 
\begin{DoxyCompactList}\small\item\em Get read buffer size. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a5e380852b8726f71e8558c86cba5bd1f}{initReadTransfer} (qint64 maxSize)
\begin{DoxyCompactList}\small\item\em Submit a read transfer. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a3570b708f9f51408e4bbf2f61cc8c881}{cancelReadTransfer} ()
\begin{DoxyCompactList}\small\item\em Cancel current bulk/interrupt input transfer. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_ab8ddd4ebee603ac381e8da0383a61e36}{waitForReadyRead} ()
\begin{DoxyCompactList}\small\item\em Wait until data is available on port. \end{DoxyCompactList}\item 
qint64 \hyperlink{classmdt_usb_port_abce257345c8af47494215cd7ee75f82d}{read} (char $\ast$data, qint64 maxSize)
\begin{DoxyCompactList}\small\item\em Read data from port. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a897234cc2c7561da323cb124f57bcc28}{initMessageInTransfer} ()
\begin{DoxyCompactList}\small\item\em Request a new interrupt input transfer for additional message input. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_afddcb02a1e2bd87609fd2b6305534560}{cancelMessageInTransfer} ()
\begin{DoxyCompactList}\small\item\em Cancel current interrupt message input transfer. \end{DoxyCompactList}\item 
QQueue$<$ \hyperlink{classmdt_frame}{mdtFrame} $\ast$ $>$ \& \hyperlink{classmdt_usb_port_a3ad4385983122fcaf6d2560b6bd43acf}{messageInFramesPool} ()
\begin{DoxyCompactList}\small\item\em Get the message IN frames pool. \end{DoxyCompactList}\item 
QQueue$<$ \hyperlink{classmdt_frame}{mdtFrame} $\ast$ $>$ \& \hyperlink{classmdt_usb_port_a3365431076a3197540cbc99278658bda}{messageInFrames} ()
\begin{DoxyCompactList}\small\item\em Get the message IN frames. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_a38200f806037e06988e73af246e8a494}{addFrameToWrite} (\hyperlink{classmdt_frame}{mdtFrame} $\ast$frame)
\begin{DoxyCompactList}\small\item\em Add a frame to write. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a3340dc3f53e857e39053988e4925fc97}{initWriteTransfer} (const char $\ast$data, qint64 maxSize)
\begin{DoxyCompactList}\small\item\em Request a new bulk/interrupt out transfer. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a7cbe1cd3649861aac5e6a14830f06cf9}{cancelWriteTransfer} ()
\begin{DoxyCompactList}\small\item\em Cancel current bulk/interrupt input transfer. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a3be875f6f10ae94fd3a94f925bb935e7}{waitEventWriteReady} ()
\begin{DoxyCompactList}\small\item\em Wait until data can be written to port. \end{DoxyCompactList}\item 
qint64 \hyperlink{classmdt_usb_port_ae777e33325ff2adef326dd7f81b00838}{write} (const char $\ast$, qint64)
\begin{DoxyCompactList}\small\item\em Write data to port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_aa857e94b4167c53b26573042ee3af280}{addError} (\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} error)
\begin{DoxyCompactList}\small\item\em Set error. \end{DoxyCompactList}\item 
QList$<$ \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} $>$ \hyperlink{classmdt_usb_port_a81855cebd9b672a74d836955236c19bf}{lastErrors} ()
\begin{DoxyCompactList}\small\item\em Get the lis of current errors. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_afe5b473e1df8b828c17f83a45a3902fb}{cancelTransfers} ()
\begin{DoxyCompactList}\small\item\em Cancel pending transfers. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a551748422808cbb071930e1134bfaad5}{handleUsbEvents} (struct timeval $\ast$timeout, quint8 endpoint)
\begin{DoxyCompactList}\small\item\em Call libusb handle\_\-event() function. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_abb66e85fc1366112eeb0a6e86f6e7e32}{handleUsbEvents} ()
\begin{DoxyCompactList}\small\item\em Call libusb handle\_\-event() function. \end{DoxyCompactList}\item 
quint8 \hyperlink{classmdt_usb_port_a860e89069ba433e6174c032a28d0eae2}{currentReadEndpointAddress} () const 
\begin{DoxyCompactList}\small\item\em Get current read endpoint address. \end{DoxyCompactList}\item 
quint8 \hyperlink{classmdt_usb_port_ae2319ee6ff5a2f4399410175fbac6a44}{currentWriteEndpointAddress} () const 
\begin{DoxyCompactList}\small\item\em Get current write endpoint address. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classmdt_usb_port_a84ddd2d0bf77b4db60358846c7da4853}{controlTransferCallback} (struct libusb\_\-transfer $\ast$transfer)
\begin{DoxyCompactList}\small\item\em Transfer callback for control endpoint. \end{DoxyCompactList}\item 
static void \hyperlink{classmdt_usb_port_ab4f1f0456c84f954604b192f6085c3f2}{readTransferCallback} (struct libusb\_\-transfer $\ast$transfer)
\begin{DoxyCompactList}\small\item\em Transfer callback for read endpoint. \end{DoxyCompactList}\item 
static void \hyperlink{classmdt_usb_port_ae8932368e2777356695ab69f6ed08f41}{messageInTransferCallback} (struct libusb\_\-transfer $\ast$transfer)
\begin{DoxyCompactList}\small\item\em Transfer callback for message in (additional interrupt) endpoint. \end{DoxyCompactList}\item 
static void \hyperlink{classmdt_usb_port_af910071a5a5c401cd20cee3519120cc2}{writeTransferCallback} (struct libusb\_\-transfer $\ast$transfer)
\begin{DoxyCompactList}\small\item\em Transfer callback for write endpoint. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
USB port I/O port class. 

Built on top of libusb-\/1.x API

Note about the port name (set with \hyperlink{classmdt_abstract_port_a0ca143d32fc677bac7c1cf0e04144932}{setPortName()} ):\par
 Because it can happen that multiple devices with same vendor ID and product ID can be attached to system, this class must provide a unique identifier when (re-\/)open the port. Because of this, the choosen format is: VID=0x1234:PID=0x1234:SID=0x1234:bInterfaceNumber=0. VID is the Vendor ID, PID the Product ID, SID the Serial ID (also called Serial Number) and bInterfaceNumber the interface number (some devices have mor than one interface, f.ex. sound cards, keboard/mouse receiver, ...). SID and bInterfaceNumber are optional. In this case, the first port with given vendor ID and device ID is open. In brief, following names are allowed:
\begin{DoxyItemize}
\item VID=0x1234:PID=0x5678 (Open the first port with given Vendor ID and Product ID. bInterfaceNumber is 0)
\item VID=0x1234:PID=0x5678:SID=ABC1234 (Open the first port with given Vendor ID, Product ID and Serial ID. bInterfaceNumber is 0)
\item VID=0x1234:PID=0x5678:bInterfaceNumber=1 (Open the first port with given Vendor ID and Product ID. bInterfaceNumber is 1)
\item VID=0x1234:PID=0x5678:SID=ABC1234:bInterfaceNumber=1 (Open the first port with given Vendor ID, Product ID and Serial ID. bInterfaceNumber is 1) The last example in the above list is the format returned by \hyperlink{classmdt_usb_port_manager_a3a2370c3a2d0353a880bf9b777728c3b}{mdtUsbPortManager::scan()}.
\end{DoxyItemize}

For read and write of data, the mdtAbstractPort's API is used, expected that \hyperlink{classmdt_usb_port_ab8ddd4ebee603ac381e8da0383a61e36}{waitForReadyRead()} and \hyperlink{classmdt_usb_port_a3be875f6f10ae94fd3a94f925bb935e7}{waitEventWriteReady()} are not used.

The control transfer is a little bit different:
\begin{DoxyItemize}
\item If the main thread (f.ex. GUI thread) wants to send a request, it locks the mutex using \hyperlink{classmdt_abstract_port_a6bf2ecdcf894da3929a22eb8793a9fe3}{lockMutex()}, then it takes a frame in pool with \hyperlink{classmdt_usb_port_af146b08006ddbe18fb537ae1a75b622e}{controlFramesPool()}. Finaly, query is submitted using \hyperlink{classmdt_usb_port_a4fbcd0fcc179335c55c6d7ccc40a7c31}{addControlRequest()}, witch will submit the frame, and main thread unlocks the mutex with \hyperlink{classmdt_abstract_port_a3523c72a06e4d950338f91e56c286e84}{unlockMutex()}.
\item The thread periodically checks if a response is available using \hyperlink{classmdt_usb_port_a304825c7d9173a3dcb5e26a412f1038b}{controlResponseFrames()} queue's size, and emit controlResponseReaden() if a control response is available.
\end{DoxyItemize}

If a additional (to read and write) interrupt IN endpoint exists, it is handled as message IN as follow:
\begin{DoxyItemize}
\item The thread periodically checks if a message IN is available using \hyperlink{classmdt_usb_port_a3365431076a3197540cbc99278658bda}{messageInFrames()} queue's size, and emit messageInReaden() if a message IN is available.
\item A new transfer is reinitialized by thread. 
\end{DoxyItemize}

Definition at line 64 of file mdtUsbPort.h.



\subsection{Member Function Documentation}
\hypertarget{classmdt_usb_port_a9f4f09dac3f09b1766072cd9c1292ab1}{
\index{mdtUsbPort@{mdtUsbPort}!addbTagToAbort@{addbTagToAbort}}
\index{addbTagToAbort@{addbTagToAbort}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{addbTagToAbort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::addbTagToAbort (
\begin{DoxyParamCaption}
\item[{quint8}]{bTag}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a9f4f09dac3f09b1766072cd9c1292ab1}


add a bulk IN bTag to abort 

\begin{Desc}
\item[\hyperlink{todo__todo000043}{Todo}]Obselete All pending bTags queued will be aborted regarding USBTMC standard (INITIATE/CHECK ABORT\_\-BULK\_\-IN)\end{Desc}


The mutex must be locked before calling this method, and still locked inside. 

Definition at line 379 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a4fbcd0fcc179335c55c6d7ccc40a7c31}{
\index{mdtUsbPort@{mdtUsbPort}!addControlRequest@{addControlRequest}}
\index{addControlRequest@{addControlRequest}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{addControlRequest}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::addControlRequest (
\begin{DoxyParamCaption}
\item[{{\bf mdtFrameUsbControl} $\ast$}]{frame, }
\item[{bool}]{setwIndexAsbInterfaceNumber = {\ttfamily false}}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a4fbcd0fcc179335c55c6d7ccc40a7c31}


Add a control request. 

Add a control frame to the queries queue. Frame will be sent as soon as possible.

The mutex must be locked before calling this method, and still locked inside.


\begin{DoxyParams}{Parameters}
{\em frame} & Control frame \\
\hline
{\em setwIndexAsbInterfaceNumber} & If true, wIndex will be set with current bInterfaceNumber \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
frame must be a valid pointer. 
\end{DoxyPrecond}


Definition at line 137 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_aa857e94b4167c53b26573042ee3af280}{
\index{mdtUsbPort@{mdtUsbPort}!addError@{addError}}
\index{addError@{addError}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{addError}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::addError (
\begin{DoxyParamCaption}
\item[{{\bf mdtAbstractPort::error\_\-t}}]{error}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_aa857e94b4167c53b26573042ee3af280}


Set error. 

Used by transfer callbacks

Mutex is not handled by this method. 

Definition at line 966 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a38200f806037e06988e73af246e8a494}{
\index{mdtUsbPort@{mdtUsbPort}!addFrameToWrite@{addFrameToWrite}}
\index{addFrameToWrite@{addFrameToWrite}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{addFrameToWrite}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::addFrameToWrite (
\begin{DoxyParamCaption}
\item[{{\bf mdtFrame} $\ast$}]{frame}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_a38200f806037e06988e73af246e8a494}


Add a frame to write. 

Once the frame is added to the write queue, waiting thread will be woken up (if waiting) and will send the frame.

The mutex must be locked before calling this method, and still locked inside.

\begin{DoxyPrecond}{Precondition}
frame must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_abstract_port_a9a69eb2fc07d551ab37c011487fa319d}{mdtAbstractPort}.



Definition at line 756 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a6566e654df8a1c3503941702593db3c5}{
\index{mdtUsbPort@{mdtUsbPort}!cancelControlTransfer@{cancelControlTransfer}}
\index{cancelControlTransfer@{cancelControlTransfer}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{cancelControlTransfer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::cancelControlTransfer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a6566e654df8a1c3503941702593db3c5}


Cancel current control transfer. 

Used by \hyperlink{classmdt_usb_port_thread}{mdtUsbPortThread}, should not be used else. 

qDebug() $<$$<$ \char`\"{}cancelControlTransfer() ...\char`\"{}; 



Definition at line 313 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_afddcb02a1e2bd87609fd2b6305534560}{
\index{mdtUsbPort@{mdtUsbPort}!cancelMessageInTransfer@{cancelMessageInTransfer}}
\index{cancelMessageInTransfer@{cancelMessageInTransfer}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{cancelMessageInTransfer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::cancelMessageInTransfer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_afddcb02a1e2bd87609fd2b6305534560}


Cancel current interrupt message input transfer. 

Used by \hyperlink{classmdt_usb_port_thread}{mdtUsbPortThread}, should not be used else. 

qDebug() $<$$<$ \char`\"{}mdtUsbPort::cancelMessageInTransfer() ...\char`\"{};

qDebug() $<$$<$ \char`\"{}mdtUsbPort::cancelMessageInTransfer() DONE\char`\"{}; 



Definition at line 705 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a3570b708f9f51408e4bbf2f61cc8c881}{
\index{mdtUsbPort@{mdtUsbPort}!cancelReadTransfer@{cancelReadTransfer}}
\index{cancelReadTransfer@{cancelReadTransfer}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{cancelReadTransfer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::cancelReadTransfer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a3570b708f9f51408e4bbf2f61cc8c881}


Cancel current bulk/interrupt input transfer. 

Used by \hyperlink{classmdt_usb_port_thread}{mdtUsbPortThread}, should not be used else. 

qDebug() $<$$<$ \char`\"{}cancelReadTransfer() ...\char`\"{}; 



Definition at line 510 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_afe5b473e1df8b828c17f83a45a3902fb}{
\index{mdtUsbPort@{mdtUsbPort}!cancelTransfers@{cancelTransfers}}
\index{cancelTransfers@{cancelTransfers}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{cancelTransfers}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::cancelTransfers (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_afe5b473e1df8b828c17f83a45a3902fb}


Cancel pending transfers. 

Will cancel all pending transfers.

Used by \hyperlink{classmdt_usb_port_thread}{mdtUsbPortThread}, should not be used else. 

qDebug() $<$$<$ \char`\"{}mdtUsbPort::cancelTransfers() ...\char`\"{};

qDebug() $<$$<$ \char`\"{}mdtUsbPort::cancelTransfers() DONE\char`\"{}; 



Definition at line 981 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a7cbe1cd3649861aac5e6a14830f06cf9}{
\index{mdtUsbPort@{mdtUsbPort}!cancelWriteTransfer@{cancelWriteTransfer}}
\index{cancelWriteTransfer@{cancelWriteTransfer}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{cancelWriteTransfer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::cancelWriteTransfer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a7cbe1cd3649861aac5e6a14830f06cf9}


Cancel current bulk/interrupt input transfer. 

Used by \hyperlink{classmdt_usb_port_thread}{mdtUsbPortThread}, should not be used else. 

qDebug() $<$$<$ \char`\"{}cancelWriteTransfer() ...\char`\"{}; 



Definition at line 898 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_af146b08006ddbe18fb537ae1a75b622e}{
\index{mdtUsbPort@{mdtUsbPort}!controlFramesPool@{controlFramesPool}}
\index{controlFramesPool@{controlFramesPool}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{controlFramesPool}]{\setlength{\rightskip}{0pt plus 5cm}QQueue$<$ {\bf mdtFrameUsbControl} $\ast$ $>$ \& mdtUsbPort::controlFramesPool (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_af146b08006ddbe18fb537ae1a75b622e}


Get the control pool queue. 

This queue contains the pool of control frames.

Mutex is not handled by this method. 

Definition at line 303 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_afbb20c403e7a5885d5e4221bab9f304e}{
\index{mdtUsbPort@{mdtUsbPort}!controlQueryFrames@{controlQueryFrames}}
\index{controlQueryFrames@{controlQueryFrames}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{controlQueryFrames}]{\setlength{\rightskip}{0pt plus 5cm}QQueue$<$ {\bf mdtFrameUsbControl} $\ast$ $>$ \& mdtUsbPort::controlQueryFrames (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_afbb20c403e7a5885d5e4221bab9f304e}


Get the control query queue. 

This queue contains control query frames (control requests).

Mutex is not handled by this method. 

Definition at line 308 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a304825c7d9173a3dcb5e26a412f1038b}{
\index{mdtUsbPort@{mdtUsbPort}!controlResponseFrames@{controlResponseFrames}}
\index{controlResponseFrames@{controlResponseFrames}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{controlResponseFrames}]{\setlength{\rightskip}{0pt plus 5cm}QQueue$<$ {\bf mdtFrameUsbControl} $\ast$ $>$ \& mdtUsbPort::controlResponseFrames (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a304825c7d9173a3dcb5e26a412f1038b}


Get the control responses queue. 

This queue contains the response frames returned from device.

Mutex is not handled by this method. 

Definition at line 353 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a84ddd2d0bf77b4db60358846c7da4853}{
\index{mdtUsbPort@{mdtUsbPort}!controlTransferCallback@{controlTransferCallback}}
\index{controlTransferCallback@{controlTransferCallback}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{controlTransferCallback}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::controlTransferCallback (
\begin{DoxyParamCaption}
\item[{struct libusb\_\-transfer $\ast$}]{transfer}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classmdt_usb_port_a84ddd2d0bf77b4db60358846c7da4853}


Transfer callback for control endpoint. 

Check completion and error flags and add control frame in responses queue if ok, or in pool else. On error, \hyperlink{classmdt_usb_port_aa857e94b4167c53b26573042ee3af280}{addError()} is called, so thread can notify it.

Once done, \hyperlink{classmdt_usb_port_a274b6fd10bd84027bb66773ed805de2a}{submitControlQuery()} is called.

This method is called from libusb and should not be used directly.

Mutex is locked during process and unlocked befor return.

\begin{DoxyPrecond}{Precondition}
transfer must be valid 

transfer-\/$>$user\_\-data must be valid 
\end{DoxyPrecond}


qDebug() $<$$<$ \char`\"{}mdtUsbPort::controlTransferCallback() ...\char`\"{};

qDebug() $<$$<$ \char`\"{}mdtUsbPort::controlTransferCallback(): timeout\char`\"{};

qDebug() $<$$<$ \char`\"{}mdtUsbPort::controlTransferCallback(): cancelled\char`\"{};

qDebug() $<$$<$ \char`\"{}mdtUsbPort::controlTransferCallback(): disconnected\char`\"{}; 



Definition at line 197 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a860e89069ba433e6174c032a28d0eae2}{
\index{mdtUsbPort@{mdtUsbPort}!currentReadEndpointAddress@{currentReadEndpointAddress}}
\index{currentReadEndpointAddress@{currentReadEndpointAddress}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{currentReadEndpointAddress}]{\setlength{\rightskip}{0pt plus 5cm}quint8 mdtUsbPort::currentReadEndpointAddress (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_usb_port_a860e89069ba433e6174c032a28d0eae2}


Get current read endpoint address. 

Note: mutex is not handled by this method 

Definition at line 1072 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_ae2319ee6ff5a2f4399410175fbac6a44}{
\index{mdtUsbPort@{mdtUsbPort}!currentWriteEndpointAddress@{currentWriteEndpointAddress}}
\index{currentWriteEndpointAddress@{currentWriteEndpointAddress}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{currentWriteEndpointAddress}]{\setlength{\rightskip}{0pt plus 5cm}quint8 mdtUsbPort::currentWriteEndpointAddress (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_usb_port_ae2319ee6ff5a2f4399410175fbac6a44}


Get current write endpoint address. 

Note: mutex is not handled by this method 

Definition at line 1077 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a551748422808cbb071930e1134bfaad5}{
\index{mdtUsbPort@{mdtUsbPort}!handleUsbEvents@{handleUsbEvents}}
\index{handleUsbEvents@{handleUsbEvents}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{handleUsbEvents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::handleUsbEvents (
\begin{DoxyParamCaption}
\item[{struct timeval $\ast$}]{timeout, }
\item[{quint8}]{endpoint}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a551748422808cbb071930e1134bfaad5}


Call libusb handle\_\-event() function. 

Notes: must be called only by I/O thread (typically \hyperlink{classmdt_usb_port_thread}{mdtUsbPortThread}). This method unlocks the mutex during wait (must be locked by call, is locked again before return)


\begin{DoxyParams}{Parameters}
{\em timeout} & Wait timeout. If null, the port's internal defined timeout is used regarding endpoint \\
\hline
{\em endpoint} & Concerned endpoint \\
\hline
\end{DoxyParams}


\begin{Desc}
\item[\hyperlink{todo__todo000038}{Todo}]Think that timeout has no sense here, should be filtered \end{Desc}




Definition at line 1007 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_abb66e85fc1366112eeb0a6e86f6e7e32}{
\index{mdtUsbPort@{mdtUsbPort}!handleUsbEvents@{handleUsbEvents}}
\index{handleUsbEvents@{handleUsbEvents}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{handleUsbEvents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::handleUsbEvents (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_abb66e85fc1366112eeb0a6e86f6e7e32}


Call libusb handle\_\-event() function. 

Notes: must be called only by I/O thread (typically \hyperlink{classmdt_usb_port_thread}{mdtUsbPortThread}). This method unlocks the mutex during wait (must be locked by call, is locked again before return)

\begin{DoxyReturn}{Returns}
NoError or \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} error (Note: timeout is ignored here) 
\end{DoxyReturn}


Definition at line 1038 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a897234cc2c7561da323cb124f57bcc28}{
\index{mdtUsbPort@{mdtUsbPort}!initMessageInTransfer@{initMessageInTransfer}}
\index{initMessageInTransfer@{initMessageInTransfer}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{initMessageInTransfer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::initMessageInTransfer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a897234cc2c7561da323cb124f57bcc28}


Request a new interrupt input transfer for additional message input. 

Will fill and init a new interrupt transfer and submit it to libusb.

If a transfer is pending, this method simply returns.

This method is called by USB port thread and should not be used else.

Mutex is not handled by this method.

\begin{DoxyReturn}{Returns}
NoError or a error from \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} 
\end{DoxyReturn}


\begin{Desc}
\item[\hyperlink{todo__todo000037}{Todo}]Handle retval \end{Desc}




Definition at line 585 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a5e380852b8726f71e8558c86cba5bd1f}{
\index{mdtUsbPort@{mdtUsbPort}!initReadTransfer@{initReadTransfer}}
\index{initReadTransfer@{initReadTransfer}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{initReadTransfer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::initReadTransfer (
\begin{DoxyParamCaption}
\item[{qint64}]{maxSize}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a5e380852b8726f71e8558c86cba5bd1f}


Submit a read transfer. 

If a transfer is pending, this method simply returns.

This method is called by USB port thread and should not be used else.

Mutex is not handled by this method.

\begin{DoxyReturn}{Returns}
NoError or a error from \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} 
\end{DoxyReturn}


qDebug() $<$$<$ \char`\"{}mdtUsbPort::initReadTransfer() called, maxSize: \char`\"{} $<$$<$ maxSize;

qDebug() $<$$<$ \char`\"{}mdtUsbPort::initReadTransfer() INIT\char`\"{};

\begin{Desc}
\item[\hyperlink{todo__todo000036}{Todo}]Handle retval \end{Desc}




Definition at line 392 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a3340dc3f53e857e39053988e4925fc97}{
\index{mdtUsbPort@{mdtUsbPort}!initWriteTransfer@{initWriteTransfer}}
\index{initWriteTransfer@{initWriteTransfer}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{initWriteTransfer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::initWriteTransfer (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{data, }
\item[{qint64}]{maxSize}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a3340dc3f53e857e39053988e4925fc97}


Request a new bulk/interrupt out transfer. 

Will fill and init a new bulk/interrupt (depending setup) transfer and submit it to libusb.

If a transfer is pending, this method simply returns.

This method is called by USB port thread and should not be used else.

Mutex is not handled by this method.

\begin{DoxyReturn}{Returns}
NoError or a error from \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} 
\end{DoxyReturn}


qDebug() $<$$<$ \char`\"{}mdtUsbPort::initWriteTransfer() called ...\char`\"{};

qDebug() $<$$<$ \char`\"{}mdtUsbPort::initWriteTransfer() , maxSize: \char`\"{} $<$$<$ maxSize $<$$<$ \char`\"{} , data: \char`\"{} $<$$<$ data; 



Definition at line 774 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a81855cebd9b672a74d836955236c19bf}{
\index{mdtUsbPort@{mdtUsbPort}!lastErrors@{lastErrors}}
\index{lastErrors@{lastErrors}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{lastErrors}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtAbstractPort::error\_\-t} $>$ mdtUsbPort::lastErrors (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a81855cebd9b672a74d836955236c19bf}


Get the lis of current errors. 

Will clear internal list (a second call will return a empty list)

Used by \hyperlink{classmdt_usb_port_thread}{mdtUsbPortThread}, should not be used else. 

Definition at line 971 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a3365431076a3197540cbc99278658bda}{
\index{mdtUsbPort@{mdtUsbPort}!messageInFrames@{messageInFrames}}
\index{messageInFrames@{messageInFrames}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{messageInFrames}]{\setlength{\rightskip}{0pt plus 5cm}QQueue$<$ {\bf mdtFrame} $\ast$ $>$ \& mdtUsbPort::messageInFrames (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a3365431076a3197540cbc99278658bda}


Get the message IN frames. 

This queue contains the message IN frames.

Mutex is not handled by this method. 

Definition at line 751 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a3ad4385983122fcaf6d2560b6bd43acf}{
\index{mdtUsbPort@{mdtUsbPort}!messageInFramesPool@{messageInFramesPool}}
\index{messageInFramesPool@{messageInFramesPool}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{messageInFramesPool}]{\setlength{\rightskip}{0pt plus 5cm}QQueue$<$ {\bf mdtFrame} $\ast$ $>$ \& mdtUsbPort::messageInFramesPool (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a3ad4385983122fcaf6d2560b6bd43acf}


Get the message IN frames pool. 

This queue contains the pool of message IN frames.

Mutex is not handled by this method. 

Definition at line 746 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_ae8932368e2777356695ab69f6ed08f41}{
\index{mdtUsbPort@{mdtUsbPort}!messageInTransferCallback@{messageInTransferCallback}}
\index{messageInTransferCallback@{messageInTransferCallback}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{messageInTransferCallback}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::messageInTransferCallback (
\begin{DoxyParamCaption}
\item[{struct libusb\_\-transfer $\ast$}]{transfer}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classmdt_usb_port_ae8932368e2777356695ab69f6ed08f41}


Transfer callback for message in (additional interrupt) endpoint. 

Check completion and error flags. On error, \hyperlink{classmdt_usb_port_aa857e94b4167c53b26573042ee3af280}{addError()} is called, so thread can notify it.

This method is called from libusb and should not be used directly.

Mutex is not handled by this method.

\begin{DoxyPrecond}{Precondition}
transfer must be valid 

transfer-\/$>$user\_\-data must be valid 
\end{DoxyPrecond}


qDebug() $<$$<$ \char`\"{}mdtUsbPort::messageInTransferCallback() ...\char`\"{};

qDebug() $<$$<$ \char`\"{}mdtUsbPort::messageInTransferCallback() return ReadCanceled\char`\"{};

qDebug() $<$$<$ \char`\"{}mdtUsbPort::messageInTransferCallback(): device disconnected\char`\"{}; 



Definition at line 617 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_abce257345c8af47494215cd7ee75f82d}{
\index{mdtUsbPort@{mdtUsbPort}!read@{read}}
\index{read@{read}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}qint64 mdtUsbPort::read (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{data, }
\item[{qint64}]{maxSize}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_abce257345c8af47494215cd7ee75f82d}


Read data from port. 

This method is called from \hyperlink{classmdt_usb_port_thread}{mdtUsbPortThread} , and should not be used directly.

Mutex is not handled by this method.

\begin{DoxyReturn}{Returns}
Amount of readen data (can be 0 if transfer is pending or no more data are available), \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} code on error. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
data must be valid 
\end{DoxyPrecond}


Implements \hyperlink{classmdt_abstract_port_a9d9c45220d5328c9856a2445557fe970}{mdtAbstractPort}.



Definition at line 556 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_af546a031ed8621fee1d5e9498cbcd174}{
\index{mdtUsbPort@{mdtUsbPort}!readBufferSize@{readBufferSize}}
\index{readBufferSize@{readBufferSize}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{readBufferSize}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbPort::readBufferSize (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_usb_port_af546a031ed8621fee1d5e9498cbcd174}


Get read buffer size. 

This is the same as wMaxPacketSize of read endpoint.

This method is used by USB thread, and should not be used else.

Mutex is not handled by this method. 

Definition at line 580 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_ab4f1f0456c84f954604b192f6085c3f2}{
\index{mdtUsbPort@{mdtUsbPort}!readTransferCallback@{readTransferCallback}}
\index{readTransferCallback@{readTransferCallback}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{readTransferCallback}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::readTransferCallback (
\begin{DoxyParamCaption}
\item[{struct libusb\_\-transfer $\ast$}]{transfer}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classmdt_usb_port_ab4f1f0456c84f954604b192f6085c3f2}


Transfer callback for read endpoint. 

Check completion and error flags. On error, \hyperlink{classmdt_usb_port_aa857e94b4167c53b26573042ee3af280}{addError()} is called, so thread can notify it.

This method is called from libusb and should not be used directly.

Mutex is not handled by this method.

\begin{DoxyPrecond}{Precondition}
transfer must be valid 

transfer-\/$>$user\_\-data must be valid 
\end{DoxyPrecond}


qDebug() $<$$<$ \char`\"{}mdtUsbPort::readTransferCallback() ...\char`\"{};

qDebug() $<$$<$ \char`\"{}mdtUsbPort::readTransferCallback() return ReadCanceled\char`\"{};

qDebug() $<$$<$ \char`\"{}mdtUsbPort::readTransferCallback(): device disconnected\char`\"{}; 



Definition at line 446 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a3c0685d67fe608abe24c140c2858779c}{
\index{mdtUsbPort@{mdtUsbPort}!readUntilShortPacketReceivedRequestPending@{readUntilShortPacketReceivedRequestPending}}
\index{readUntilShortPacketReceivedRequestPending@{readUntilShortPacketReceivedRequestPending}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{readUntilShortPacketReceivedRequestPending}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtUsbPort::readUntilShortPacketReceivedRequestPending (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a3c0685d67fe608abe24c140c2858779c}


Check if a request to read until a short packet is received is pending. 

Flag will be cleared after a call of this method.

This method is used by USB thread, and should not be used else.

Mutex is not handled by this method. 

Definition at line 370 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_af2399348faf1abc20130eab20cfc36ee}{
\index{mdtUsbPort@{mdtUsbPort}!reconnect@{reconnect}}
\index{reconnect@{reconnect}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{reconnect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::reconnect (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_af2399348faf1abc20130eab20cfc36ee}


Reconnect device. 

If one of the method returns a Disconnected error, the thread will call this method to try to reconnect.


\begin{DoxyParams}{Parameters}
{\em timeout} & Timeout \mbox{[}ms\mbox{]} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
NoError if connection could be done. Disconnected if connection could not be done, in wich case the thread will retry (until max retry). A UnhandledError can be returned. 
\end{DoxyReturn}


Reimplemented from \hyperlink{classmdt_abstract_port_aec74b2db1a629d98a95d8f042ea96653}{mdtAbstractPort}.



Definition at line 86 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a719fc7b43461a3e2d9a4926d3e3961c2}{
\index{mdtUsbPort@{mdtUsbPort}!requestReadUntilShortPacketReceived@{requestReadUntilShortPacketReceived}}
\index{requestReadUntilShortPacketReceived@{requestReadUntilShortPacketReceived}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{requestReadUntilShortPacketReceived}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::requestReadUntilShortPacketReceived (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a719fc7b43461a3e2d9a4926d3e3961c2}


Request to read until a short packet is received. 

The mutex must be locked before calling this method, and still locked inside. 

Definition at line 358 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a44ed5024a81a573b5196b8f64c42cd6a}{
\index{mdtUsbPort@{mdtUsbPort}!setReadTimeout@{setReadTimeout}}
\index{setReadTimeout@{setReadTimeout}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{setReadTimeout}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::setReadTimeout (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_a44ed5024a81a573b5196b8f64c42cd6a}


Set the read data timeout. 

The mutex is not handled by this method. 

Implements \hyperlink{classmdt_abstract_port_a6589b04467e0073d18ba872201bdcd84}{mdtAbstractPort}.



Definition at line 111 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a592af88bd7e7f45dd80df0ecab375ace}{
\index{mdtUsbPort@{mdtUsbPort}!setWriteTimeout@{setWriteTimeout}}
\index{setWriteTimeout@{setWriteTimeout}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{setWriteTimeout}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::setWriteTimeout (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_a592af88bd7e7f45dd80df0ecab375ace}


Set the write data timeout. 

The mutex is not handled by this method. 

Implements \hyperlink{classmdt_abstract_port_a12eb422d52ebb09a650f8497b258c2e7}{mdtAbstractPort}.



Definition at line 124 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a274b6fd10bd84027bb66773ed805de2a}{
\index{mdtUsbPort@{mdtUsbPort}!submitControlQuery@{submitControlQuery}}
\index{submitControlQuery@{submitControlQuery}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{submitControlQuery}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::submitControlQuery (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a274b6fd10bd84027bb66773ed805de2a}


Submit a control query. 

If frames are available in queries queue and no control transfer is pending, a transfer will be submitted.

This method is called by \hyperlink{classmdt_usb_port_a4fbcd0fcc179335c55c6d7ccc40a7c31}{addControlRequest()} and \hyperlink{classmdt_usb_port_a84ddd2d0bf77b4db60358846c7da4853}{controlTransferCallback()} and should not be used directly.

The mutex must be locked before calling this method, and still locked inside. 

Definition at line 148 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a43e3102b004f213ecc01b17f31607957}{
\index{mdtUsbPort@{mdtUsbPort}!takebTagToAbort@{takebTagToAbort}}
\index{takebTagToAbort@{takebTagToAbort}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{takebTagToAbort}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbPort::takebTagToAbort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a43e3102b004f213ecc01b17f31607957}


Get a bTag to abort in pending queue. 

\begin{Desc}
\item[\hyperlink{todo__todo000044}{Todo}]Obselete This method is used by USB thread, and should not be used else.\end{Desc}


Mutex is not handled by this method.

\begin{DoxyReturn}{Returns}
Value $>$= 0 (=bTag) or -\/1 if queue is empty. 
\end{DoxyReturn}


Definition at line 384 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a3be875f6f10ae94fd3a94f925bb935e7}{
\index{mdtUsbPort@{mdtUsbPort}!waitEventWriteReady@{waitEventWriteReady}}
\index{waitEventWriteReady@{waitEventWriteReady}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{waitEventWriteReady}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::waitEventWriteReady (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_a3be875f6f10ae94fd3a94f925bb935e7}


Wait until data can be written to port. 

This method is not implemented here and will allways return a UnhandledError. 

Implements \hyperlink{classmdt_abstract_port_a35e4686f50e2c53c7e3618cf2c485d92}{mdtAbstractPort}.



Definition at line 940 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_ab8ddd4ebee603ac381e8da0383a61e36}{
\index{mdtUsbPort@{mdtUsbPort}!waitForReadyRead@{waitForReadyRead}}
\index{waitForReadyRead@{waitForReadyRead}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{waitForReadyRead}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::waitForReadyRead (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_ab8ddd4ebee603ac381e8da0383a61e36}


Wait until data is available on port. 

Not implemented, will allways return a UnhandledError 

Implements \hyperlink{classmdt_abstract_port_aeda364cb191da1038a22dd1fc06a1d49}{mdtAbstractPort}.



Definition at line 551 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_ae777e33325ff2adef326dd7f81b00838}{
\index{mdtUsbPort@{mdtUsbPort}!write@{write}}
\index{write@{write}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}qint64 mdtUsbPort::write (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{, }
\item[{qint64}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_ae777e33325ff2adef326dd7f81b00838}


Write data to port. 

This method is called from \hyperlink{classmdt_port_write_thread}{mdtPortWriteThread} , and should not be used directly.

Mutex is not handled by this method. 

Implements \hyperlink{classmdt_abstract_port_a64d4802975a76474b9196c91f57a6d90}{mdtAbstractPort}.



Definition at line 945 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_af910071a5a5c401cd20cee3519120cc2}{
\index{mdtUsbPort@{mdtUsbPort}!writeTransferCallback@{writeTransferCallback}}
\index{writeTransferCallback@{writeTransferCallback}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{writeTransferCallback}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::writeTransferCallback (
\begin{DoxyParamCaption}
\item[{struct libusb\_\-transfer $\ast$}]{transfer}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classmdt_usb_port_af910071a5a5c401cd20cee3519120cc2}


Transfer callback for write endpoint. 

Check completion and error flags. On error, \hyperlink{classmdt_usb_port_aa857e94b4167c53b26573042ee3af280}{addError()} is called, so thread can notify it.

This method is called from libusb and should not be used directly.

Mutex is not handled by this method.

\begin{DoxyPrecond}{Precondition}
transfer must be valid 

transfer-\/$>$user\_\-data must be valid 
\end{DoxyPrecond}


qDebug() $<$$<$ \char`\"{}mdtUsbPort::writeTransferCallback() return WriteCanceled\char`\"{};

qDebug() $<$$<$ \char`\"{}mdtUsbPort::writeTransferCallback(): device disconnected\char`\"{}; 



Definition at line 830 of file mdtUsbPort.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtUsbPort.h\item 
src/mdtport/mdtUsbPort.cpp\end{DoxyCompactItemize}
