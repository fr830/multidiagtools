\hypertarget{classmdt_port_manager}{
\section{mdtPortManager Class Reference}
\label{classmdt_port_manager}\index{mdtPortManager@{mdtPortManager}}
}


Port manager base class.  




{\ttfamily \#include $<$mdtPortManager.h$>$}



Inheritance diagram for mdtPortManager:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{classmdt_port_manager__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=254pt]{classmdt_port_manager__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Slots}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classmdt_port_manager_a1d185e9bb610aee16ccd9499ae7bff0d}{abort} ()
\begin{DoxyCompactList}\small\item\em Cancel read and write operations. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{fromThreadNewFrameReaden} ()
\begin{DoxyCompactList}\small\item\em Try to. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}{onThreadsErrorOccured} (int error)
\begin{DoxyCompactList}\small\item\em Manage errors comming from port threads. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Signals}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_port_manager_a65d5d2e9edde76796714f737a7eaf204}{newReadenFrame} (int id, QByteArray data)
\begin{DoxyCompactList}\small\item\em Emitted when new frame was readen. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ab6a2a791de303ff20e6f7f884be681bf}{readenFramesQueueSizeChanged} (int newSize)
\begin{DoxyCompactList}\small\item\em Emitted when internal queue of readen frames size has changed. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a053ba62f090eced0cf635c9be5c6b052}{
void \hyperlink{classmdt_port_manager_a053ba62f090eced0cf635c9be5c6b052}{errorStateChanged} (int error)}
\label{classmdt_port_manager_a053ba62f090eced0cf635c9be5c6b052}

\begin{DoxyCompactList}\small\item\em Emitted when error number has changed. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_port_manager_a5ec36523089b7528d973e29cdbc64d01}{
{\bfseries mdtPortManager} (QObject $\ast$parent=0)}
\label{classmdt_port_manager_a5ec36523089b7528d973e29cdbc64d01}

\item 
virtual \hyperlink{classmdt_port_manager_adf797f8fd7a3ffdc000890a224e4c1b6}{$\sim$mdtPortManager} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ae48865abce3dc2a3173ae77d7b0c107f}{setEnqueueReadenFrames} (bool enqueue)
\begin{DoxyCompactList}\small\item\em Set the enqueue readen frames flag. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a56bb2f93ee65b4743cb19784224e3489}{setNotifyNewReadenFrame} (bool notify)
\begin{DoxyCompactList}\small\item\em Set the incomming frame notification flag. \end{DoxyCompactList}\item 
virtual QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}{scan} ()
\begin{DoxyCompactList}\small\item\em Scan for available ports. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort} (\hyperlink{classmdt_abstract_port}{mdtAbstractPort} $\ast$port)
\begin{DoxyCompactList}\small\item\em Set port object. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a39cb4af4aedc0b6b7c4d4f53002c3fd1}{detachPort} (bool deletePort, bool deleteThreads)
\begin{DoxyCompactList}\small\item\em Detach port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}{addThread} (\hyperlink{classmdt_port_thread}{mdtPortThread} $\ast$thread)
\begin{DoxyCompactList}\small\item\em Add a thread and assign it to port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_aaa0a474183bcae0fff4fb9ef43023c25}{removeThreads} (bool releaseMemory)
\begin{DoxyCompactList}\small\item\em Detach threads from port and remove threads. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{start} ()
\begin{DoxyCompactList}\small\item\em Start threads. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_af460167e604b8b6e2e933a98b2b6b5a2}{isRunning} ()
\begin{DoxyCompactList}\small\item\em Get the running state. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_aacbf87cc3d9c37c87e21696f8a6514bd}{stop} ()
\begin{DoxyCompactList}\small\item\em Stop threads. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}{setPortName} (const QString \&portName)
\begin{DoxyCompactList}\small\item\em Set port name. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a7e2ef93ec2731e66aa2b2d5f7ce9bc1c}{setPortInfo} (\hyperlink{classmdt_port_info}{mdtPortInfo} info)
\begin{DoxyCompactList}\small\item\em Set port info. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}{
\hyperlink{classmdt_port_info}{mdtPortInfo} \hyperlink{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}{portInfo} ()}
\label{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}

\begin{DoxyCompactList}\small\item\em Get port info. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_port_config}{mdtPortConfig} \& \hyperlink{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{config} ()
\begin{DoxyCompactList}\small\item\em Get the port's config object. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{openPort} ()
\begin{DoxyCompactList}\small\item\em Open the port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ace8065f1f5083041ee7f65c2892bc77d}{closePort} ()
\begin{DoxyCompactList}\small\item\em Close the port. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_ae1cc1010067bcbf104fb3d1b19f2fa48}{waitOnWriteReady} (int timeout, int granularity=50)
\begin{DoxyCompactList}\small\item\em Wait until data can be written. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{writeData} (QByteArray data)
\begin{DoxyCompactList}\small\item\em Write data by copy. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_a44ca338c8c56893612301e09d2ee6e88}{waitReadenFrame} (int timeout=500)
\begin{DoxyCompactList}\small\item\em Wait until a complete frame is available. \end{DoxyCompactList}\item 
QByteArray \hyperlink{classmdt_port_manager_a1db6b8da9ff16221c917a1a75366e5c0}{waitOnFrame} (int id, int timeout=500)
\begin{DoxyCompactList}\small\item\em Wait on readen frame with defined ID. \end{DoxyCompactList}\item 
QByteArray \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame} (int id)
\begin{DoxyCompactList}\small\item\em Get data by frame ID. \end{DoxyCompactList}\item 
const QList$<$ QByteArray $>$ \hyperlink{classmdt_port_manager_ae5c6475a54ac4921c6df26893f261556}{readenFrames} () const 
\begin{DoxyCompactList}\small\item\em Get all readen data. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ad4ff1309b267dfdcfa5a12e4617397f1}{clearReadenFrames} ()
\begin{DoxyCompactList}\small\item\em Clear readen frames. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classmdt_port_manager_acc5c63ad33fdd3cc153fc23e00c6e69c}{wait} (int msecs, int granularity=50)
\begin{DoxyCompactList}\small\item\em Wait some time without break the GUI's event loop. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_port_manager_a3daaf801a26008388af390b5917d7a0c}{commitFrame} (int id, QByteArray data)
\begin{DoxyCompactList}\small\item\em Store frame data in queue and/or emit \hyperlink{classmdt_port_manager_a65d5d2e9edde76796714f737a7eaf204}{newReadenFrame()} signal. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_port_manager_af856162aab4f1c5202c1dfb330fae538}{
\hyperlink{classmdt_abstract_port}{mdtAbstractPort} $\ast$ {\bfseries pvPort}}
\label{classmdt_port_manager_af856162aab4f1c5202c1dfb330fae538}

\item 
\hypertarget{classmdt_port_manager_a8e0d49b789f8b01d469e84b487799573}{
QList$<$ \hyperlink{classmdt_port_thread}{mdtPortThread} $\ast$ $>$ {\bfseries pvThreads}}
\label{classmdt_port_manager_a8e0d49b789f8b01d469e84b487799573}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Port manager base class. 

Manages a port based on \hyperlink{classmdt_abstract_port}{mdtAbstractPort} an several threads based on \hyperlink{classmdt_port_thread}{mdtPortThread}. The goal is to hide the complexity of the port API.

Example: 
\begin{DoxyCode}
 mdtPortManager m;
 mdtPort *port;
 mdtPortConfig *config;

 // Setup
 config = new mdtPortConfig;
 config->setFrameType(mdtFrame::FT_ASCII);
 config->setEndOfFrameSeq("$");

 // Init port
 port = new mdtPort;
 port->setConfig(config);

 // Init port manager
 m.setEnqueueReadenFrames(true);
 m.setPort(port);
 m.addThread(mew mdtPortWriteThread);
 m.addThread(mew mdtPortReadThread);
 m.setPortName("/dev/xyz"));
 if(!m.openPort()){
  // Handle error
 }

 // Start threads
 if(!m.start()){
  // Handle error
 }

 // Send some data
 if(!m.writeData("Test$")){
  // Handle error
 }

 // Wait on answer - Timout: 1500 [ms]
 if(!m.waitReadenFrame(1500)){
  // Timout , handle error
 }

 // Do something with received data
 for(int i=0; i<m.readenFrames().size(); i++){
  qDebug() << m.readenFrames().at(i);
 }

 // Cleanup - detachPort() will delete port and threads objects
 m.detachPort(true, true);
 delete config;
\end{DoxyCode}


A alternative of using \hyperlink{classmdt_port_manager_a44ca338c8c56893612301e09d2ee6e88}{waitReadenFrame()} is to connect the \hyperlink{classmdt_port_manager_a65d5d2e9edde76796714f737a7eaf204}{newReadenFrame()} signal to a slot, and get data with \hyperlink{classmdt_port_manager_ae5c6475a54ac4921c6df26893f261556}{readenFrames()} from this slot.

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_serial_port_manager}{mdtSerialPortManager} 

\hyperlink{classmdt_usbtmc_port_manager}{mdtUsbtmcPortManager} (Linux only) 
\end{DoxySeeAlso}


Definition at line 102 of file mdtPortManager.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_port_manager_adf797f8fd7a3ffdc000890a224e4c1b6}{
\index{mdtPortManager@{mdtPortManager}!$\sim$mdtPortManager@{$\sim$mdtPortManager}}
\index{$\sim$mdtPortManager@{$\sim$mdtPortManager}!mdtPortManager@{mdtPortManager}}
\subsubsection[{$\sim$mdtPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtPortManager::$\sim$mdtPortManager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_adf797f8fd7a3ffdc000890a224e4c1b6}


Destructor. 

If a port was set, the manager will stop (if running), and port will be closed (if open).

Note that port set by \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} and threads are not deleted. 

Definition at line 39 of file mdtPortManager.cpp.



\subsection{Member Function Documentation}
\hypertarget{classmdt_port_manager_a1d185e9bb610aee16ccd9499ae7bff0d}{
\index{mdtPortManager@{mdtPortManager}!abort@{abort}}
\index{abort@{abort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{abort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::abort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual, slot\mbox{]}}}}
\label{classmdt_port_manager_a1d185e9bb610aee16ccd9499ae7bff0d}


Cancel read and write operations. 

Default implementation calls \hyperlink{classmdt_abstract_port_abde440c49b95833f821e1333c40a7398}{mdtAbstractPort::flush()}. 

pvPort-\/$>$flushIn(); pvPort-\/$>$flushOut(); 



Definition at line 360 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}{
\index{mdtPortManager@{mdtPortManager}!addThread@{addThread}}
\index{addThread@{addThread}!mdtPortManager@{mdtPortManager}}
\subsubsection[{addThread}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::addThread (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortThread} $\ast$}]{thread}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}


Add a thread and assign it to port. 

\begin{DoxyPrecond}{Precondition}
Port must be set with setPort before using this method 

Manager must no running 

thread must be a valid pointer 
\end{DoxyPrecond}


Definition at line 97 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ad4ff1309b267dfdcfa5a12e4617397f1}{
\index{mdtPortManager@{mdtPortManager}!clearReadenFrames@{clearReadenFrames}}
\index{clearReadenFrames@{clearReadenFrames}!mdtPortManager@{mdtPortManager}}
\subsubsection[{clearReadenFrames}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::clearReadenFrames (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_ad4ff1309b267dfdcfa5a12e4617397f1}


Clear readen frames. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_ae5c6475a54ac4921c6df26893f261556}{readenFrames()} 
\end{DoxySeeAlso}


pvReadenFramesCopy.clear(); 



Definition at line 341 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ace8065f1f5083041ee7f65c2892bc77d}{
\index{mdtPortManager@{mdtPortManager}!closePort@{closePort}}
\index{closePort@{closePort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{closePort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::closePort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_ace8065f1f5083041ee7f65c2892bc77d}


Close the port. 

This stops the threads (if exists) and close the port.

If port was never set (with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} ), this method does nothing. 

Definition at line 212 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a3daaf801a26008388af390b5917d7a0c}{
\index{mdtPortManager@{mdtPortManager}!commitFrame@{commitFrame}}
\index{commitFrame@{commitFrame}!mdtPortManager@{mdtPortManager}}
\subsubsection[{commitFrame}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::commitFrame (
\begin{DoxyParamCaption}
\item[{int}]{id, }
\item[{QByteArray}]{data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a3daaf801a26008388af390b5917d7a0c}


Store frame data in queue and/or emit \hyperlink{classmdt_port_manager_a65d5d2e9edde76796714f737a7eaf204}{newReadenFrame()} signal. 

Dependeing on pvEnqueueReadenFrames and pvNotifyNewReadenFrame, frame will be enqueued and/or the \hyperlink{classmdt_port_manager_a65d5d2e9edde76796714f737a7eaf204}{newReadenFrame(int, QByteArray)} signal will be emitted.

Subclass notes:\par
 The subclass should use this method to handle new incomming frames. 

Definition at line 445 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{
\index{mdtPortManager@{mdtPortManager}!config@{config}}
\index{config@{config}!mdtPortManager@{mdtPortManager}}
\subsubsection[{config}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortConfig} \& mdtPortManager::config (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}


Get the port's config object. 

Usefull to alter internal port configuration

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_serial_port_manager_a4b8ab7b9d53966a1887d9ce8557b8416}{mdtSerialPortManager}.



Definition at line 194 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a39cb4af4aedc0b6b7c4d4f53002c3fd1}{
\index{mdtPortManager@{mdtPortManager}!detachPort@{detachPort}}
\index{detachPort@{detachPort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{detachPort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::detachPort (
\begin{DoxyParamCaption}
\item[{bool}]{deletePort, }
\item[{bool}]{deleteThreads}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a39cb4af4aedc0b6b7c4d4f53002c3fd1}


Detach port. 

Will detach port from each thread and from port manager. If port was not set, this method does nothing. If manager is running, it will be stopped. If port is open, it will be closed.


\begin{DoxyParams}{Parameters}
{\em deletePort} & If true, the port object that was set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} will be deleted. \\
\hline
{\em deleteThreads} & If true, each thread added with \hyperlink{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}{addThread()} will be deleted. \\
\hline
\end{DoxyParams}


Definition at line 76 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{
\index{mdtPortManager@{mdtPortManager}!fromThreadNewFrameReaden@{fromThreadNewFrameReaden}}
\index{fromThreadNewFrameReaden@{fromThreadNewFrameReaden}!mdtPortManager@{mdtPortManager}}
\subsubsection[{fromThreadNewFrameReaden}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::fromThreadNewFrameReaden (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual, slot\mbox{]}}}}
\label{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}


Try to. 

Called by the read thread whenn a complete frame was readen

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_thread}{mdtPortThread} 
\end{DoxySeeAlso}


\begin{Desc}
\item[\hyperlink{todo__todo000021}{Todo}]Error on incomplete frame \end{Desc}


pvReadenFrames.insert(pvLastReadenFrameId, data); 



Reimplemented in \hyperlink{classmdt_modbus_tcp_port_manager_ad941ea607f00db54aa6deb2866a539e9}{mdtModbusTcpPortManager}, and \hyperlink{classmdt_usbtmc_port_manager_aca42b343ae1f6a324e6e45968f03bbea}{mdtUsbtmcPortManager}.



Definition at line 369 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_af460167e604b8b6e2e933a98b2b6b5a2}{
\index{mdtPortManager@{mdtPortManager}!isRunning@{isRunning}}
\index{isRunning@{isRunning}!mdtPortManager@{mdtPortManager}}
\subsubsection[{isRunning}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::isRunning (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_af460167e604b8b6e2e933a98b2b6b5a2}


Get the running state. 

If one of the threads is running, true is returned.

If port was not set, it returns false. 

Definition at line 148 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a65d5d2e9edde76796714f737a7eaf204}{
\index{mdtPortManager@{mdtPortManager}!newReadenFrame@{newReadenFrame}}
\index{newReadenFrame@{newReadenFrame}!mdtPortManager@{mdtPortManager}}
\subsubsection[{newReadenFrame}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::newReadenFrame (
\begin{DoxyParamCaption}
\item[{int}]{id, }
\item[{QByteArray}]{data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a65d5d2e9edde76796714f737a7eaf204}


Emitted when new frame was readen. 

The id is the same than returned by \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{writeData()}.

Emitted only if notifyNewReadenFrame flag is true.

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_a56bb2f93ee65b4743cb19784224e3489}{setNotifyNewReadenFrame()} 
\end{DoxySeeAlso}
\hypertarget{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}{
\index{mdtPortManager@{mdtPortManager}!onThreadsErrorOccured@{onThreadsErrorOccured}}
\index{onThreadsErrorOccured@{onThreadsErrorOccured}!mdtPortManager@{mdtPortManager}}
\subsubsection[{onThreadsErrorOccured}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::onThreadsErrorOccured (
\begin{DoxyParamCaption}
\item[{int}]{error}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}slot\mbox{]}}}}
\label{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}


Manage errors comming from port threads. 

\begin{Desc}
\item[\hyperlink{todo__todo000022}{Todo}]Error handling (in general ...) \end{Desc}


if(error == \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea8b70726d03f75a691ac4ad65722a5f3c}{mdtAbstractPort::Disconnected})\{ qDebug() $<$$<$ \char`\"{}Disconnected , closing port ...\char`\"{}; \hyperlink{classmdt_port_manager_ace8065f1f5083041ee7f65c2892bc77d}{closePort()}; Try re-\/open port ok = false; while(!ok)\{ wait(5000); qDebug() $<$$<$ \char`\"{}Try to re-\/open ...\char`\"{}; ok = \hyperlink{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{openPort()}; maxTry-\/-\/; if(maxTry $<$= 0)\{ qDebug() $<$$<$ \char`\"{}Re-\/open failed\char`\"{}; return; \} \} qDebug() $<$$<$ \char`\"{}Open OK, starting ...\char`\"{}; if(!start())\{ qDebug() $<$$<$ \char`\"{}start failed :-\/(\char`\"{}; return; \} \}

if(error == MDT\_\-PORT\_\-IO\_\-ERROR)\{ qDebug() $<$$<$ \char`\"{}I/O error !\char`\"{}; \hyperlink{classmdt_port_manager_ace8065f1f5083041ee7f65c2892bc77d}{closePort()}; if(!openPort())\{ return; \} \hyperlink{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{start()}; \} if(error == MDT\_\-PORT\_\-QUEUE\_\-EMPTY\_\-ERROR)\{ qDebug() $<$$<$ \char`\"{}Queue empty !\char`\"{}; \}



Definition at line 396 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{
\index{mdtPortManager@{mdtPortManager}!openPort@{openPort}}
\index{openPort@{openPort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{openPort}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::openPort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}


Open the port. 

Will try to open port defined with \hyperlink{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}{setPortName()}.

\begin{DoxyReturn}{Returns}
True on success, false else. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}
\begin{Desc}
\item[\hyperlink{todo__todo000023}{Todo}]Should return \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \end{Desc}


Definition at line 201 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{
\index{mdtPortManager@{mdtPortManager}!readenFrame@{readenFrame}}
\index{readenFrame@{readenFrame}!mdtPortManager@{mdtPortManager}}
\subsubsection[{readenFrame}]{\setlength{\rightskip}{0pt plus 5cm}QByteArray mdtPortManager::readenFrame (
\begin{DoxyParamCaption}
\item[{int}]{id}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}


Get data by frame ID. 

The frame ID is a protocol specific identification. F.ex. in MODBUS/TCP, the transaction ID is used, or bTag for USBTMC.

If found, the frame is removed from received queue.

If ID was not found, a empty QByteArray is returned. 

Definition at line 315 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ae5c6475a54ac4921c6df26893f261556}{
\index{mdtPortManager@{mdtPortManager}!readenFrames@{readenFrames}}
\index{readenFrames@{readenFrames}!mdtPortManager@{mdtPortManager}}
\subsubsection[{readenFrames}]{\setlength{\rightskip}{0pt plus 5cm}const QList$<$ QByteArray $>$ mdtPortManager::readenFrames (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_port_manager_ae5c6475a54ac4921c6df26893f261556}


Get all readen data. 

Get all currently available data. Once data are readen, don't forget to clear incoming frames list with \hyperlink{classmdt_port_manager_ad4ff1309b267dfdcfa5a12e4617397f1}{clearReadenFrames()}.

To prevent data loss, call \hyperlink{classmdt_port_manager_ad4ff1309b267dfdcfa5a12e4617397f1}{clearReadenFrames()} just after data read. Do not use QApplication::processEvent() before, because this could insert a new frame, wich will be cleared. (see slot \hyperlink{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{fromThreadNewFrameReaden()} ).

Yout can iterate over returned list, like: 
\begin{DoxyCode}
 int i;

 // Get all frames
 for(i=0; i<manager.readenFrames().size(); i++){
   qDebug() << "Data[" << i << "]: " << manager.readenFrames().at(i);
 }
 // Clear readen frames
 manager.clearReadenFrames();
\end{DoxyCode}
 In this example, no deep copy of frames list should occur.

A other way is to reference returned list to a temporary QList: 
\begin{DoxyCode}
 QList<QByteArray> list;

 // Get all frames
 list = manager.readenFrames();
 for(i=0; i<list.size(); i++){
   qDebug() << "Data[" << i << "]: " << list.at(i);
 }
 // Clear readen frames
 list.clear();
 // Here, a deep copy occured, we must clear manager's internal list
 manager.clearReadenFrames();
\end{DoxyCode}


For more details you should read Qt's documentation about implicit-\/sharing. 

pvReadenFramesCopy.append(it.value()); pvReadenFrames.remove(it.key());

return pvReadenFramesCopy; 



Definition at line 326 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ab6a2a791de303ff20e6f7f884be681bf}{
\index{mdtPortManager@{mdtPortManager}!readenFramesQueueSizeChanged@{readenFramesQueueSizeChanged}}
\index{readenFramesQueueSizeChanged@{readenFramesQueueSizeChanged}!mdtPortManager@{mdtPortManager}}
\subsubsection[{readenFramesQueueSizeChanged}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::readenFramesQueueSizeChanged (
\begin{DoxyParamCaption}
\item[{int}]{newSize}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_ab6a2a791de303ff20e6f7f884be681bf}


Emitted when internal queue of readen frames size has changed. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} 

\hyperlink{classmdt_port_manager_ae5c6475a54ac4921c6df26893f261556}{readenFrames()} 
\end{DoxySeeAlso}
\hypertarget{classmdt_port_manager_aaa0a474183bcae0fff4fb9ef43023c25}{
\index{mdtPortManager@{mdtPortManager}!removeThreads@{removeThreads}}
\index{removeThreads@{removeThreads}!mdtPortManager@{mdtPortManager}}
\subsubsection[{removeThreads}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::removeThreads (
\begin{DoxyParamCaption}
\item[{bool}]{releaseMemory}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_aaa0a474183bcae0fff4fb9ef43023c25}


Detach threads from port and remove threads. 


\begin{DoxyParams}{Parameters}
{\em releaseMemory} & If true, all threads are deleted \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port manager must not running. 
\end{DoxyPrecond}


Definition at line 113 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}{
\index{mdtPortManager@{mdtPortManager}!scan@{scan}}
\index{scan@{scan}!mdtPortManager@{mdtPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtPortManager::scan (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}


Scan for available ports. 

This method is implemented is port's specific subclass. Default implementation returns a empty list.

Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).

\begin{DoxyPrecond}{Precondition}
Manager must no running 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_usb_port_manager_a3a2370c3a2d0353a880bf9b777728c3b}{mdtUsbPortManager}, \hyperlink{classmdt_usbtmc_port_manager_a992d1227810186d3c7dc166452e2e3b6}{mdtUsbtmcPortManager}, and \hyperlink{classmdt_serial_port_manager_a791572f869d1d605d0c4658ca4187260}{mdtSerialPortManager}.



Definition at line 61 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ae48865abce3dc2a3173ae77d7b0c107f}{
\index{mdtPortManager@{mdtPortManager}!setEnqueueReadenFrames@{setEnqueueReadenFrames}}
\index{setEnqueueReadenFrames@{setEnqueueReadenFrames}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setEnqueueReadenFrames}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setEnqueueReadenFrames (
\begin{DoxyParamCaption}
\item[{bool}]{enqueue}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_ae48865abce3dc2a3173ae77d7b0c107f}


Set the enqueue readen frames flag. 

If true, all incomming frames will be added in internal queue, and the \hyperlink{classmdt_port_manager_ab6a2a791de303ff20e6f7f884be681bf}{readenFramesQueueSizeChanged()} signal will be sent.

By default this flag is false. 

Definition at line 51 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a56bb2f93ee65b4743cb19784224e3489}{
\index{mdtPortManager@{mdtPortManager}!setNotifyNewReadenFrame@{setNotifyNewReadenFrame}}
\index{setNotifyNewReadenFrame@{setNotifyNewReadenFrame}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setNotifyNewReadenFrame}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setNotifyNewReadenFrame (
\begin{DoxyParamCaption}
\item[{bool}]{notify}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a56bb2f93ee65b4743cb19784224e3489}


Set the incomming frame notification flag. 

If true, the \hyperlink{classmdt_port_manager_a65d5d2e9edde76796714f737a7eaf204}{newReadenFrame(int, QByteArray)} signal will be emitted for each incomming frame.

By default this flag is false. 

Definition at line 56 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{
\index{mdtPortManager@{mdtPortManager}!setPort@{setPort}}
\index{setPort@{setPort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setPort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setPort (
\begin{DoxyParamCaption}
\item[{{\bf mdtAbstractPort} $\ast$}]{port}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}


Set port object. 

\begin{DoxyPrecond}{Precondition}
port must be a valid pointer to the expected class instance (for ex: \hyperlink{classmdt_serial_port}{mdtSerialPort}). 

Manager must no running 
\end{DoxyPrecond}


Definition at line 68 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a7e2ef93ec2731e66aa2b2d5f7ce9bc1c}{
\index{mdtPortManager@{mdtPortManager}!setPortInfo@{setPortInfo}}
\index{setPortInfo@{setPortInfo}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setPortInfo}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setPortInfo (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortInfo}}]{info}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a7e2ef93ec2731e66aa2b2d5f7ce9bc1c}


Set port info. 

Store given port info, and call \hyperlink{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}{setPortName()} with port info's stored port name (see \hyperlink{classmdt_port_info_ad456aac33dccc9b0583ed8aa4796cdf0}{mdtPortInfo::portName()} ).

Setting a port info can be usefull if other informations are needed later in application (f.ex. \hyperlink{classmdt_port_info_a38bcac67372782228a91d8e7dbf49211}{mdtPortInfo::displayText()} ). You can get port informations later with \hyperlink{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}{portInfo()}. 

Definition at line 183 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}{
\index{mdtPortManager@{mdtPortManager}!setPortName@{setPortName}}
\index{setPortName@{setPortName}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setPortName}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setPortName (
\begin{DoxyParamCaption}
\item[{const QString \&}]{portName}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}


Set port name. 

Set the port name to internally port object. Does nothing else. To open the port, use \hyperlink{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{openPort()}.

\begin{DoxyPrecond}{Precondition}
Port must be set before with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} 
\end{DoxyPrecond}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_abstract_port}{mdtAbstractPort} 
\end{DoxySeeAlso}


Definition at line 176 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{
\index{mdtPortManager@{mdtPortManager}!start@{start}}
\index{start@{start}!mdtPortManager@{mdtPortManager}}
\subsubsection[{start}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::start (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}


Start threads. 

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Definition at line 133 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_aacbf87cc3d9c37c87e21696f8a6514bd}{
\index{mdtPortManager@{mdtPortManager}!stop@{stop}}
\index{stop@{stop}!mdtPortManager@{mdtPortManager}}
\subsubsection[{stop}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::stop (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_aacbf87cc3d9c37c87e21696f8a6514bd}


Stop threads. 

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Definition at line 165 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_acc5c63ad33fdd3cc153fc23e00c6e69c}{
\index{mdtPortManager@{mdtPortManager}!wait@{wait}}
\index{wait@{wait}!mdtPortManager@{mdtPortManager}}
\subsubsection[{wait}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::wait (
\begin{DoxyParamCaption}
\item[{int}]{msecs, }
\item[{int}]{granularity = {\ttfamily 50}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classmdt_port_manager_acc5c63ad33fdd3cc153fc23e00c6e69c}


Wait some time without break the GUI's event loop. 

This is a helper method that provide a blocking wait. Internally, a couple of sleep and event processing is done, avoiding freesing the GUI.

This wait method is not precise.


\begin{DoxyParams}{Parameters}
{\em msecs} & Time to wait \mbox{[}ms\mbox{]} \\
\hline
{\em granularity} & Sleep time between each call of event processing \mbox{[}ms\mbox{]}\par
 A little value needs more CPU and big value can freese the GUI. Should be between 50 and 100, and must be $>$ 0. Note that msecs must be a multiple of granularity. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
granularity must be $>$ 0. 
\end{DoxyPrecond}


Definition at line 347 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a1db6b8da9ff16221c917a1a75366e5c0}{
\index{mdtPortManager@{mdtPortManager}!waitOnFrame@{waitOnFrame}}
\index{waitOnFrame@{waitOnFrame}!mdtPortManager@{mdtPortManager}}
\subsubsection[{waitOnFrame}]{\setlength{\rightskip}{0pt plus 5cm}QByteArray mdtPortManager::waitOnFrame (
\begin{DoxyParamCaption}
\item[{int}]{id, }
\item[{int}]{timeout = {\ttfamily 500}}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a1db6b8da9ff16221c917a1a75366e5c0}


Wait on readen frame with defined ID. 

Will return when frame with given ID was read or after timeout.

Internally, a couple of sleep and process event are called, so Qt's event loop will not be broken.


\begin{DoxyParams}{Parameters}
{\em id} & Frame ID. Depending on protocol, this can be a transaction ID or what else. \\
\hline
{\em timeout} & Maximum wait time \mbox{[}ms\mbox{]}. Must be a multiple of 50 \mbox{[}ms\mbox{]} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Frame's data on success or empty QByteArray on timeout 
\end{DoxyReturn}


Definition at line 289 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ae1cc1010067bcbf104fb3d1b19f2fa48}{
\index{mdtPortManager@{mdtPortManager}!waitOnWriteReady@{waitOnWriteReady}}
\index{waitOnWriteReady@{waitOnWriteReady}!mdtPortManager@{mdtPortManager}}
\subsubsection[{waitOnWriteReady}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::waitOnWriteReady (
\begin{DoxyParamCaption}
\item[{int}]{timeout, }
\item[{int}]{granularity = {\ttfamily 50}}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_ae1cc1010067bcbf104fb3d1b19f2fa48}


Wait until data can be written. 

Wait until a frame is available in write frames pool. The wait will not breack Qt's event loop, so this method can be called from GUI Thread. (See \hyperlink{classmdt_port_manager_acc5c63ad33fdd3cc153fc23e00c6e69c}{wait()} for details).


\begin{DoxyParams}{Parameters}
{\em timeout} & Timeout \mbox{[}ms\mbox{]} \\
\hline
{\em granularity} & Sleep time between each call of event processing \mbox{[}ms\mbox{]}\par
 A little value needs more CPU and big value can freese the GUI. Should be between 50 and 100, and must be $>$ 0. Note that timeout must be a multiple of granularity. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if a frame is available before timeout, false else. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Granularity must be $>$ 0. 

Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before calling this method. 
\end{DoxyPrecond}


Definition at line 223 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a44ca338c8c56893612301e09d2ee6e88}{
\index{mdtPortManager@{mdtPortManager}!waitReadenFrame@{waitReadenFrame}}
\index{waitReadenFrame@{waitReadenFrame}!mdtPortManager@{mdtPortManager}}
\subsubsection[{waitReadenFrame}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::waitReadenFrame (
\begin{DoxyParamCaption}
\item[{int}]{timeout = {\ttfamily 500}}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a44ca338c8c56893612301e09d2ee6e88}


Wait until a complete frame is available. 

This method will return when a complete frame was readen. This is usefull for query/answer protocols.

Internally, a couple of sleep and process event are called, so Qt's event loop will not be broken.


\begin{DoxyParams}{Parameters}
{\em timeout} & Maximum wait time \mbox{[}ms\mbox{]}. Must be a multiple of 50 \mbox{[}ms\mbox{]} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if Ok, false on timeout 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_a65d5d2e9edde76796714f737a7eaf204}{newReadenFrame()} 
\end{DoxySeeAlso}


Definition at line 273 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{
\index{mdtPortManager@{mdtPortManager}!writeData@{writeData}}
\index{writeData@{writeData}!mdtPortManager@{mdtPortManager}}
\subsubsection[{writeData}]{\setlength{\rightskip}{0pt plus 5cm}int mdtPortManager::writeData (
\begin{DoxyParamCaption}
\item[{QByteArray}]{data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}


Write data by copy. 

Data will be passed to the mdtPort's write queue by copy. This method returns immediatly after enqueue, and don't wait until data was written.


\begin{DoxyParams}{Parameters}
{\em data} & Data to write \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success or value $<$ 0 on error. In this implementation, the only possible error is mdtAbstractPort::WriteQueueEmpty . Some subclass can return a frame ID on success, or a other error. See subclass documentation for details. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method.
\end{DoxyPrecond}
Subclass notes:\par
 This method can be reimplemented in subclass if needed. Typically usefull if some encoding is needed before the frame is submitted to port. A frame must be taken from port's write frames pool with \hyperlink{classmdt_abstract_port_abf093b67fddebffa4f3c52277b9a8cf7}{mdtAbstractPort::writeFramesPool()} dequeue() method (see Qt's QQueue documentation for more details on dequeue() ), then added to port's write queue with \hyperlink{classmdt_abstract_port_a9a69eb2fc07d551ab37c011487fa319d}{mdtAbstractPort::addFrameToWrite()} . If protocol supports frame identification (like MODBUS's transaction ID or USBTMC's bTag), it should be returned here and incremented. 

Reimplemented in \hyperlink{classmdt_modbus_tcp_port_manager_a0c56b7d38cfb52d95e81de4ca6ac414f}{mdtModbusTcpPortManager}, and \hyperlink{classmdt_usbtmc_port_manager_ab7229e9d519e80a6509bec90dc9239b3}{mdtUsbtmcPortManager}.



Definition at line 246 of file mdtPortManager.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtPortManager.h\item 
src/mdtport/mdtPortManager.cpp\end{DoxyCompactItemize}
