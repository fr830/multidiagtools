\hypertarget{classmdt_port_thread}{
\section{mdtPortThread Class Reference}
\label{classmdt_port_thread}\index{mdtPortThread@{mdtPortThread}}
}


Inheritance diagram for mdtPortThread:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{classmdt_port_thread__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtPortThread:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=168pt]{classmdt_port_thread__coll__graph}
\end{center}
\end{figure}
\subsection*{Signals}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_port_thread_abb7234a12814f5c7c98bd6c1c2ccb776}{readProcessBegin} ()
\begin{DoxyCompactList}\small\item\em Emitted when a read process begins. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_thread_aa01aac7e1a26deb823be40e6cb01b255}{writeProcessBegin} ()
\begin{DoxyCompactList}\small\item\em Emitted when a write process begins. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_thread_a7fc2245c753fd65e1beffec211c41461}{newFrameReaden} ()
\begin{DoxyCompactList}\small\item\em Emited when a new frame is available. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_thread_ab31cbe1a85aa830cd368654d1f806326}{errorOccured} (int error)
\begin{DoxyCompactList}\small\item\em Emitted on error. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_thread_ae71ae3aa58eb1f409a2b128e6ef3148b}{
void \hyperlink{classmdt_port_thread_ae71ae3aa58eb1f409a2b128e6ef3148b}{ready} (\hyperlink{classmdt_port_thread}{mdtPortThread} $\ast$thread)}
\label{classmdt_port_thread_ae71ae3aa58eb1f409a2b128e6ef3148b}

\begin{DoxyCompactList}\small\item\em Emitted when thread is started and ready. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_thread_a4266192826f09d8186ee8f9b646ac089}{
void \hyperlink{classmdt_port_thread_a4266192826f09d8186ee8f9b646ac089}{finished} (\hyperlink{classmdt_port_thread}{mdtPortThread} $\ast$thread)}
\label{classmdt_port_thread_a4266192826f09d8186ee8f9b646ac089}

\begin{DoxyCompactList}\small\item\em Emitted when thread has finished executing. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_thread_a88070ed43976a83b6e4d289d6f1827bd}{connected} ()
\begin{DoxyCompactList}\small\item\em Emitted when connection with device is done. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_port_thread_aa20869c68d7a016f9e547464f0d8b71e}{
{\bfseries mdtPortThread} (QObject $\ast$parent=0)}
\label{classmdt_port_thread_aa20869c68d7a016f9e547464f0d8b71e}

\item 
virtual void \hyperlink{classmdt_port_thread_acd51474c3a2683676423317bc9cb31b2}{setPort} (\hyperlink{classmdt_abstract_port}{mdtAbstractPort} $\ast$port)
\begin{DoxyCompactList}\small\item\em Set the port instance. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port}{mdtAbstractPort} $\ast$ \hyperlink{classmdt_port_thread_a97bff8cf6aca37d8858cc4e5c9294cae}{port} ()
\begin{DoxyCompactList}\small\item\em Get port instance. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_port_thread_a29b434534a5564efbd9dfe570a61b143}{detachPort} (bool releaseMemory)
\begin{DoxyCompactList}\small\item\em Detach the port from thread. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_thread_a5a5c1290eaa43182d69c3f39eadbec00}{start} ()
\begin{DoxyCompactList}\small\item\em Start the thread. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_port_thread_a5746ea96689ed80179751ad1353f0b39}{stop} ()
\begin{DoxyCompactList}\small\item\em Stop the running thread. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_thread_aca7473f73c6b68fe8c3e1cfc349240e7}{waitReady} ()
\begin{DoxyCompactList}\small\item\em Wait until thread is ready. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_thread_a621c0748a16bc9ee15983ef488314c85}{waitFinished} ()
\begin{DoxyCompactList}\small\item\em Wait until thread is finished. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_thread_ae1becf17263dd9fbf5dfcc6c51eddd72}{isRunning} () const 
\begin{DoxyCompactList}\small\item\em Returns true if the thread is running. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_thread_ad9bcfaa66fba25512f2677a7e320c6c8}{setRunningFlag} (bool running)
\begin{DoxyCompactList}\small\item\em Set the running flag. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_thread_abce96e61e09780841b729f28ab9054f0}{runningFlagSet} () const 
\begin{DoxyCompactList}\small\item\em Get the running flag. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_thread_a55d7ef615447823bf9878492a2c88fd4}{isFinished} () const 
\begin{DoxyCompactList}\small\item\em Returns false if the thread is running. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classmdt_port_thread_acdb3d96287c571cc08ef39860dc324b1}{isReader} () const 
\begin{DoxyCompactList}\small\item\em Returns true if this thread reads data and send the \hyperlink{classmdt_port_thread_a7fc2245c753fd65e1beffec211c41461}{newFrameReaden()} signal. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classmdt_port_thread_a0122a12262052cf3643241a3eaa31c58}{isWriter} () const 
\begin{DoxyCompactList}\small\item\em Returns true if this thread writes date. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classmdt_port_thread_aaf671b84f7c1fb508ff9221dccee4c15}{handlesTimeout} () const 
\begin{DoxyCompactList}\small\item\em Returns true is thread handles timeout(s) itself. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_thread_a30bdd11ef16d4f3321921c9d9b26399d}{notifyError} (\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} error, bool renotifySameError=false)
\begin{DoxyCompactList}\small\item\em Emit the \hyperlink{classmdt_port_thread_ab31cbe1a85aa830cd368654d1f806326}{errorOccured()} signal if new error is different from current. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \hyperlink{classmdt_port_thread_adbc2d86162c23401e75184407b8c9428}{currentError} () const 
\begin{DoxyCompactList}\small\item\em Get current error. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \hyperlink{classmdt_port_thread_abee1d2f9b67ca37cfd13e108ca978b36}{reconnect} (bool notify=true)
\begin{DoxyCompactList}\small\item\em Try to reconnect to device/peer. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_port_thread_a01d2362e0dfcece4cba242cb586d8d1c}{
static void {\bfseries sigactionHandle} (int signum)}
\label{classmdt_port_thread_a01d2362e0dfcece4cba242cb586d8d1c}

\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_port_thread_a59735ef01b761361b1055a0356be525a}{
volatile bool {\bfseries pvRunning}}
\label{classmdt_port_thread_a59735ef01b761361b1055a0356be525a}

\item 
\hypertarget{classmdt_port_thread_af5c4bed0c9fb012f220fba013d0f69b8}{
\hyperlink{classmdt_abstract_port}{mdtAbstractPort} $\ast$ {\bfseries pvPort}}
\label{classmdt_port_thread_af5c4bed0c9fb012f220fba013d0f69b8}

\item 
\hypertarget{classmdt_port_thread_a7154af7d387eecaea113ddb5900ff23c}{
pthread\_\-t {\bfseries pvNativePthreadObject}}
\label{classmdt_port_thread_a7154af7d387eecaea113ddb5900ff23c}

\item 
\hypertarget{classmdt_port_thread_ae22f83fd56b06cdaa9b77abafe85a6b4}{
struct sigaction {\bfseries pvSigaction}}
\label{classmdt_port_thread_ae22f83fd56b06cdaa9b77abafe85a6b4}

\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 36 of file mdtPortThread.h.



\subsection{Member Function Documentation}
\hypertarget{classmdt_port_thread_a88070ed43976a83b6e4d289d6f1827bd}{
\index{mdtPortThread@{mdtPortThread}!connected@{connected}}
\index{connected@{connected}!mdtPortThread@{mdtPortThread}}
\subsubsection[{connected}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::connected (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_thread_a88070ed43976a83b6e4d289d6f1827bd}


Emitted when connection with device is done. 

Notes:
\begin{DoxyItemize}
\item Disconnection, connection, etc... are notified as error
\item Some threads does not send this signal, because device connection is not handled directly by port protocol. 
\end{DoxyItemize}\hypertarget{classmdt_port_thread_adbc2d86162c23401e75184407b8c9428}{
\index{mdtPortThread@{mdtPortThread}!currentError@{currentError}}
\index{currentError@{currentError}!mdtPortThread@{mdtPortThread}}
\subsubsection[{currentError}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtPortThread::currentError (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_port_thread_adbc2d86162c23401e75184407b8c9428}


Get current error. 

This is used by \hyperlink{classmdt_port_manager}{mdtPortManager}.

Port's mutex is not handled by this method. 

Definition at line 225 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_a29b434534a5564efbd9dfe570a61b143}{
\index{mdtPortThread@{mdtPortThread}!detachPort@{detachPort}}
\index{detachPort@{detachPort}!mdtPortThread@{mdtPortThread}}
\subsubsection[{detachPort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::detachPort (
\begin{DoxyParamCaption}
\item[{bool}]{releaseMemory}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_thread_a29b434534a5564efbd9dfe570a61b143}


Detach the port from thread. 


\begin{DoxyParams}{Parameters}
{\em releaseMemory} & If true, the port object that was set with \hyperlink{classmdt_port_thread_acd51474c3a2683676423317bc9cb31b2}{setPort()} will be deleted. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The thread must not running 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_usb_port_thread_a99070e7dba4bd7939b054cddbd66979f}{mdtUsbPortThread}.



Definition at line 70 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_ab31cbe1a85aa830cd368654d1f806326}{
\index{mdtPortThread@{mdtPortThread}!errorOccured@{errorOccured}}
\index{errorOccured@{errorOccured}!mdtPortThread@{mdtPortThread}}
\subsubsection[{errorOccured}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::errorOccured (
\begin{DoxyParamCaption}
\item[{int}]{error}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_thread_ab31cbe1a85aa830cd368654d1f806326}


Emitted on error. 

\begin{Desc}
\item[\hyperlink{todo__todo000045}{Todo}]Adapt threads + port managers\end{Desc}


When a error occurs, this signal is emited.

The error is one of the \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t}.

\hyperlink{classmdt_port_manager}{mdtPortManager} uses this signal. \hypertarget{classmdt_port_thread_aaf671b84f7c1fb508ff9221dccee4c15}{
\index{mdtPortThread@{mdtPortThread}!handlesTimeout@{handlesTimeout}}
\index{handlesTimeout@{handlesTimeout}!mdtPortThread@{mdtPortThread}}
\subsubsection[{handlesTimeout}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortThread::handlesTimeout (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_thread_aaf671b84f7c1fb508ff9221dccee4c15}


Returns true is thread handles timeout(s) itself. 

For example, \hyperlink{classmdt_usb_port_thread}{mdtUsbPortThread} and subclasses handles timeout itself. \hyperlink{classmdt_port_read_thread}{mdtPortReadThread} does not.

\hyperlink{classmdt_port_manager}{mdtPortManager} uses this flag to know how to deal with timeouts.

This implementation returns false. 

Reimplemented in \hyperlink{classmdt_port_read_thread_afa42f86f3fed878b8f44cacb3a2f41af}{mdtPortReadThread}, \hyperlink{classmdt_tcp_socket_thread_aa14c9838dfb8d2defac449b8b58bbc7c}{mdtTcpSocketThread}, and \hyperlink{classmdt_usb_port_thread_aeaa2dabc53e57f6b7cf7077d113c7f40}{mdtUsbPortThread}.



Definition at line 211 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_a55d7ef615447823bf9878492a2c88fd4}{
\index{mdtPortThread@{mdtPortThread}!isFinished@{isFinished}}
\index{isFinished@{isFinished}!mdtPortThread@{mdtPortThread}}
\subsubsection[{isFinished}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortThread::isFinished (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_port_thread_a55d7ef615447823bf9878492a2c88fd4}


Returns false if the thread is running. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_thread_ae1becf17263dd9fbf5dfcc6c51eddd72}{isRunning()} 
\end{DoxySeeAlso}


Definition at line 185 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_acdb3d96287c571cc08ef39860dc324b1}{
\index{mdtPortThread@{mdtPortThread}!isReader@{isReader}}
\index{isReader@{isReader}!mdtPortThread@{mdtPortThread}}
\subsubsection[{isReader}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortThread::isReader (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_thread_acdb3d96287c571cc08ef39860dc324b1}


Returns true if this thread reads data and send the \hyperlink{classmdt_port_thread_a7fc2245c753fd65e1beffec211c41461}{newFrameReaden()} signal. 

\hyperlink{classmdt_port_manager}{mdtPortManager} can handle many threads. It needs to know wich one will send the \hyperlink{classmdt_port_thread_a7fc2245c753fd65e1beffec211c41461}{newFrameReaden()} signal, so it can connect it to his slot.

Default implementation returns allways false.

This method should be implemented in reader subclass. 

Reimplemented in \hyperlink{classmdt_port_read_thread_a0138d613b61056c9f8373331de2d9a84}{mdtPortReadThread}, \hyperlink{classmdt_port_write_thread_ac37bb988773f624def51e841998a2f1e}{mdtPortWriteThread}, \hyperlink{classmdt_tcp_socket_thread_a3224f12c8ff8d695975030f3f6215010}{mdtTcpSocketThread}, \hyperlink{classmdt_usb_port_thread_aed82b57c84745f1e2391750697db1022}{mdtUsbPortThread}, \hyperlink{classmdt_usbtmc_port_thread_a27c115427b49d5ae988c9f9c9a5e402a}{mdtUsbtmcPortThread}, and \hyperlink{classmdt_serial_port_ctl_thread_ab87413cedc8d0540eac553e55a3f6407}{mdtSerialPortCtlThread}.



Definition at line 201 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_ae1becf17263dd9fbf5dfcc6c51eddd72}{
\index{mdtPortThread@{mdtPortThread}!isRunning@{isRunning}}
\index{isRunning@{isRunning}!mdtPortThread@{mdtPortThread}}
\subsubsection[{isRunning}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortThread::isRunning (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_port_thread_ae1becf17263dd9fbf5dfcc6c51eddd72}


Returns true if the thread is running. 

This function overloads the QThread::isRunning() function. Note for subclass: when the thread is started and ready, the private member pvRunning must be set to true. 

Definition at line 157 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_a0122a12262052cf3643241a3eaa31c58}{
\index{mdtPortThread@{mdtPortThread}!isWriter@{isWriter}}
\index{isWriter@{isWriter}!mdtPortThread@{mdtPortThread}}
\subsubsection[{isWriter}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortThread::isWriter (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_thread_a0122a12262052cf3643241a3eaa31c58}


Returns true if this thread writes date. 

Is used by \hyperlink{classmdt_port_thread_a5746ea96689ed80179751ad1353f0b39}{mdtPortThread::stop()} to know if \hyperlink{classmdt_abstract_port_ae67c815f68317c70e398eaa86622af6b}{mdtAbstractPort::abortFrameToWriteWait()} must be called.

Default implementation returns false 

Reimplemented in \hyperlink{classmdt_port_write_thread_ad2508c3a2433383e2de705e9f3d2e602}{mdtPortWriteThread}, \hyperlink{classmdt_tcp_socket_thread_a014ad2b3a5fbe7031eeb1d42d8f0767d}{mdtTcpSocketThread}, \hyperlink{classmdt_usb_port_thread_a74258f300967b5dea1fbfa9a0ccab38a}{mdtUsbPortThread}, and \hyperlink{classmdt_usbtmc_port_thread_a4c58b7140f0483a19723b14487907423}{mdtUsbtmcPortThread}.



Definition at line 206 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_a7fc2245c753fd65e1beffec211c41461}{
\index{mdtPortThread@{mdtPortThread}!newFrameReaden@{newFrameReaden}}
\index{newFrameReaden@{newFrameReaden}!mdtPortThread@{mdtPortThread}}
\subsubsection[{newFrameReaden}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::newFrameReaden (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_thread_a7fc2245c753fd65e1beffec211c41461}


Emited when a new frame is available. 

This signal is emited when a new frame is available.

To get the frame, the simplest way is to use a \hyperlink{classmdt_port_manager}{mdtPortManager}.

It's also possible to use \hyperlink{classmdt_port}{mdtPort}, but this solution needs to handle the mutex, verify the readen queue state, ...

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager}{mdtPortManager} 

\hyperlink{classmdt_port}{mdtPort} 
\end{DoxySeeAlso}
\hypertarget{classmdt_port_thread_a30bdd11ef16d4f3321921c9d9b26399d}{
\index{mdtPortThread@{mdtPortThread}!notifyError@{notifyError}}
\index{notifyError@{notifyError}!mdtPortThread@{mdtPortThread}}
\subsubsection[{notifyError}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::notifyError (
\begin{DoxyParamCaption}
\item[{{\bf mdtAbstractPort::error\_\-t}}]{error, }
\item[{bool}]{renotifySameError = {\ttfamily false}}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_thread_a30bdd11ef16d4f3321921c9d9b26399d}


Emit the \hyperlink{classmdt_port_thread_ab31cbe1a85aa830cd368654d1f806326}{errorOccured()} signal if new error is different from current. 


\begin{DoxyParams}{Parameters}
{\em renotifySameError} & For some cases, the same error must be notified each time it happens. If this flag is true, signal is emitted without checking previous error. \\
\hline
\end{DoxyParams}


Definition at line 216 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_a97bff8cf6aca37d8858cc4e5c9294cae}{
\index{mdtPortThread@{mdtPortThread}!port@{port}}
\index{port@{port}!mdtPortThread@{mdtPortThread}}
\subsubsection[{port}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort} $\ast$ mdtPortThread::port (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_thread_a97bff8cf6aca37d8858cc4e5c9294cae}


Get port instance. 

\begin{DoxyReturn}{Returns}
Port instance, or a null pointer if it was not set 
\end{DoxyReturn}


Definition at line 65 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_abb7234a12814f5c7c98bd6c1c2ccb776}{
\index{mdtPortThread@{mdtPortThread}!readProcessBegin@{readProcessBegin}}
\index{readProcessBegin@{readProcessBegin}!mdtPortThread@{mdtPortThread}}
\subsubsection[{readProcessBegin}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::readProcessBegin (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_thread_abb7234a12814f5c7c98bd6c1c2ccb776}


Emitted when a read process begins. 

This can be used to display read state. Please consider that this signal is emitted each time the read process begins, and not when it ends. This is because asynch I/O calls are fast, and nothing will be seen from user if we update state before/after I/O call. To handle this, use this signal as trigger, and hold the state some stime (f.ex. 100 \mbox{[}ms\mbox{]}) \hypertarget{classmdt_port_thread_abee1d2f9b67ca37cfd13e108ca978b36}{
\index{mdtPortThread@{mdtPortThread}!reconnect@{reconnect}}
\index{reconnect@{reconnect}!mdtPortThread@{mdtPortThread}}
\subsubsection[{reconnect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtPortThread::reconnect (
\begin{DoxyParamCaption}
\item[{bool}]{notify = {\ttfamily true}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_thread_abee1d2f9b67ca37cfd13e108ca978b36}


Try to reconnect to device/peer. 

This is a helper method for subclass. When a port method returns a Disconnected error, the thread can call this method, wich will try to reconnect (using \hyperlink{classmdt_abstract_port_aec74b2db1a629d98a95d8f042ea96653}{mdtAbstractPort::reconnect()} ) until max retry was reached.

Reconnect timeout and max try are readen from port config, in \hyperlink{classmdt_port_thread_a5a5c1290eaa43182d69c3f39eadbec00}{start()} method.


\begin{DoxyParams}{Parameters}
{\em notify} & If true, error will be notified (with \hyperlink{classmdt_port_thread_ab31cbe1a85aa830cd368654d1f806326}{errorOccured()} ), and failure after maxTry will be reported with \hyperlink{classmdt_error}{mdtError}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
NoError if reconnection worked or UnhandledError else.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_thread_acd51474c3a2683676423317bc9cb31b2}{setPort()} before using this method. 
\end{DoxyPrecond}


notifyError(mdtAbstractPort::NoError); ///\begin{Desc}
\item[\hyperlink{todo__todo000043}{Todo}]emit \hyperlink{classmdt_port_thread_a88070ed43976a83b6e4d289d6f1827bd}{connected()} \end{Desc}


notifyError(mdtAbstractPort::Disconnected); ///\begin{Desc}
\item[\hyperlink{todo__todo000044}{Todo}]notify ConnectionFailed \end{Desc}




Definition at line 230 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_abce96e61e09780841b729f28ab9054f0}{
\index{mdtPortThread@{mdtPortThread}!runningFlagSet@{runningFlagSet}}
\index{runningFlagSet@{runningFlagSet}!mdtPortThread@{mdtPortThread}}
\subsubsection[{runningFlagSet}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortThread::runningFlagSet (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_port_thread_abce96e61e09780841b729f28ab9054f0}


Get the running flag. 

This method is used by \hyperlink{classmdt_port_thread_helper}{mdtPortThreadHelper} and should not be used directly.

Port's mutex is not handled in this method. 

Definition at line 180 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_acd51474c3a2683676423317bc9cb31b2}{
\index{mdtPortThread@{mdtPortThread}!setPort@{setPort}}
\index{setPort@{setPort}!mdtPortThread@{mdtPortThread}}
\subsubsection[{setPort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::setPort (
\begin{DoxyParamCaption}
\item[{{\bf mdtAbstractPort} $\ast$}]{port}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_thread_acd51474c3a2683676423317bc9cb31b2}


Set the port instance. 

\begin{DoxyPrecond}{Precondition}
port must be a valid pointer 

The thread must not running 
\end{DoxyPrecond}


Definition at line 57 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_ad9bcfaa66fba25512f2677a7e320c6c8}{
\index{mdtPortThread@{mdtPortThread}!setRunningFlag@{setRunningFlag}}
\index{setRunningFlag@{setRunningFlag}!mdtPortThread@{mdtPortThread}}
\subsubsection[{setRunningFlag}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::setRunningFlag (
\begin{DoxyParamCaption}
\item[{bool}]{running}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_thread_ad9bcfaa66fba25512f2677a7e320c6c8}


Set the running flag. 

This method is used by \hyperlink{classmdt_port_thread_helper}{mdtPortThreadHelper} and should not be used directly.

Port's mutex is not handled in this method. 

Definition at line 175 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_a5a5c1290eaa43182d69c3f39eadbec00}{
\index{mdtPortThread@{mdtPortThread}!start@{start}}
\index{start@{start}!mdtPortThread@{mdtPortThread}}
\subsubsection[{start}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::start (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_thread_a5a5c1290eaa43182d69c3f39eadbec00}


Start the thread. 

This method will not wait until thread is running and ready. Once thread is ready, \hyperlink{classmdt_port_thread_ae71ae3aa58eb1f409a2b128e6ef3148b}{ready()} signal is emitted.

\begin{DoxyPrecond}{Precondition}
Port instance must be defined. 

Port must have a valid configuration. 
\end{DoxyPrecond}


Definition at line 80 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_a5746ea96689ed80179751ad1353f0b39}{
\index{mdtPortThread@{mdtPortThread}!stop@{stop}}
\index{stop@{stop}!mdtPortThread@{mdtPortThread}}
\subsubsection[{stop}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::stop (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_thread_a5746ea96689ed80179751ad1353f0b39}


Stop the running thread. 

This method will not wait until thread is stopped. Once thread is stopped, \hyperlink{classmdt_port_thread_a4266192826f09d8186ee8f9b646ac089}{finished()} signal is emitted.

\begin{DoxyPrecond}{Precondition}
Port instance must be defined with \hyperlink{classmdt_port_thread_acd51474c3a2683676423317bc9cb31b2}{setPort()}. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_port_write_thread_a69702ab3a95c238fb451f866efc7cb34}{mdtPortWriteThread}.



Definition at line 92 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_a621c0748a16bc9ee15983ef488314c85}{
\index{mdtPortThread@{mdtPortThread}!waitFinished@{waitFinished}}
\index{waitFinished@{waitFinished}!mdtPortThread@{mdtPortThread}}
\subsubsection[{waitFinished}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::waitFinished (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_thread_a621c0748a16bc9ee15983ef488314c85}


Wait until thread is finished. 

This is a conveniance method, mainly used by test suite. Port manager, for example, use the finished signal ensteatd of this method. 

Definition at line 148 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_aca7473f73c6b68fe8c3e1cfc349240e7}{
\index{mdtPortThread@{mdtPortThread}!waitReady@{waitReady}}
\index{waitReady@{waitReady}!mdtPortThread@{mdtPortThread}}
\subsubsection[{waitReady}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::waitReady (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_thread_aca7473f73c6b68fe8c3e1cfc349240e7}


Wait until thread is ready. 

This is a conveniance method, mainly used by test suite. Port manager, for example, use the ready signal ensteatd of this method. 

Definition at line 139 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_aa01aac7e1a26deb823be40e6cb01b255}{
\index{mdtPortThread@{mdtPortThread}!writeProcessBegin@{writeProcessBegin}}
\index{writeProcessBegin@{writeProcessBegin}!mdtPortThread@{mdtPortThread}}
\subsubsection[{writeProcessBegin}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::writeProcessBegin (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_thread_aa01aac7e1a26deb823be40e6cb01b255}


Emitted when a write process begins. 

This can be used to display write state. Please consider that this signal is emitted each time the write process begins, and not when it ends. This is because asynch I/O calls are fast, and nothing will be seen from user if we update state before/after I/O call. To handle this, use this signal as trigger, and hold the state some stime (f.ex. 100 \mbox{[}ms\mbox{]}) 

The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtPortThread.h\item 
src/mdtport/mdtPortThread.cpp\end{DoxyCompactItemize}
