\hypertarget{classmdt_abstract_port}{
\section{mdtAbstractPort Class Reference}
\label{classmdt_abstract_port}\index{mdtAbstractPort@{mdtAbstractPort}}
}


Base class for port I/O.  




{\ttfamily \#include $<$mdtAbstractPort.h$>$}



Inheritance diagram for mdtAbstractPort:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{classmdt_abstract_port__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtAbstractPort:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=168pt]{classmdt_abstract_port__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \{ \par
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eab898bd273effe5cb4ed1a399a2d4baad}{NoError} =  0, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eaedd63daf0db75794bb8e8e467da9575c}{PortLocked} =  -\/1000, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea54a896ba3ff98896390e87bfe1f29eb0}{PortNotFound}, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eaee5a84e59e9dc5fcf27cac57068bb1f4}{PortAccess}, 
\par
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea3d692317af7125319f60204df3101307}{SetupError}, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eae50ff4a9393507ad39005ddc7d5be42f}{WriteCanceled}, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eac910ca649b9eaa64e290be41945a61dc}{ReadCanceled}, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea44eaa84d8f888f4f9d5c814291e54079}{ControlCanceled}, 
\par
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea487558758ab0d582d6cf497a785e40c5}{ReadTimeout}, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eac3a5cee51d4fb0b3bfb7c49604059c6a}{WriteTimeout}, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea9611d47cf51e23aff74a6d2f41ceae2e}{MessageInTimeout}, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea421ccee58528bbdba8a3b32da3ceca97}{MessageInCanceled}, 
\par
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eabdb5a36cd2c7dd2dcf59e996fc4922c9}{ControlTimeout}, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea8b70726d03f75a691ac4ad65722a5f3c}{Disconnected}, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea0edfb7a2f0daf9501874543ecaae8e93}{Connecting}, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea79cfce29fadf5a27dbcbc6e0cbc8d118}{ConnectionFailed}, 
\par
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea6e24e272af4da51c84eef5825c5cd712}{UnhandledError}, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea5059c1f30381b95b14a0b33445d2a984}{ReadPoolEmpty}, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea823db75227ad56b6aa74ea2f160c0693}{WritePoolEmpty}, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eab0a372501b8916e3953897dc82fd3b3d}{ErrorHandled}, 
\par
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea2d198672405289a1a7e662492ff073f8}{ReadWriteBusy}, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eaf89af56394b281f71247cd2eb4eaac62}{UsbWriteStall}, 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea7b3edb569231d6ebd0c933974df60160}{UsbReadStall}
 \}
\begin{DoxyCompactList}\small\item\em Error. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_abstract_port_a35e7bff9413690833c832bf115da102f}{
{\bfseries mdtAbstractPort} (QObject $\ast$parent=0)}
\label{classmdt_abstract_port_a35e7bff9413690833c832bf115da102f}

\item 
virtual \hyperlink{classmdt_abstract_port_aa40baa0c593fef984f3796acafceee15}{$\sim$mdtAbstractPort} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_abstract_port_a0ca143d32fc677bac7c1cf0e04144932}{setPortName} (const QString \&portName)
\begin{DoxyCompactList}\small\item\em Set the port name. \end{DoxyCompactList}\item 
\hypertarget{classmdt_abstract_port_ac52fbd121f7cbb848a2f3e5d29fae615}{
QString \& \hyperlink{classmdt_abstract_port_ac52fbd121f7cbb848a2f3e5d29fae615}{portName} ()}
\label{classmdt_abstract_port_ac52fbd121f7cbb848a2f3e5d29fae615}

\begin{DoxyCompactList}\small\item\em Get port name. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_abstract_port_a4e0f0b7f9e24257677184e4bde10fdde}{open} ()
\begin{DoxyCompactList}\small\item\em Open the port given by \hyperlink{classmdt_abstract_port_a0ca143d32fc677bac7c1cf0e04144932}{setPortName()} \end{DoxyCompactList}\item 
\hypertarget{classmdt_abstract_port_a2122ae3141342ff38c8388e62b244e3b}{
bool \hyperlink{classmdt_abstract_port_a2122ae3141342ff38c8388e62b244e3b}{isOpen} () const }
\label{classmdt_abstract_port_a2122ae3141342ff38c8388e62b244e3b}

\begin{DoxyCompactList}\small\item\em Get port's open state. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_abstract_port_a1ace1a2bd1a04f16952980e247b04800}{close} ()
\begin{DoxyCompactList}\small\item\em Close the port. \end{DoxyCompactList}\item 
\hypertarget{classmdt_abstract_port_a48bdc0a8057c3b119763643098cf798f}{
void \hyperlink{classmdt_abstract_port_a48bdc0a8057c3b119763643098cf798f}{setConfig} (\hyperlink{classmdt_port_config}{mdtPortConfig} $\ast$cfg)}
\label{classmdt_abstract_port_a48bdc0a8057c3b119763643098cf798f}

\begin{DoxyCompactList}\small\item\em Set configuration. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_config}{mdtPortConfig} \& \hyperlink{classmdt_abstract_port_a3d105c90696f7c40f29c24fe9b6e4481}{config} ()
\begin{DoxyCompactList}\small\item\em Get the stored configuration. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_abstract_port_abc9f1154ac71c4e31ac3e7a3ff4c5182}{setup} ()
\begin{DoxyCompactList}\small\item\em Setup port with given configurations. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_abstract_port_aec74b2db1a629d98a95d8f042ea96653}{reconnect} (int timeout)
\begin{DoxyCompactList}\small\item\em Reconnect device/peer. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_abstract_port_a6589b04467e0073d18ba872201bdcd84}{setReadTimeout} (int timeout)=0
\begin{DoxyCompactList}\small\item\em Set the read data timeout. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_abstract_port_a12eb422d52ebb09a650f8497b258c2e7}{setWriteTimeout} (int timeout)=0
\begin{DoxyCompactList}\small\item\em Set the write data timeout. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_abstract_port_aeda364cb191da1038a22dd1fc06a1d49}{waitForReadyRead} ()=0
\begin{DoxyCompactList}\small\item\em Wait until data is available on port. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_abstract_port_a47f4db2e72b5fd3e32162e6a898fd391}{waitForReadyRead} (int msecs)
\begin{DoxyCompactList}\small\item\em Wait until data is available on port. \end{DoxyCompactList}\item 
virtual qint64 \hyperlink{classmdt_abstract_port_a9d9c45220d5328c9856a2445557fe970}{read} (char $\ast$data, qint64 maxSize)=0
\begin{DoxyCompactList}\small\item\em Read data from port. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classmdt_abstract_port_aff3d79248baf96e670eba6d2fef700b9}{suspendTransmission} ()
\begin{DoxyCompactList}\small\item\em Request to suspend transmission. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classmdt_abstract_port_ad4a04c995df881593db0a309000be7a7}{resumeTransmission} ()
\begin{DoxyCompactList}\small\item\em Request to resume transmission. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_abstract_port_a32329b4188db796401e4f454755acb44}{flushIn} ()
\begin{DoxyCompactList}\small\item\em Flush read buffers. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_abstract_port_a54b7bfb725c91b2c292a39275b877207}{flushInRequestPending} ()
\begin{DoxyCompactList}\small\item\em Check if a flush in request is pending. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_abstract_port_a35e4686f50e2c53c7e3618cf2c485d92}{waitEventWriteReady} ()=0
\begin{DoxyCompactList}\small\item\em Wait until data can be written to port. \end{DoxyCompactList}\item 
virtual qint64 \hyperlink{classmdt_abstract_port_a64d4802975a76474b9196c91f57a6d90}{write} (const char $\ast$data, qint64 maxSize)=0
\begin{DoxyCompactList}\small\item\em Write data to port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_abstract_port_ad199c6310801893f1f7de2a2391606fc}{flushOut} ()
\begin{DoxyCompactList}\small\item\em Flush write buffers. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_abstract_port_a2cc79d9288bebafaa183753dcf0807f3}{flushOutRequestPending} ()
\begin{DoxyCompactList}\small\item\em Check if a flush out request is pending. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_abstract_port_abde440c49b95833f821e1333c40a7398}{flush} ()
\begin{DoxyCompactList}\small\item\em Flush read/write buffers. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_abstract_port_adf06d095d6c3e6ce939a3998bcf8b829}{initQueues} ()
\begin{DoxyCompactList}\small\item\em Init the read ans write queues. \end{DoxyCompactList}\item 
QQueue$<$ \hyperlink{classmdt_frame}{mdtFrame} $\ast$ $>$ \& \hyperlink{classmdt_abstract_port_a05356a33dc546a11d2794a0419d749e0}{readenFrames} ()
\begin{DoxyCompactList}\small\item\em Get the readen frames Queue. \end{DoxyCompactList}\item 
QQueue$<$ \hyperlink{classmdt_frame}{mdtFrame} $\ast$ $>$ \& \hyperlink{classmdt_abstract_port_a3850ab819a8fc5dad22af14b74c45274}{readFramesPool} ()
\begin{DoxyCompactList}\small\item\em Get the read frames Queue pool. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_abstract_port_a9a69eb2fc07d551ab37c011487fa319d}{addFrameToWrite} (\hyperlink{classmdt_frame}{mdtFrame} $\ast$frame)
\begin{DoxyCompactList}\small\item\em Add a frame to write. \end{DoxyCompactList}\item 
\hyperlink{classmdt_frame}{mdtFrame} $\ast$ \hyperlink{classmdt_abstract_port_a6c5ebd4451aec959efc4e71ab1b13941}{getFrameToWrite} ()
\begin{DoxyCompactList}\small\item\em Wait until a frame to write is available and get it. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_abstract_port_ae67c815f68317c70e398eaa86622af6b}{abortFrameToWriteWait} ()
\begin{DoxyCompactList}\small\item\em Abort the frame tp write waiting. \end{DoxyCompactList}\item 
QQueue$<$ \hyperlink{classmdt_frame}{mdtFrame} $\ast$ $>$ \& \hyperlink{classmdt_abstract_port_a4fed10be147dfce6ca315467ff3fb968}{writeFrames} ()
\begin{DoxyCompactList}\small\item\em Get the write frames Queue. \end{DoxyCompactList}\item 
QQueue$<$ \hyperlink{classmdt_frame}{mdtFrame} $\ast$ $>$ \& \hyperlink{classmdt_abstract_port_abf093b67fddebffa4f3c52277b9a8cf7}{writeFramesPool} ()
\begin{DoxyCompactList}\small\item\em Get the write frames Queue pool. \end{DoxyCompactList}\item 
\hypertarget{classmdt_abstract_port_a6bf2ecdcf894da3929a22eb8793a9fe3}{
void \hyperlink{classmdt_abstract_port_a6bf2ecdcf894da3929a22eb8793a9fe3}{lockMutex} ()}
\label{classmdt_abstract_port_a6bf2ecdcf894da3929a22eb8793a9fe3}

\begin{DoxyCompactList}\small\item\em Lock the mutex. \end{DoxyCompactList}\item 
\hypertarget{classmdt_abstract_port_a3523c72a06e4d950338f91e56c286e84}{
void \hyperlink{classmdt_abstract_port_a3523c72a06e4d950338f91e56c286e84}{unlockMutex} ()}
\label{classmdt_abstract_port_a3523c72a06e4d950338f91e56c286e84}

\begin{DoxyCompactList}\small\item\em Unlock the mutex. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_abstract_port_ac1440ea9759cbbee9efc5ea22afcdb0a}{pvOpen} ()=0
\begin{DoxyCompactList}\small\item\em Open the port given by \hyperlink{classmdt_abstract_port_a0ca143d32fc677bac7c1cf0e04144932}{setPortName()} \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_abstract_port_add29e91ccc4be62ab5c0dcb2a68ae8f0}{pvClose} ()=0
\begin{DoxyCompactList}\small\item\em Close port. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_abstract_port_a880e5ae1699af102f9a80501bb6a0021}{pvSetup} ()=0
\begin{DoxyCompactList}\small\item\em Setup port with given configurations. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_abstract_port_a1fe88e9d56c0881b9566664b094b0958}{pvFlushIn} ()=0
\begin{DoxyCompactList}\small\item\em Flush read port. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_abstract_port_a1667fa938d3a7578b73f54c32015c369}{pvFlushOut} ()=0
\begin{DoxyCompactList}\small\item\em Flush write port. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_abstract_port_a412c3e4903bf7d90914cfeb273e82623}{
QQueue$<$ \hyperlink{classmdt_frame}{mdtFrame} $\ast$ $>$ {\bfseries pvReadenFrames}}
\label{classmdt_abstract_port_a412c3e4903bf7d90914cfeb273e82623}

\item 
\hypertarget{classmdt_abstract_port_a3d6bb9b420f64776d8fd077cf2b9b873}{
QQueue$<$ \hyperlink{classmdt_frame}{mdtFrame} $\ast$ $>$ {\bfseries pvReadFramesPool}}
\label{classmdt_abstract_port_a3d6bb9b420f64776d8fd077cf2b9b873}

\item 
\hypertarget{classmdt_abstract_port_a12cd5c1ba100b018539ed909a481d6dc}{
QQueue$<$ \hyperlink{classmdt_frame}{mdtFrame} $\ast$ $>$ {\bfseries pvWriteFrames}}
\label{classmdt_abstract_port_a12cd5c1ba100b018539ed909a481d6dc}

\item 
\hypertarget{classmdt_abstract_port_a67a8b1965f20a55ad115926aed0234b4}{
QQueue$<$ \hyperlink{classmdt_frame}{mdtFrame} $\ast$ $>$ {\bfseries pvWriteFramesPool}}
\label{classmdt_abstract_port_a67a8b1965f20a55ad115926aed0234b4}

\item 
\hypertarget{classmdt_abstract_port_a035d72bddbac47f405a8ecf0d2eeba66}{
\hyperlink{classmdt_port_config}{mdtPortConfig} $\ast$ {\bfseries pvConfig}}
\label{classmdt_abstract_port_a035d72bddbac47f405a8ecf0d2eeba66}

\item 
\hypertarget{classmdt_abstract_port_afb8f8a723ff2db5141f18750020a7ee9}{
QString {\bfseries pvPortName}}
\label{classmdt_abstract_port_afb8f8a723ff2db5141f18750020a7ee9}

\item 
\hypertarget{classmdt_abstract_port_a357bce65bc031fffa87090a26ab88a08}{
QMutex {\bfseries pvMutex}}
\label{classmdt_abstract_port_a357bce65bc031fffa87090a26ab88a08}

\item 
\hypertarget{classmdt_abstract_port_a4c81c98680c98ad6802dccd30380459d}{
QWaitCondition {\bfseries pvWriteFrameAvailable}}
\label{classmdt_abstract_port_a4c81c98680c98ad6802dccd30380459d}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Base class for port I/O. 

\begin{Desc}
\item[\hyperlink{todo__todo000029}{Todo}]WaitingCanceled, WriteCanceled, ReadCanceled are not clean defined. The only object that knows when it must stop is the thread itself ! To be a little more clean, thread should check it's running flag each time a function returns a error, and stop if requierd ! \end{Desc}


Definition at line 42 of file mdtAbstractPort.h.



\subsection{Member Enumeration Documentation}
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{
\index{mdtAbstractPort@{mdtAbstractPort}!error\_\-t@{error\_\-t}}
\index{error\_\-t@{error\_\-t}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{error\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf mdtAbstractPort::error\_\-t}}}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}


Error. 

Each system's I/O API can return several error. Goal is here to map them to common error codes.

Note for thread implementation:\par
 Some errors must be handled in specific ways depending on port (serial, USB, TCP, ...). Each time a error occurs, thread should check the pvRunning flag, and stop if it is false (typical: after a stop request from main thread, \hyperlink{classmdt_abstract_port}{mdtAbstractPort} subclass will return ReadCanceled, WriteCanceled or ControlCanceled. But it can happen that I/O process was canceled for another reason, this is port specific). \begin{Desc}
\item[Enumerator: ]\par
\begin{description}
\index{NoError@{NoError}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!NoError@{NoError}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eab898bd273effe5cb4ed1a399a2d4baad}{
NoError}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eab898bd273effe5cb4ed1a399a2d4baad}
}]No error \index{PortLocked@{PortLocked}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!PortLocked@{PortLocked}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eaedd63daf0db75794bb8e8e467da9575c}{
PortLocked}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eaedd63daf0db75794bb8e8e467da9575c}
}]Port is allready locked \index{PortNotFound@{PortNotFound}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!PortNotFound@{PortNotFound}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea54a896ba3ff98896390e87bfe1f29eb0}{
PortNotFound}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea54a896ba3ff98896390e87bfe1f29eb0}
}]Port was not found \index{PortAccess@{PortAccess}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!PortAccess@{PortAccess}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eaee5a84e59e9dc5fcf27cac57068bb1f4}{
PortAccess}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eaee5a84e59e9dc5fcf27cac57068bb1f4}
}]Port cannot be open with requierd access (read, write) \index{SetupError@{SetupError}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!SetupError@{SetupError}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea3d692317af7125319f60204df3101307}{
SetupError}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea3d692317af7125319f60204df3101307}
}]Setup failed on a configuration option \index{WriteCanceled@{WriteCanceled}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!WriteCanceled@{WriteCanceled}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eae50ff4a9393507ad39005ddc7d5be42f}{
WriteCanceled}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eae50ff4a9393507ad39005ddc7d5be42f}
}]Write process was cancelled. The thread should stop the write process, restore the current frame into pool, notify the error and continue working. \index{ReadCanceled@{ReadCanceled}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!ReadCanceled@{ReadCanceled}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eac910ca649b9eaa64e290be41945a61dc}{
ReadCanceled}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eac910ca649b9eaa64e290be41945a61dc}
}]Read process was cancelled. The thread should stop the read process, clear the current , notify the error and continue working. \index{ControlCanceled@{ControlCanceled}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!ControlCanceled@{ControlCanceled}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea44eaa84d8f888f4f9d5c814291e54079}{
ControlCanceled}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea44eaa84d8f888f4f9d5c814291e54079}
}]Control process canceled (serial port's modem line, USB control transfer) \index{ReadTimeout@{ReadTimeout}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!ReadTimeout@{ReadTimeout}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea487558758ab0d582d6cf497a785e40c5}{
ReadTimeout}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea487558758ab0d582d6cf497a785e40c5}
}]Read process has timed out. Thread should clear current frame, notify this and continue working. If thread uses the read timeout protocol, no notification should be sent \index{WriteTimeout@{WriteTimeout}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!WriteTimeout@{WriteTimeout}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eac3a5cee51d4fb0b3bfb7c49604059c6a}{
WriteTimeout}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eac3a5cee51d4fb0b3bfb7c49604059c6a}
}]Write process has timed out. Thread should notify this and continue working. If thread uses the write timeout protocol, no notification should be sent \index{MessageInTimeout@{MessageInTimeout}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!MessageInTimeout@{MessageInTimeout}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea9611d47cf51e23aff74a6d2f41ceae2e}{
MessageInTimeout}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea9611d47cf51e23aff74a6d2f41ceae2e}
}]Used by USB/USBTMC for additionnal interrupt IN \index{MessageInCanceled@{MessageInCanceled}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!MessageInCanceled@{MessageInCanceled}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea421ccee58528bbdba8a3b32da3ceca97}{
MessageInCanceled}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea421ccee58528bbdba8a3b32da3ceca97}
}]Used by USB/USBTMC for additionnal interrupt IN \index{ControlTimeout@{ControlTimeout}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!ControlTimeout@{ControlTimeout}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eabdb5a36cd2c7dd2dcf59e996fc4922c9}{
ControlTimeout}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eabdb5a36cd2c7dd2dcf59e996fc4922c9}
}]Control process timed out (serial port's modem line, USB control transfer) \index{Disconnected@{Disconnected}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!Disconnected@{Disconnected}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea8b70726d03f75a691ac4ad65722a5f3c}{
Disconnected}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea8b70726d03f75a691ac4ad65722a5f3c}
}]For USB port: the device is disconnected. For TCP socket: peer has closed the connection. If this error happens, the thread will try to reconnect. If connection fails after maximum trys, a notification is sent with ConnectionFailed error. \index{Connecting@{Connecting}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!Connecting@{Connecting}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea0edfb7a2f0daf9501874543ecaae8e93}{
Connecting}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea0edfb7a2f0daf9501874543ecaae8e93}
}]Used to notify portmanager that connection is in progress (see \hyperlink{classmdt_port_thread_abee1d2f9b67ca37cfd13e108ca978b36}{mdtPortThread::reconnect()} ) \index{ConnectionFailed@{ConnectionFailed}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!ConnectionFailed@{ConnectionFailed}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea79cfce29fadf5a27dbcbc6e0cbc8d118}{
ConnectionFailed}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea79cfce29fadf5a27dbcbc6e0cbc8d118}
}]Can happen during first connection, or afetr max retry of reconnection. Port manager will stop on this error \index{UnhandledError@{UnhandledError}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!UnhandledError@{UnhandledError}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea6e24e272af4da51c84eef5825c5cd712}{
UnhandledError}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea6e24e272af4da51c84eef5825c5cd712}
}]Unhandled error happen. In this case, thread will stop working and error is reported with \hyperlink{classmdt_error}{mdtError} system. Logfile could give more information, see \hyperlink{classmdt_error}{mdtError} and \hyperlink{classmdt_application}{mdtApplication} \index{ReadPoolEmpty@{ReadPoolEmpty}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!ReadPoolEmpty@{ReadPoolEmpty}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea5059c1f30381b95b14a0b33445d2a984}{
ReadPoolEmpty}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea5059c1f30381b95b14a0b33445d2a984}
}]Read frames pool is empty. Says that no data can be received for the moment \index{WritePoolEmpty@{WritePoolEmpty}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!WritePoolEmpty@{WritePoolEmpty}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea823db75227ad56b6aa74ea2f160c0693}{
WritePoolEmpty}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea823db75227ad56b6aa74ea2f160c0693}
}]Write queue is empty. Says that no data can be sent for the moment \index{ErrorHandled@{ErrorHandled}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!ErrorHandled@{ErrorHandled}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eab0a372501b8916e3953897dc82fd3b3d}{
ErrorHandled}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eab0a372501b8916e3953897dc82fd3b3d}
}]Used by mdtPortThread's helper methods (handle\mbox{[}Read$|$Write\mbox{]}Error) to tell the thread that error could be handled \index{ReadWriteBusy@{ReadWriteBusy}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!ReadWriteBusy@{ReadWriteBusy}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea2d198672405289a1a7e662492ff073f8}{
ReadWriteBusy}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea2d198672405289a1a7e662492ff073f8}
}]It's currently not possible to read from or write to port/device. This is typically used by USBTMC when some control (f.ex. abort bilk IN/OUT) is in progress \index{UsbWriteStall@{UsbWriteStall}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!UsbWriteStall@{UsbWriteStall}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eaf89af56394b281f71247cd2eb4eaac62}{
UsbWriteStall}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eaf89af56394b281f71247cd2eb4eaac62}
}]USB specific: occurs for bulk or interrupt endpoint when a halt condition was detected \index{UsbReadStall@{UsbReadStall}!mdtAbstractPort@{mdtAbstractPort}}\index{mdtAbstractPort@{mdtAbstractPort}!UsbReadStall@{UsbReadStall}}\item[{\em 
\hypertarget{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea7b3edb569231d6ebd0c933974df60160}{
UsbReadStall}
\label{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea7b3edb569231d6ebd0c933974df60160}
}]USB specific: occurs for bulk or interrupt endpoint when a halt condition was detected \end{description}
\end{Desc}



Definition at line 60 of file mdtAbstractPort.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_abstract_port_aa40baa0c593fef984f3796acafceee15}{
\index{mdtAbstractPort@{mdtAbstractPort}!$\sim$mdtAbstractPort@{$\sim$mdtAbstractPort}}
\index{$\sim$mdtAbstractPort@{$\sim$mdtAbstractPort}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{$\sim$mdtAbstractPort}]{\setlength{\rightskip}{0pt plus 5cm}mdtAbstractPort::$\sim$mdtAbstractPort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_abstract_port_aa40baa0c593fef984f3796acafceee15}


Destructor. 

Subclass notes:\par
 This destructor cannot call the \hyperlink{classmdt_abstract_port_a1ace1a2bd1a04f16952980e247b04800}{close()} method, because this will call the \hyperlink{classmdt_abstract_port_add29e91ccc4be62ab5c0dcb2a68ae8f0}{pvClose()} from destructed inherited object. So, the subclass must call \hyperlink{classmdt_abstract_port_a1ace1a2bd1a04f16952980e247b04800}{close()} in its own destructor. 

Definition at line 33 of file mdtAbstractPort.cpp.



\subsection{Member Function Documentation}
\hypertarget{classmdt_abstract_port_ae67c815f68317c70e398eaa86622af6b}{
\index{mdtAbstractPort@{mdtAbstractPort}!abortFrameToWriteWait@{abortFrameToWriteWait}}
\index{abortFrameToWriteWait@{abortFrameToWriteWait}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{abortFrameToWriteWait}]{\setlength{\rightskip}{0pt plus 5cm}void mdtAbstractPort::abortFrameToWriteWait (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_ae67c815f68317c70e398eaa86622af6b}


Abort the frame tp write waiting. 

Will wake thread(s) waiting on a frame to write with \hyperlink{classmdt_abstract_port_a6c5ebd4451aec959efc4e71ab1b13941}{getFrameToWrite()} . This method is called from \hyperlink{classmdt_port_thread_a5746ea96689ed80179751ad1353f0b39}{mdtPortThread::stop()} , and should not be called directly.

Mutex is not handled by this method. 

Definition at line 329 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_a9a69eb2fc07d551ab37c011487fa319d}{
\index{mdtAbstractPort@{mdtAbstractPort}!addFrameToWrite@{addFrameToWrite}}
\index{addFrameToWrite@{addFrameToWrite}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{addFrameToWrite}]{\setlength{\rightskip}{0pt plus 5cm}void mdtAbstractPort::addFrameToWrite (
\begin{DoxyParamCaption}
\item[{{\bf mdtFrame} $\ast$}]{frame}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_abstract_port_a9a69eb2fc07d551ab37c011487fa319d}


Add a frame to write. 

Once the frame is added to the write queue, waiting thread will be woken up (if waiting) and will send the frame.

The mutex must be locked before calling this method, and still locked inside.

\begin{DoxyPrecond}{Precondition}
frame must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_tcp_socket_ade57b2659836d004a1c5618f9e482b4a}{mdtTcpSocket}, and \hyperlink{classmdt_usb_port_a38200f806037e06988e73af246e8a494}{mdtUsbPort}.



Definition at line 298 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_a1ace1a2bd1a04f16952980e247b04800}{
\index{mdtAbstractPort@{mdtAbstractPort}!close@{close}}
\index{close@{close}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{close}]{\setlength{\rightskip}{0pt plus 5cm}void mdtAbstractPort::close (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_abstract_port_a1ace1a2bd1a04f16952980e247b04800}


Close the port. 

Flush and close port if it is open.

Internal queues are freed here. (If subclass handles additionnaly queues, it should delete is in his \hyperlink{classmdt_abstract_port_add29e91ccc4be62ab5c0dcb2a68ae8f0}{pvClose()} method).

The mutex is not handled by this method.

Subclass notes:\par
 Internally, this method calls \hyperlink{classmdt_abstract_port_add29e91ccc4be62ab5c0dcb2a68ae8f0}{pvClose()}. Once done, the flags are updated. Note that this method must be called from subclass destructor. See \hyperlink{classmdt_abstract_port_aa40baa0c593fef984f3796acafceee15}{$\sim$mdtAbstractPort()} for details. 

Reimplemented in \hyperlink{classmdt_abstract_serial_port_ae668910f98ad0e158dc6ebebf0c19805}{mdtAbstractSerialPort}.



Definition at line 70 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_a3d105c90696f7c40f29c24fe9b6e4481}{
\index{mdtAbstractPort@{mdtAbstractPort}!config@{config}}
\index{config@{config}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{config}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortConfig} \& mdtAbstractPort::config (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_a3d105c90696f7c40f29c24fe9b6e4481}


Get the stored configuration. 

\begin{DoxyPrecond}{Precondition}
Configuration must be set with \hyperlink{classmdt_abstract_port_a48bdc0a8057c3b119763643098cf798f}{setConfig()} before using this method. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_abstract_serial_port_ae053b73fee897769641813df658c9ead}{mdtAbstractSerialPort}.



Definition at line 103 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_abde440c49b95833f821e1333c40a7398}{
\index{mdtAbstractPort@{mdtAbstractPort}!flush@{flush}}
\index{flush@{flush}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{flush}]{\setlength{\rightskip}{0pt plus 5cm}void mdtAbstractPort::flush (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_abde440c49b95833f821e1333c40a7398}


Flush read/write buffers. 

Will do the same as calling \hyperlink{classmdt_abstract_port_a32329b4188db796401e4f454755acb44}{flushIn()} and \hyperlink{classmdt_abstract_port_ad199c6310801893f1f7de2a2391606fc}{flushOut()}, but lock the mutex only once.

Mutex is locked in this method. 

Definition at line 201 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_a32329b4188db796401e4f454755acb44}{
\index{mdtAbstractPort@{mdtAbstractPort}!flushIn@{flushIn}}
\index{flushIn@{flushIn}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{flushIn}]{\setlength{\rightskip}{0pt plus 5cm}void mdtAbstractPort::flushIn (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_a32329b4188db796401e4f454755acb44}


Flush read buffers. 

Will move all readen frames to pool, and call \hyperlink{classmdt_abstract_port_a1fe88e9d56c0881b9566664b094b0958}{pvFlushIn()} to flush system's buffers.

After this call, \hyperlink{classmdt_abstract_port_a54b7bfb725c91b2c292a39275b877207}{flushInRequestPending()} will return true.

Mutex is locked in this method. 

Definition at line 161 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_a54b7bfb725c91b2c292a39275b877207}{
\index{mdtAbstractPort@{mdtAbstractPort}!flushInRequestPending@{flushInRequestPending}}
\index{flushInRequestPending@{flushInRequestPending}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{flushInRequestPending}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtAbstractPort::flushInRequestPending (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_a54b7bfb725c91b2c292a39275b877207}


Check if a flush in request is pending. 

Returns true after \hyperlink{classmdt_abstract_port_a32329b4188db796401e4f454755acb44}{flushIn()} was called.

This method is used by thread, and should not be used directly. If a request is pending, thread will put his current read frame back to pool.

A call of this method will clear the internall flag. (a second call will then return false).

Mutex is not handled by this method.

\begin{Desc}
\item[\hyperlink{todo__todo000030}{Todo}]Thread are to adapt. \end{Desc}


Definition at line 172 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_ad199c6310801893f1f7de2a2391606fc}{
\index{mdtAbstractPort@{mdtAbstractPort}!flushOut@{flushOut}}
\index{flushOut@{flushOut}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{flushOut}]{\setlength{\rightskip}{0pt plus 5cm}void mdtAbstractPort::flushOut (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_ad199c6310801893f1f7de2a2391606fc}


Flush write buffers. 

Will cancel current write operation, and all queued frames are removed.

Internally, all write frames are moved to pool. \hyperlink{classmdt_abstract_port_a1667fa938d3a7578b73f54c32015c369}{pvFlushOut()} will be called to flush system's buffers and the next call of \hyperlink{classmdt_abstract_port_a35e4686f50e2c53c7e3618cf2c485d92}{waitEventWriteReady()} will return the WriteCanceled error.

Mutex is locked in this method. 

Definition at line 181 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_a2cc79d9288bebafaa183753dcf0807f3}{
\index{mdtAbstractPort@{mdtAbstractPort}!flushOutRequestPending@{flushOutRequestPending}}
\index{flushOutRequestPending@{flushOutRequestPending}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{flushOutRequestPending}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtAbstractPort::flushOutRequestPending (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_a2cc79d9288bebafaa183753dcf0807f3}


Check if a flush out request is pending. 

Returns true after \hyperlink{classmdt_abstract_port_ad199c6310801893f1f7de2a2391606fc}{flushOut()} was called.

This method is used by thread, and should not be used directly. If a request is pending, thread will put his current write frame back to pool.

A call of this method will clear the internall flag. (a second call will then return false).

Mutex is not handled by this method.

\begin{Desc}
\item[\hyperlink{todo__todo000031}{Todo}]Thread are to adapt. \end{Desc}


Definition at line 192 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_a6c5ebd4451aec959efc4e71ab1b13941}{
\index{mdtAbstractPort@{mdtAbstractPort}!getFrameToWrite@{getFrameToWrite}}
\index{getFrameToWrite@{getFrameToWrite}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{getFrameToWrite}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtFrame} $\ast$ mdtAbstractPort::getFrameToWrite (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_a6c5ebd4451aec959efc4e71ab1b13941}


Wait until a frame to write is available and get it. 

If a frame is available in write frames queue, it will be returned. Else, thit method will block calling thread until a frame is available in write frames queue, and return one.

This method is called from \hyperlink{classmdt_port_thread}{mdtPortThread} and should not be used directly.

The mutex must be locked before calling this method. Internally, it will be unlocked during wait, and locked again before returning.

\begin{DoxyReturn}{Returns}
A pointer to a frame, or Null (Null happens after stop request) 
\end{DoxyReturn}


Definition at line 306 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_adf06d095d6c3e6ce939a3998bcf8b829}{
\index{mdtAbstractPort@{mdtAbstractPort}!initQueues@{initQueues}}
\index{initQueues@{initQueues}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{initQueues}]{\setlength{\rightskip}{0pt plus 5cm}void mdtAbstractPort::initQueues (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_adf06d095d6c3e6ce939a3998bcf8b829}


Init the read ans write queues. 

\begin{DoxyPrecond}{Precondition}
A valid configuration must be set before using this method. 
\end{DoxyPrecond}


Definition at line 217 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_a4e0f0b7f9e24257677184e4bde10fdde}{
\index{mdtAbstractPort@{mdtAbstractPort}!open@{open}}
\index{open@{open}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{open}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtAbstractPort::open (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_a4e0f0b7f9e24257677184e4bde10fdde}


Open the port given by \hyperlink{classmdt_abstract_port_a0ca143d32fc677bac7c1cf0e04144932}{setPortName()} 

If port can be open successfull, NoError code is returned. If port is open, it will be closed first (by calling \hyperlink{classmdt_abstract_port_a1ace1a2bd1a04f16952980e247b04800}{close()}).

The mutex is not handled by this method.

Subclass notes:\par
 Internally, this method calls \hyperlink{classmdt_abstract_port_ac1440ea9759cbbee9efc5ea22afcdb0a}{pvOpen()}. Once done, the flags are updated.

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} 
\end{DoxySeeAlso}


Definition at line 53 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_add29e91ccc4be62ab5c0dcb2a68ae8f0}{
\index{mdtAbstractPort@{mdtAbstractPort}!pvClose@{pvClose}}
\index{pvClose@{pvClose}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{pvClose}]{\setlength{\rightskip}{0pt plus 5cm}virtual void mdtAbstractPort::pvClose (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classmdt_abstract_port_add29e91ccc4be62ab5c0dcb2a68ae8f0}


Close port. 

The mutex is not handled by this method.

\begin{DoxyPrecond}{Precondition}
The port must be open whenn calling this method.
\end{DoxyPrecond}
Subclass notes:\par
 This method must be re-\/implemented in subclass.\par
 To handle the port correctly, the subclass method must:
\begin{DoxyItemize}
\item Do the specific work. Note that port was open in exclusive mode. On Linux, don't forget to unlock the port with \hyperlink{classmdt_port_lock}{mdtPortLock}.
\item The \hyperlink{classmdt_error}{mdtError} system should be used (on error) to keep trace in logfile.
\item If additionnal queues are handled, they should be freed here. 
\end{DoxyItemize}\hypertarget{classmdt_abstract_port_a1fe88e9d56c0881b9566664b094b0958}{
\index{mdtAbstractPort@{mdtAbstractPort}!pvFlushIn@{pvFlushIn}}
\index{pvFlushIn@{pvFlushIn}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{pvFlushIn}]{\setlength{\rightskip}{0pt plus 5cm}virtual void mdtAbstractPort::pvFlushIn (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classmdt_abstract_port_a1fe88e9d56c0881b9566664b094b0958}


Flush read port. 

This method is called from \hyperlink{classmdt_abstract_port_a32329b4188db796401e4f454755acb44}{flushIn()}, and is usefull if subsystem needs to be flushed. (For ex. serial port).

This method must be implemented in subclass.

The mutex is handled by \hyperlink{classmdt_abstract_port_a32329b4188db796401e4f454755acb44}{flushIn()} and should not be handled here. \hypertarget{classmdt_abstract_port_a1667fa938d3a7578b73f54c32015c369}{
\index{mdtAbstractPort@{mdtAbstractPort}!pvFlushOut@{pvFlushOut}}
\index{pvFlushOut@{pvFlushOut}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{pvFlushOut}]{\setlength{\rightskip}{0pt plus 5cm}virtual void mdtAbstractPort::pvFlushOut (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classmdt_abstract_port_a1667fa938d3a7578b73f54c32015c369}


Flush write port. 

This method is called from \hyperlink{classmdt_abstract_port_ad199c6310801893f1f7de2a2391606fc}{flushOut()}, and is usefull if subsystem needs to be flushed. (For ex. serial port).

The mutex is handled by \hyperlink{classmdt_abstract_port_ad199c6310801893f1f7de2a2391606fc}{flushOut()} and should not be handled here. \hypertarget{classmdt_abstract_port_ac1440ea9759cbbee9efc5ea22afcdb0a}{
\index{mdtAbstractPort@{mdtAbstractPort}!pvOpen@{pvOpen}}
\index{pvOpen@{pvOpen}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{pvOpen}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf error\_\-t} mdtAbstractPort::pvOpen (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classmdt_abstract_port_ac1440ea9759cbbee9efc5ea22afcdb0a}


Open the port given by \hyperlink{classmdt_abstract_port_a0ca143d32fc677bac7c1cf0e04144932}{setPortName()} 

If port can be open successfull, NoError code is returned.

The mutex is not handled by this method.

\begin{DoxyPrecond}{Precondition}
The port must not be open whenn calling this method.
\end{DoxyPrecond}
Subclass notes:\par
 This method must be re-\/implemented in subclass.\par
 To handle the port correctly, the subclass method must:
\begin{DoxyItemize}
\item Do the specific work. Note that port must be open in exclusive mode. On Linux, the \hyperlink{classmdt_port_lock}{mdtPortLock} should be used for this.
\item The \hyperlink{classmdt_error}{mdtError} system should be used (on error) to keep trace in logfile.
\item If port must be closed (f.ex. on error), use the \hyperlink{classmdt_abstract_port_a1ace1a2bd1a04f16952980e247b04800}{close()} method to keep flags coherent. Note that \hyperlink{classmdt_abstract_port_add29e91ccc4be62ab5c0dcb2a68ae8f0}{pvClose()} will not be called if this method returns something else than NoError. If some cleanup (witch are normally done in \hyperlink{classmdt_abstract_port_add29e91ccc4be62ab5c0dcb2a68ae8f0}{pvClose()} ) must be done, do it before return.
\item Return the correct error code on failure (see the error\_\-t enum)
\end{DoxyItemize}

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_abstract_port_a1ace1a2bd1a04f16952980e247b04800}{close()} 

\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} 
\end{DoxySeeAlso}
\hypertarget{classmdt_abstract_port_a880e5ae1699af102f9a80501bb6a0021}{
\index{mdtAbstractPort@{mdtAbstractPort}!pvSetup@{pvSetup}}
\index{pvSetup@{pvSetup}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{pvSetup}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf error\_\-t} mdtAbstractPort::pvSetup (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, pure virtual\mbox{]}}}}
\label{classmdt_abstract_port_a880e5ae1699af102f9a80501bb6a0021}


Setup port with given configurations. 

The mutex is not handled by this method.

\begin{DoxyPrecond}{Precondition}
The port must be open whenn calling this method. 

A valid configuration must be set before calling this method.
\end{DoxyPrecond}
Subclass notes:\par
 This method must be re-\/implemented in subclass.\par
 To handle the port correctly, the subclass method must:
\begin{DoxyItemize}
\item Do the specific work
\item Set read/write timeouts using \hyperlink{classmdt_abstract_port_a6589b04467e0073d18ba872201bdcd84}{setReadTimeout()} and \hyperlink{classmdt_abstract_port_a12eb422d52ebb09a650f8497b258c2e7}{setWriteTimeout()}. See \hyperlink{classmdt_port_config}{mdtPortConfig} to know how to get these timeouts.
\item Return the correct error code on failure (see the error\_\-t enum)
\end{DoxyItemize}

Configuration is available using \hyperlink{classmdt_abstract_port_a3d105c90696f7c40f29c24fe9b6e4481}{config()}.

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} 
\end{DoxySeeAlso}
\hypertarget{classmdt_abstract_port_a9d9c45220d5328c9856a2445557fe970}{
\index{mdtAbstractPort@{mdtAbstractPort}!read@{read}}
\index{read@{read}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}virtual qint64 mdtAbstractPort::read (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{data, }
\item[{qint64}]{maxSize}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classmdt_abstract_port_a9d9c45220d5328c9856a2445557fe970}


Read data from port. 

This method is called from \hyperlink{classmdt_port_read_thread}{mdtPortReadThread} , and should not be used directly.

Mutex is not handled by this method.

Subclass notes:\par
 This method must be implemented in subclass.\par


\begin{DoxyReturn}{Returns}
Number of bytes readen, or a error $<$ 0 (see error\_\-t ) 
\end{DoxyReturn}


Implemented in \hyperlink{classmdt_port_ad8a196bb21b6ca76dffb068a1692904a}{mdtPort}, \hyperlink{classmdt_tcp_socket_a78842bc5ddcac2d96fb368ee575214cd}{mdtTcpSocket}, \hyperlink{classmdt_usb_port_abce257345c8af47494215cd7ee75f82d}{mdtUsbPort}, and \hyperlink{classmdt_serial_port_a12274d7956b2af961ccdd36cfc2052cc}{mdtSerialPort}.

\hypertarget{classmdt_abstract_port_a05356a33dc546a11d2794a0419d749e0}{
\index{mdtAbstractPort@{mdtAbstractPort}!readenFrames@{readenFrames}}
\index{readenFrames@{readenFrames}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{readenFrames}]{\setlength{\rightskip}{0pt plus 5cm}QQueue$<$ {\bf mdtFrame} $\ast$ $>$ \& mdtAbstractPort::readenFrames (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_a05356a33dc546a11d2794a0419d749e0}


Get the readen frames Queue. 

Readen frames queue contains frames that where received from device

Mutex is not handled by this method. 

Definition at line 288 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_a3850ab819a8fc5dad22af14b74c45274}{
\index{mdtAbstractPort@{mdtAbstractPort}!readFramesPool@{readFramesPool}}
\index{readFramesPool@{readFramesPool}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{readFramesPool}]{\setlength{\rightskip}{0pt plus 5cm}QQueue$<$ {\bf mdtFrame} $\ast$ $>$ \& mdtAbstractPort::readFramesPool (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_a3850ab819a8fc5dad22af14b74c45274}


Get the read frames Queue pool. 

Read frames queue pool contains frames that are ready to use for reception

Mutex is not handled by this method. 

Definition at line 293 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_aec74b2db1a629d98a95d8f042ea96653}{
\index{mdtAbstractPort@{mdtAbstractPort}!reconnect@{reconnect}}
\index{reconnect@{reconnect}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{reconnect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtAbstractPort::reconnect (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_abstract_port_aec74b2db1a629d98a95d8f042ea96653}


Reconnect device/peer. 

If one of the method returns a Disconnected error, the thread will call this method to try to reconnect.


\begin{DoxyParams}{Parameters}
{\em timeout} & Timeout \mbox{[}ms\mbox{]} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
NoError if connection could be done. Disconnected if connection could not be done, in wich case the thread will retry (until max retry). A UnhandledError can be returned.
\end{DoxyReturn}
If subclass supports device (de$|$re)-\/connection, this method must be implemented.

Default implementation returns a UnhandledError.

Notes about mutex handling:
\begin{DoxyItemize}
\item The mutex is locked when method is called, and must be locked when returns 
\end{DoxyItemize}

Reimplemented in \hyperlink{classmdt_usb_port_af2399348faf1abc20130eab20cfc36ee}{mdtUsbPort}.



Definition at line 133 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_ad4a04c995df881593db0a309000be7a7}{
\index{mdtAbstractPort@{mdtAbstractPort}!resumeTransmission@{resumeTransmission}}
\index{resumeTransmission@{resumeTransmission}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{resumeTransmission}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtAbstractPort::resumeTransmission (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_abstract_port_ad4a04c995df881593db0a309000be7a7}


Request to resume transmission. 

This method is called from \hyperlink{classmdt_port_read_thread}{mdtPortReadThread} , and should not be used directly.\par
 Mutex is not handled by this method.

Subclass notes:\par
 This method must be implemented in subclass if requierd.\par
 Note about serial port subclass:\par
 the right flow control must be used regarding enabled flow control.\par
 Default implementation does nothing.\par


\begin{DoxyReturn}{Returns}
False on error, in this case, the reader thread will be stopped. 
\end{DoxyReturn}


Reimplemented in \hyperlink{classmdt_serial_port_a02fd5ee74a7f52c3bce0545ec8a659bf}{mdtSerialPort}.



Definition at line 156 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_a0ca143d32fc677bac7c1cf0e04144932}{
\index{mdtAbstractPort@{mdtAbstractPort}!setPortName@{setPortName}}
\index{setPortName@{setPortName}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{setPortName}]{\setlength{\rightskip}{0pt plus 5cm}void mdtAbstractPort::setPortName (
\begin{DoxyParamCaption}
\item[{const QString \&}]{portName}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_a0ca143d32fc677bac7c1cf0e04144932}


Set the port name. 

Port name can be, f.ex. /dev/ttyS0 on Linux, or COM1 on Windows. This method just store given port name and does nothing else. 

Definition at line 38 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_a6589b04467e0073d18ba872201bdcd84}{
\index{mdtAbstractPort@{mdtAbstractPort}!setReadTimeout@{setReadTimeout}}
\index{setReadTimeout@{setReadTimeout}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{setReadTimeout}]{\setlength{\rightskip}{0pt plus 5cm}virtual void mdtAbstractPort::setReadTimeout (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classmdt_abstract_port_a6589b04467e0073d18ba872201bdcd84}


Set the read data timeout. 

The mutex is not handled by this method.

Subclass notes:\par
 This method must be re-\/implemented in subclass. The subclass can convert and store the value in system specific type (f.ex: timeval struct on Posix)


\begin{DoxyParams}{Parameters}
{\em timeout} & Timeout \mbox{[}ms\mbox{]}. A value of -\/1 means a infinite timeout. \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classmdt_port_aa77b266f23744f1b53ae589f986be101}{mdtPort}, \hyperlink{classmdt_tcp_socket_aae23057f2e0ee326d0fee78ffe3f00f9}{mdtTcpSocket}, \hyperlink{classmdt_usb_port_a44ed5024a81a573b5196b8f64c42cd6a}{mdtUsbPort}, and \hyperlink{classmdt_serial_port_a9105e5a3a640b56097c1156000ace933}{mdtSerialPort}.

\hypertarget{classmdt_abstract_port_abc9f1154ac71c4e31ac3e7a3ff4c5182}{
\index{mdtAbstractPort@{mdtAbstractPort}!setup@{setup}}
\index{setup@{setup}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{setup}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtAbstractPort::setup (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_abc9f1154ac71c4e31ac3e7a3ff4c5182}


Setup port with given configurations. 

If port is not open, \hyperlink{classmdt_abstract_port_a4e0f0b7f9e24257677184e4bde10fdde}{open()} will be called first. Then, \hyperlink{classmdt_abstract_port_a880e5ae1699af102f9a80501bb6a0021}{pvSetup()} is called, and finally queues initialized with \hyperlink{classmdt_abstract_port_adf06d095d6c3e6ce939a3998bcf8b829}{initQueues()}. If somethig fails, the port is closed again, and error code returned.

The mutex is not handled by this method.

\begin{DoxyPrecond}{Precondition}
A valid configuration must be set before calling this method.
\end{DoxyPrecond}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} 
\end{DoxySeeAlso}


Definition at line 110 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_a12eb422d52ebb09a650f8497b258c2e7}{
\index{mdtAbstractPort@{mdtAbstractPort}!setWriteTimeout@{setWriteTimeout}}
\index{setWriteTimeout@{setWriteTimeout}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{setWriteTimeout}]{\setlength{\rightskip}{0pt plus 5cm}virtual void mdtAbstractPort::setWriteTimeout (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classmdt_abstract_port_a12eb422d52ebb09a650f8497b258c2e7}


Set the write data timeout. 

The mutex is not handled by this method.

Subclass notes:\par
 This method must be re-\/implemented in subclass. The subclass can convert and store the value in system specific type (f.ex: timeval struct on Posix)


\begin{DoxyParams}{Parameters}
{\em timeout} & Timeout \mbox{[}ms\mbox{]}. A value of -\/1 means a infinite timeout. \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classmdt_port_a2acb6e7bedacdadf78ee735dc611abfa}{mdtPort}, \hyperlink{classmdt_tcp_socket_ac59d2dfdf405b5382f0f20d5b9f75fd0}{mdtTcpSocket}, \hyperlink{classmdt_usb_port_a592af88bd7e7f45dd80df0ecab375ace}{mdtUsbPort}, and \hyperlink{classmdt_serial_port_a036f49d743838013c9a8cbf6a1dd40d1}{mdtSerialPort}.

\hypertarget{classmdt_abstract_port_aff3d79248baf96e670eba6d2fef700b9}{
\index{mdtAbstractPort@{mdtAbstractPort}!suspendTransmission@{suspendTransmission}}
\index{suspendTransmission@{suspendTransmission}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{suspendTransmission}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtAbstractPort::suspendTransmission (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_abstract_port_aff3d79248baf96e670eba6d2fef700b9}


Request to suspend transmission. 

This method is called from \hyperlink{classmdt_port_read_thread}{mdtPortReadThread} , and should not be used directly.\par
 Mutex is not handled by this method.

Subclass notes:\par
 This method must be implemented in subclass if requierd.\par
 Note about serial port subclass:\par
 the right flow control must be used regarding enabled flow control.\par
 Default implementation does nothing.\par


\begin{DoxyReturn}{Returns}
False on error, in this case, the reader thread will be stopped. 
\end{DoxyReturn}


Reimplemented in \hyperlink{classmdt_serial_port_a9412faf413eca5ee3516139fdfaaf2fe}{mdtSerialPort}.



Definition at line 151 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_a35e4686f50e2c53c7e3618cf2c485d92}{
\index{mdtAbstractPort@{mdtAbstractPort}!waitEventWriteReady@{waitEventWriteReady}}
\index{waitEventWriteReady@{waitEventWriteReady}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{waitEventWriteReady}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf error\_\-t} mdtAbstractPort::waitEventWriteReady (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classmdt_abstract_port_a35e4686f50e2c53c7e3618cf2c485d92}


Wait until data can be written to port. 

This method is called from \hyperlink{classmdt_port_write_thread}{mdtPortWriteThread} , and should not be used directly.\par
 Mutex must be locked before calling this method with \hyperlink{classmdt_abstract_port_a6bf2ecdcf894da3929a22eb8793a9fe3}{lockMutex()}. The mutex is locked when method returns.

Subclass notes:\par
 This method must be re-\/implemented in subclass. The write timeout state must be updated with updateWriteTimeoutState() Notes about mutex handling:
\begin{DoxyItemize}
\item Mutex must be released during wait, and relocked befor return.
\end{DoxyItemize}

\begin{DoxyReturn}{Returns}
On success, NoError is returned. If waiting is canceled, WaitingCanceled is returned and the thread knows that it must end (case of stopping thread). If \hyperlink{classmdt_abstract_port_ad199c6310801893f1f7de2a2391606fc}{flushOut()} was called, WriteCanceled is returned. If a port lost connection (f.ex. USB port or TCP socket), Disconnected is returned. On unhandled error, UnhandledError is returned. The thread also stop working, and emit a error signal (that can be handled in \hyperlink{classmdt_port_manager}{mdtPortManager}, or in another place in application). 
\end{DoxyReturn}


Implemented in \hyperlink{classmdt_port_a85e77a391f6f5782428beb2e6aee52f8}{mdtPort}, \hyperlink{classmdt_tcp_socket_a33385bcde41b8065ea7eff65c754b0cb}{mdtTcpSocket}, \hyperlink{classmdt_usb_port_a3be875f6f10ae94fd3a94f925bb935e7}{mdtUsbPort}, and \hyperlink{classmdt_serial_port_a988825b3ff2ef93a1b43e2df316055bd}{mdtSerialPort}.

\hypertarget{classmdt_abstract_port_aeda364cb191da1038a22dd1fc06a1d49}{
\index{mdtAbstractPort@{mdtAbstractPort}!waitForReadyRead@{waitForReadyRead}}
\index{waitForReadyRead@{waitForReadyRead}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{waitForReadyRead}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf error\_\-t} mdtAbstractPort::waitForReadyRead (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classmdt_abstract_port_aeda364cb191da1038a22dd1fc06a1d49}


Wait until data is available on port. 

This method is called from reader thread , and should not be used directly.

Mutex must be locked before calling this method with \hyperlink{classmdt_abstract_port_a6bf2ecdcf894da3929a22eb8793a9fe3}{lockMutex()}. The mutex is locked when method returns.

Subclass notes:\par
 This method must be re-\/implemented in subclass. The read timeout state must be updated with updateReadTimeoutState()\par
 Notes about mutex handling:
\begin{DoxyItemize}
\item Mutex must be released during wait, and relocked befor return.
\end{DoxyItemize}

\begin{DoxyReturn}{Returns}
On success, NoError is returned. If waiting is canceled, ReadCanceled is returned. If a port lost connection (f.ex. USB port or TCP socket), Disconnected is returned. On unhandled error, UnhandledError is returned. The thread also stop working, and emit a error signal (that can be handled in \hyperlink{classmdt_port_manager}{mdtPortManager}, or in another place in application).
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_thread}{mdtPortThread} 

\hyperlink{classmdt_port_config}{mdtPortConfig} 

\hyperlink{classmdt_tcp_socket_thread}{mdtTcpSocketThread} 

\hyperlink{classmdt_usb_port_thread}{mdtUsbPortThread} 
\end{DoxySeeAlso}


Implemented in \hyperlink{classmdt_port_a84594fdb56cd455a366c69b0a9228020}{mdtPort}, \hyperlink{classmdt_tcp_socket_adb09186cdacdac15291523c59f156cd4}{mdtTcpSocket}, \hyperlink{classmdt_usb_port_ab8ddd4ebee603ac381e8da0383a61e36}{mdtUsbPort}, and \hyperlink{classmdt_serial_port_ad150a45c68d98a501bea2f102aeadb50}{mdtSerialPort}.

\hypertarget{classmdt_abstract_port_a47f4db2e72b5fd3e32162e6a898fd391}{
\index{mdtAbstractPort@{mdtAbstractPort}!waitForReadyRead@{waitForReadyRead}}
\index{waitForReadyRead@{waitForReadyRead}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{waitForReadyRead}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtAbstractPort::waitForReadyRead (
\begin{DoxyParamCaption}
\item[{int}]{msecs}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_a47f4db2e72b5fd3e32162e6a898fd391}


Wait until data is available on port. 

This method calls \hyperlink{classmdt_abstract_port_a6589b04467e0073d18ba872201bdcd84}{setReadTimeout()} , \hyperlink{classmdt_abstract_port_aeda364cb191da1038a22dd1fc06a1d49}{waitForReadyRead()} and \hyperlink{classmdt_abstract_port_a6589b04467e0073d18ba872201bdcd84}{setReadTimeout()} again to restore original setting. (it is a little bit slower than setting timeout one time, and call \hyperlink{classmdt_abstract_port_aeda364cb191da1038a22dd1fc06a1d49}{waitForReadyRead()} ).\par
 Note that the reader thread will call \hyperlink{classmdt_abstract_port_aeda364cb191da1038a22dd1fc06a1d49}{waitForReadyRead()} without argument.\par
 Note: this method is called from thread , and should not be used directly\par
 Mutex: see \hyperlink{classmdt_abstract_port_aeda364cb191da1038a22dd1fc06a1d49}{waitForReadyRead()}


\begin{DoxyParams}{Parameters}
{\em timeout} & Timeout \mbox{[}ms\mbox{]}. A value of -\/1 means a infinite timeout. \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_abstract_port_aeda364cb191da1038a22dd1fc06a1d49}{waitForReadyRead()} 
\end{DoxySeeAlso}


Definition at line 138 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_a64d4802975a76474b9196c91f57a6d90}{
\index{mdtAbstractPort@{mdtAbstractPort}!write@{write}}
\index{write@{write}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}virtual qint64 mdtAbstractPort::write (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{data, }
\item[{qint64}]{maxSize}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classmdt_abstract_port_a64d4802975a76474b9196c91f57a6d90}


Write data to port. 

This method is called from \hyperlink{classmdt_port_write_thread}{mdtPortWriteThread} , and should not be used directly.

Mutex is not handled by this method.

Subclass notes:\par
 This method must be implemented in subclass.\par


\begin{DoxyReturn}{Returns}
Number of bytes written, or error $<$ 0 (see error\_\-t) 
\end{DoxyReturn}


Implemented in \hyperlink{classmdt_port_a62f4a6f2c547d40d3743ce893e0f64d6}{mdtPort}, \hyperlink{classmdt_tcp_socket_adbf2db44b291127a499d9f8720beb632}{mdtTcpSocket}, \hyperlink{classmdt_usb_port_ae777e33325ff2adef326dd7f81b00838}{mdtUsbPort}, and \hyperlink{classmdt_serial_port_a282f99035c032fbb6fa86ccd10deb597}{mdtSerialPort}.

\hypertarget{classmdt_abstract_port_a4fed10be147dfce6ca315467ff3fb968}{
\index{mdtAbstractPort@{mdtAbstractPort}!writeFrames@{writeFrames}}
\index{writeFrames@{writeFrames}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{writeFrames}]{\setlength{\rightskip}{0pt plus 5cm}QQueue$<$ {\bf mdtFrame} $\ast$ $>$ \& mdtAbstractPort::writeFrames (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_a4fed10be147dfce6ca315467ff3fb968}


Get the write frames Queue. 

Write frames queue contains frames that must be sent

Mutex is not handled by this method. 

Definition at line 334 of file mdtAbstractPort.cpp.

\hypertarget{classmdt_abstract_port_abf093b67fddebffa4f3c52277b9a8cf7}{
\index{mdtAbstractPort@{mdtAbstractPort}!writeFramesPool@{writeFramesPool}}
\index{writeFramesPool@{writeFramesPool}!mdtAbstractPort@{mdtAbstractPort}}
\subsubsection[{writeFramesPool}]{\setlength{\rightskip}{0pt plus 5cm}QQueue$<$ {\bf mdtFrame} $\ast$ $>$ \& mdtAbstractPort::writeFramesPool (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_abstract_port_abf093b67fddebffa4f3c52277b9a8cf7}


Get the write frames Queue pool. 

Write frames queue pool contains frames that are ready to use for transmission

Mutex is not handled by this method. 

Definition at line 339 of file mdtAbstractPort.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtAbstractPort.h\item 
src/mdtport/mdtAbstractPort.cpp\end{DoxyCompactItemize}
