<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="Generator" content="Kate, the KDE Advanced Text Editor" />
<title>mxusb-serial.c</title>
</head>
<body>
<pre style='color:#1f1c1b;background-color:#ffffff;'>
<i><span style='color:#898887;'>/*</span></i>
<i><span style='color:#898887;'> * USB Serial Converter driver</span></i>
<i><span style='color:#898887;'> *</span></i>
<i><span style='color:#898887;'> * Copyright (C) 1999 - 2005 Greg Kroah-Hartman (greg@kroah.com)</span></i>
<i><span style='color:#898887;'> * Copyright (C) 2000 Peter Berger (pberger@brimson.com)</span></i>
<i><span style='color:#898887;'> * Copyright (C) 2000 Al Borchers (borchers@steinerpoint.com)</span></i>
<i><span style='color:#898887;'> *</span></i>
<i><span style='color:#898887;'> *	This program is free software; you can redistribute it and/or</span></i>
<i><span style='color:#898887;'> *	modify it under the terms of the GNU General Public License version</span></i>
<i><span style='color:#898887;'> *	2 as published by the Free Software Foundation.</span></i>
<i><span style='color:#898887;'> *</span></i>
<i><span style='color:#898887;'> * This driver was originally based on the ACM driver by Armin Fuerst (which was</span></i>
<i><span style='color:#898887;'> * based on a driver by Brad Keryan)</span></i>
<i><span style='color:#898887;'> *</span></i>
<i><span style='color:#898887;'> * See Documentation/usb/usb-serial.txt for more information on using this driver</span></i>
<i><span style='color:#898887;'> *</span></i>
<i><span style='color:#898887;'> */</span></i>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;linux/kernel.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;linux/errno.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;linux/init.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;linux/slab.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;linux/tty.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;linux/tty_driver.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;linux/tty_flip.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;linux/module.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;linux/moduleparam.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;linux/spinlock.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;linux/list.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;asm/uaccess.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;linux/usb.h&gt;</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&quot;mxusb-serial.h&quot;</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,39))</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;linux/smp_lock.h&gt;</span>
<span style='color:#006e28;'>#endif</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,19))</span>
<span style='color:#006e28;'>#ifndef FC6</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;linux/config.h&gt;</span>
<span style='color:#006e28;'>#endif</span>
<span style='color:#006e28;'>#endif</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,15))</span>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,17))</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;asm/semaphore.h&gt;</span>
<span style='color:#006e28;'>#endif</span>
<span style='color:#006e28;'>#endif</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,16))</span>
<span style='color:#006e28;'>#include </span><span style='color:#006e28;'>&lt;linux/mutex.h&gt;</span>
<span style='color:#006e28;'>#endif</span>

<i><span style='color:#898887;'>/*</span></i>
<i><span style='color:#898887;'> * Version Information</span></i>
<i><span style='color:#898887;'> */</span></i>
<span style='color:#006e28;'>#define DRIVER_AUTHOR </span><span style='color:#006e28;'>&quot;Greg Kroah-Hartman, greg@kroah.com, http://www.kroah.com/linux/&quot;</span>
<span style='color:#006e28;'>#define DRIVER_DESC </span><span style='color:#006e28;'>&quot;USB Serial Driver core&quot;</span>


<i><span style='color:#898887;'>/* Driver structure we register with the USB core */</span></i>
<span style='color:#0057ae;'>static</span> <b>struct</b> usb_driver usb_serial_driver = {
	.name =		<span style='color:#bf0303;'>&quot;mxusbserial&quot;</span>,
	.probe =	mx_usbserial_probe,
	.disconnect =	mx_usbserial_disconnect,
<span style='color:#006e28;'>#if (defined(_SCREEN_INFO_H) || (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,15)))</span>
	.no_dynamic_id = 	<span style='color:#b08000;'>1</span>,
<span style='color:#006e28;'>#else</span>
	.owner =	THIS_MODULE,	
<span style='color:#006e28;'>#endif	</span>
};

<i><span style='color:#898887;'>/* There is no MODULE_DEVICE_TABLE for usbserial.c.  Instead</span></i>
<i><span style='color:#898887;'>   the MODULE_DEVICE_TABLE declarations in each serial driver</span></i>
<i><span style='color:#898887;'>   cause the &quot;hotplug&quot; program to pull in whatever module is necessary</span></i>
<i><span style='color:#898887;'>   via modprobe, and modprobe will load usbserial because the serial</span></i>
<i><span style='color:#898887;'>   drivers depend on it.</span></i>
<i><span style='color:#898887;'>*/</span></i>

<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> debug;
<span style='color:#0057ae;'>static</span> <b>struct</b> usb_serial *serial_table[SERIAL_TTY_MINORS];	<i><span style='color:#898887;'>/* initially all NULL */</span></i>
<span style='color:#0057ae;'>static</span> LIST_HEAD(usb_serial_driver_list);

<b>struct</b> usb_serial *mx_usbserial_get_by_index(<span style='color:#0057ae;'>unsigned</span> index)
{
	<b>struct</b> usb_serial *serial = serial_table[index];

	<b>if</b> (serial)
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,4))</span>
		kref_get(&amp;serial-&gt;kref);
<span style='color:#006e28;'>#else</span>
		kobject_get (&amp;serial-&gt;kobj);
<span style='color:#006e28;'>#endif</span>

	<b>return</b> serial;
}

<span style='color:#0057ae;'>static</span> <b>struct</b> usb_serial *get_free_serial (<b>struct</b> usb_serial *serial, <span style='color:#0057ae;'>int</span> num_ports, <span style='color:#0057ae;'>unsigned</span> <span style='color:#0057ae;'>int</span> *minor)
{
	<span style='color:#0057ae;'>unsigned</span> <span style='color:#0057ae;'>int</span> i, j;
	<span style='color:#0057ae;'>int</span> good_spot;

	dbg(<span style='color:#bf0303;'>&quot;%s %d&quot;</span>, __FUNCTION__, num_ports);

	*minor = <span style='color:#b08000;'>0</span>;
	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; SERIAL_TTY_MINORS; ++i) {
		<b>if</b> (serial_table[i])
			<b>continue</b>;

		good_spot = <span style='color:#b08000;'>1</span>;
		<b>for</b> (j = <span style='color:#b08000;'>1</span>; j &lt;= num_ports-<span style='color:#b08000;'>1</span>; ++j)
			<b>if</b> ((i+j &gt;= SERIAL_TTY_MINORS) || (serial_table[i+j])) {
				good_spot = <span style='color:#b08000;'>0</span>;
				i += j;
				<b>break</b>;
			}
		<b>if</b> (good_spot == <span style='color:#b08000;'>0</span>)
			<b>continue</b>;
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,7))			</span>
		serial-&gt;magic = USB_SERIAL_MAGIC;
<span style='color:#006e28;'>#endif		</span>
		*minor = i;
		dbg(<span style='color:#bf0303;'>&quot;%s - minor base = %d&quot;</span>, __FUNCTION__, *minor);
		<b>for</b> (i = *minor; (i &lt; (*minor + num_ports)) &amp;&amp; (i &lt; SERIAL_TTY_MINORS); ++i)
			serial_table[i] = serial;
		<b>return</b> serial;
	}
	<b>return</b> NULL;
}

<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>void</span> return_serial(<b>struct</b> usb_serial *serial)
{
	<span style='color:#0057ae;'>int</span> i;

	dbg(<span style='color:#bf0303;'>&quot;%s&quot;</span>, __FUNCTION__);

	<b>if</b> (serial == NULL)
		<b>return</b>;

	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; serial-&gt;num_ports; ++i) {
		serial_table[serial-&gt;minor + i] = NULL;
	}
}


<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,4))</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>void</span> destroy_serial(<b>struct</b> kref *kref)
<span style='color:#006e28;'>#else</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>void</span> destroy_serial (<b>struct</b> kobject *kobj)
<span style='color:#006e28;'>#endif</span>
{
	<b>struct</b> usb_serial *serial;
	<b>struct</b> usb_serial_port *port;
	<span style='color:#0057ae;'>int</span> i;

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,4))</span>
	serial = to_usb_serial(kref);
	
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) </span>
	dbg(<span style='color:#bf0303;'>&quot;%s - %s&quot;</span>, __FUNCTION__, serial-&gt;type-&gt;description);
<span style='color:#006e28;'>#else</span>
	dbg (<span style='color:#bf0303;'>&quot;%s - %s&quot;</span>, __FUNCTION__, serial-&gt;type-&gt;name);
<span style='color:#006e28;'>#endif</span>
<span style='color:#006e28;'>#else	</span>
	dbg (<span style='color:#bf0303;'>&quot;%s - %s&quot;</span>, __FUNCTION__, kobj-&gt;name);
	serial = to_usb_serial(kobj);
<span style='color:#006e28;'>#endif	</span>


	serial-&gt;type-&gt;shutdown(serial);

	<i><span style='color:#898887;'>/* return the minor range that this device had */</span></i>
	return_serial(serial);

	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; serial-&gt;num_ports; ++i)
		serial-&gt;port[i]-&gt;open_count = <span style='color:#b08000;'>0</span>;

	<i><span style='color:#898887;'>/* the ports are cleaned up and released in port_release() */</span></i>
	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; serial-&gt;num_ports; ++i)
		<b>if</b> (serial-&gt;port[i]-&gt;dev.parent != NULL) {
			device_unregister(&amp;serial-&gt;port[i]-&gt;dev);
			serial-&gt;port[i] = NULL;
		}

	<i><span style='color:#898887;'>/* If this is a &quot;fake&quot; port, we have to clean it up here, as it will</span></i>
<i><span style='color:#898887;'>	 * not get cleaned up in port_release() as it was never registered with</span></i>
<i><span style='color:#898887;'>	 * the driver core */</span></i>
	<b>if</b> (serial-&gt;num_ports &lt; serial-&gt;num_port_pointers) {
		<b>for</b> (i = serial-&gt;num_ports; i &lt; serial-&gt;num_port_pointers; ++i) {
			port = serial-&gt;port[i];
			<b>if</b> (!port)
				<b>continue</b>;
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))			</span>
			usb_kill_urb(port-&gt;read_urb);
			usb_free_urb(port-&gt;read_urb);
			usb_kill_urb(port-&gt;write_urb);
			usb_free_urb(port-&gt;write_urb);
			usb_kill_urb(port-&gt;interrupt_in_urb);
			usb_free_urb(port-&gt;interrupt_in_urb);
			usb_kill_urb(port-&gt;interrupt_out_urb);
			usb_free_urb(port-&gt;interrupt_out_urb);
			kfree(port-&gt;bulk_in_buffer);
			kfree(port-&gt;bulk_out_buffer);
			kfree(port-&gt;interrupt_in_buffer);
			kfree(port-&gt;interrupt_out_buffer);
<span style='color:#006e28;'>#else				</span>
			<b>if</b> (port-&gt;read_urb) {
				usb_unlink_urb(port-&gt;read_urb);
				usb_free_urb(port-&gt;read_urb);
			}
			<b>if</b> (port-&gt;write_urb) {
				usb_unlink_urb(port-&gt;write_urb);
				usb_free_urb(port-&gt;write_urb);
			}
			<b>if</b> (port-&gt;interrupt_in_urb) {
				usb_unlink_urb(port-&gt;interrupt_in_urb);
				usb_free_urb(port-&gt;interrupt_in_urb);
			}
			kfree(port-&gt;bulk_in_buffer);
			kfree(port-&gt;bulk_out_buffer);
			kfree(port-&gt;interrupt_in_buffer);
<span style='color:#006e28;'>#endif			</span>
		}
	}

	usb_put_dev(serial-&gt;dev);

	<i><span style='color:#898887;'>/* free up any memory that we allocated */</span></i>
	kfree (serial);
}


<i><span style='color:#898887;'>/*****************************************************************************</span></i>
<i><span style='color:#898887;'> * Driver tty interface functions</span></i>
<i><span style='color:#898887;'> *****************************************************************************/</span></i>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,16))</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> serial_open (<b>struct</b> tty_struct *tty, <b>struct</b> file * filp)
{
	<b>struct</b> usb_serial *serial;
	<b>struct</b> usb_serial_port *port;
	<span style='color:#0057ae;'>unsigned</span> <span style='color:#0057ae;'>int</span> portNumber;
	<span style='color:#0057ae;'>int</span> retval;
	
	dbg(<span style='color:#bf0303;'>&quot;%s&quot;</span>, __FUNCTION__);

	<i><span style='color:#898887;'>/* get the serial object associated with this tty pointer */</span></i>
	serial = mx_usbserial_get_by_index(tty-&gt;index);
	<b>if</b> (!serial) {
		tty-&gt;driver_data = NULL;
		<b>return</b> -ENODEV;
	}

	portNumber = tty-&gt;index - serial-&gt;minor;
	port = serial-&gt;port[portNumber];
	<b>if</b> (!port) {
		retval = -ENODEV;
		<b>goto</b> bailout_kref_put;
	}

	<b>if</b> (mutex_lock_interruptible(&amp;port-&gt;mutex)) {
		retval = -ERESTARTSYS;
		<b>goto</b> bailout_kref_put;
	}
	 
	++port-&gt;open_count;

	<b>if</b> (port-&gt;open_count == <span style='color:#b08000;'>1</span>) {

		<i><span style='color:#898887;'>/* set up our port structure making the tty driver</span></i>
<i><span style='color:#898887;'>		 * remember our port object, and us it */</span></i>
		tty-&gt;driver_data = port;
		port-&gt;tty = tty;

		<i><span style='color:#898887;'>/* lock this module before we call it</span></i>
<i><span style='color:#898887;'>		 * this may fail, which means we must bail out,</span></i>
<i><span style='color:#898887;'>		 * safe because we are called with BKL held */</span></i>
		<b>if</b> (!try_module_get(serial-&gt;type-&gt;driver.owner)) {
			retval = -ENODEV;
			<b>goto</b> bailout_mutex_unlock;
		}

		<i><span style='color:#898887;'>/* only call the device specific open if this </span></i>
<i><span style='color:#898887;'>		 * is the first time the port is opened */</span></i>
		retval = serial-&gt;type-&gt;open(port, filp);
		<b>if</b> (retval)
			<b>goto</b> bailout_module_put;
	}

	mutex_unlock(&amp;port-&gt;mutex);
	<b>return</b> <span style='color:#b08000;'>0</span>;

bailout_module_put:
	module_put(serial-&gt;type-&gt;driver.owner);
bailout_mutex_unlock:
	port-&gt;open_count = <span style='color:#b08000;'>0</span>;
	mutex_unlock(&amp;port-&gt;mutex);
bailout_kref_put:
	kref_put(&amp;serial-&gt;kref, destroy_serial);
	<b>return</b> retval;
}
<span style='color:#006e28;'>#else</span>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))			</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> serial_open (<b>struct</b> tty_struct *tty, <b>struct</b> file * filp)
{
	<b>struct</b> usb_serial *serial;
	<b>struct</b> usb_serial_port *port;
	<span style='color:#0057ae;'>unsigned</span> <span style='color:#0057ae;'>int</span> portNumber;
	<span style='color:#0057ae;'>int</span> retval;
	
	dbg(<span style='color:#bf0303;'>&quot;%s&quot;</span>, __FUNCTION__);

	<i><span style='color:#898887;'>/* get the serial object associated with this tty pointer */</span></i>
	serial = mx_usbserial_get_by_index(tty-&gt;index);
	<b>if</b> (!serial) {
		tty-&gt;driver_data = NULL;
		<b>return</b> -ENODEV;
	}

	portNumber = tty-&gt;index - serial-&gt;minor;
	port = serial-&gt;port[portNumber];
	<b>if</b> (!port)
		<b>return</b> -ENODEV;

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,15))</span>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,17))</span>
	<b>if</b> (down_interruptible(&amp;port-&gt;sem))
		<b>return</b> -ERESTARTSYS;
<span style='color:#006e28;'>#endif</span>
<span style='color:#006e28;'>#endif</span>
	 
	++port-&gt;open_count;

	<b>if</b> (port-&gt;open_count == <span style='color:#b08000;'>1</span>) {

		<i><span style='color:#898887;'>/* set up our port structure making the tty driver</span></i>
<i><span style='color:#898887;'>		 * remember our port object, and us it */</span></i>
		tty-&gt;driver_data = port;
		port-&gt;tty = tty;

		<i><span style='color:#898887;'>/* lock this module before we call it</span></i>
<i><span style='color:#898887;'>		 * this may fail, which means we must bail out,</span></i>
<i><span style='color:#898887;'>		 * safe because we are called with BKL held */</span></i>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) </span>
		<b>if</b> (!try_module_get(serial-&gt;type-&gt;driver.owner)) {
<span style='color:#006e28;'>#else</span>
		<b>if</b> (!try_module_get(serial-&gt;type-&gt;owner)) {
<span style='color:#006e28;'>#endif		    </span>
			retval = -ENODEV;
			<b>goto</b> bailout_kref_put;
		}

		<i><span style='color:#898887;'>/* only call the device specific open if this </span></i>
<i><span style='color:#898887;'>		 * is the first time the port is opened */</span></i>
		retval = serial-&gt;type-&gt;open(port, filp);
		<b>if</b> (retval)
			<b>goto</b> bailout_module_put;
	}

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,15))</span>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,17))</span>
	up(&amp;port-&gt;sem);
<span style='color:#006e28;'>#endif</span>
<span style='color:#006e28;'>#endif</span>
	
	<b>return</b> <span style='color:#b08000;'>0</span>;

bailout_module_put:
	module_put(serial-&gt;type-&gt;driver.owner);
bailout_kref_put:
	kref_put(&amp;serial-&gt;kref, destroy_serial);
	port-&gt;open_count = <span style='color:#b08000;'>0</span>;
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,15))</span>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,17))</span>
	up(&amp;port-&gt;sem);
<span style='color:#006e28;'>#endif</span>
<span style='color:#006e28;'>#endif	</span>
	<b>return</b> retval;
}
<span style='color:#006e28;'>#else</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> serial_open (<b>struct</b> tty_struct *tty, <b>struct</b> file * filp)
{
	<b>struct</b> usb_serial *serial;
	<b>struct</b> usb_serial_port *port;
	<span style='color:#0057ae;'>unsigned</span> <span style='color:#0057ae;'>int</span> portNumber;
	<span style='color:#0057ae;'>int</span> retval = <span style='color:#b08000;'>0</span>;
	
	dbg(<span style='color:#bf0303;'>&quot;%s&quot;</span>, __FUNCTION__);

	<i><span style='color:#898887;'>/* initialize the pointer incase something fails */</span></i>
	tty-&gt;driver_data = NULL;

	<i><span style='color:#898887;'>/* get the serial object associated with this tty pointer */</span></i>
	serial = mx_usbserial_get_by_index(tty-&gt;index);
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,6))</span>
	<b>if</b> (!serial) {
		retval = -ENODEV;
		<b>goto</b> bailout;
	}
<span style='color:#006e28;'>#else</span>
	<b>if</b> (serial_paranoia_check (serial, __FUNCTION__))
		<b>return</b> -ENODEV;
<span style='color:#006e28;'>#endif</span>

	<i><span style='color:#898887;'>/* set up our port structure making the tty driver remember our port object, and us it */</span></i>
	portNumber = tty-&gt;index - serial-&gt;minor;
	port = serial-&gt;port[portNumber];
	tty-&gt;driver_data = port;

	port-&gt;tty = tty;
	 
	<i><span style='color:#898887;'>/* lock this module before we call it,</span></i>
<i><span style='color:#898887;'>	   this may, which means we must bail out, safe because we are called with BKL held */</span></i>
	<b>if</b> (!try_module_get(serial-&gt;type-&gt;owner)) {
		retval = -ENODEV;
		<b>goto</b> bailout;
	}

	++port-&gt;open_count;
	<b>if</b> (port-&gt;open_count == <span style='color:#b08000;'>1</span>) {
		<i><span style='color:#898887;'>/* only call the device specific open if this </span></i>
<i><span style='color:#898887;'>		 * is the first time the port is opened */</span></i>
		retval = serial-&gt;type-&gt;open(port, filp);
		<b>if</b> (retval) {
			port-&gt;open_count = <span style='color:#b08000;'>0</span>;
			module_put(serial-&gt;type-&gt;owner);

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,4))</span>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,8)) 			</span>
			kref_put(&amp;serial-&gt;kref, destroy_serial);
<span style='color:#006e28;'>#else</span>
			kref_put(&amp;serial-&gt;kref);			
<span style='color:#006e28;'>#endif</span>
<span style='color:#006e28;'>#else</span>
		    kobject_put (&amp;serial-&gt;kobj);
<span style='color:#006e28;'>#endif</span>

		}
	}
bailout:
	<b>return</b> retval;
}
<span style='color:#006e28;'>#endif</span>
<span style='color:#006e28;'>#endif</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,10))</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>void</span> serial_close(<b>struct</b> tty_struct *tty, <b>struct</b> file * filp)
{
	<b>struct</b> usb_serial_port *port = tty-&gt;driver_data;

	<b>if</b> (!port)
		<b>return</b>;

	dbg(<span style='color:#bf0303;'>&quot;%s - port %d&quot;</span>, __FUNCTION__, port-&gt;number);

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,15))</span>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,17))</span>
	down(&amp;port-&gt;sem);

	<b>if</b> (port-&gt;open_count == <span style='color:#b08000;'>0</span>) {
		up(&amp;port-&gt;sem);
		<b>return</b>;
	}
<span style='color:#006e28;'>#endif</span>
<span style='color:#006e28;'>#endif</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,16))</span>
	mutex_lock(&amp;port-&gt;mutex);

	<b>if</b> (port-&gt;open_count == <span style='color:#b08000;'>0</span>) {
		mutex_unlock(&amp;port-&gt;mutex);
		<b>return</b>;
	}
<span style='color:#006e28;'>#endif</span>

	--port-&gt;open_count;
	<b>if</b> (port-&gt;open_count == <span style='color:#b08000;'>0</span>) {
		<i><span style='color:#898887;'>/* only call the device specific close if this </span></i>
<i><span style='color:#898887;'>		 * port is being closed by the last owner */</span></i>
		port-&gt;serial-&gt;type-&gt;close(port, filp);

		<b>if</b> (port-&gt;tty) {
			<b>if</b> (port-&gt;tty-&gt;driver_data)
				port-&gt;tty-&gt;driver_data = NULL;
			port-&gt;tty = NULL;
		}

		module_put(port-&gt;serial-&gt;type-&gt;driver.owner);
	}

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,15))</span>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,17))</span>
	up(&amp;port-&gt;sem);
<span style='color:#006e28;'>#endif</span>
<span style='color:#006e28;'>#endif</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,16))</span>
	mutex_unlock(&amp;port-&gt;mutex);
<span style='color:#006e28;'>#endif</span>

	kref_put(&amp;port-&gt;serial-&gt;kref, destroy_serial);
}
<span style='color:#006e28;'>#else</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>void</span> serial_close(<b>struct</b> tty_struct *tty, <b>struct</b> file * filp)
{
	<b>struct</b> usb_serial_port *port = (<b>struct</b> usb_serial_port *) tty-&gt;driver_data;

	<b>if</b> (!port)
		<b>return</b>;

	dbg(<span style='color:#bf0303;'>&quot;%s - port %d&quot;</span>, __FUNCTION__, port-&gt;number);

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))</span>
	<b>if</b> (port-&gt;open_count == <span style='color:#b08000;'>0</span>)
		<b>return</b>;

	--port-&gt;open_count;
	<b>if</b> (port-&gt;open_count == <span style='color:#b08000;'>0</span>) {
		<i><span style='color:#898887;'>/* only call the device specific close if this </span></i>
<i><span style='color:#898887;'>		 * port is being closed by the last owner */</span></i>
		port-&gt;serial-&gt;type-&gt;close(port, filp);
<span style='color:#006e28;'>#else</span>
	--port-&gt;open_count;
	<b>if</b> (port-&gt;open_count &lt;= <span style='color:#b08000;'>0</span>) {
		<i><span style='color:#898887;'>/* only call the device specific close if this </span></i>
<i><span style='color:#898887;'>		 * port is being closed by the last owner */</span></i>
		port-&gt;serial-&gt;type-&gt;close(port, filp);
		port-&gt;open_count = <span style='color:#b08000;'>0</span>;
<span style='color:#006e28;'>#endif</span>
		<b>if</b> (port-&gt;tty) {
			<b>if</b> (port-&gt;tty-&gt;driver_data)
				port-&gt;tty-&gt;driver_data = NULL;
			port-&gt;tty = NULL;
		}

		module_put(port-&gt;serial-&gt;type-&gt;owner);
	}
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,4))</span>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,8)) 			</span>
			kref_put(&amp;port-&gt;serial-&gt;kref, destroy_serial);
<span style='color:#006e28;'>#else</span>
			kref_put(&amp;port-&gt;serial-&gt;kref);			
<span style='color:#006e28;'>#endif</span>
<span style='color:#006e28;'>#else</span>
		    kobject_put (&amp;port-&gt;serial-&gt;kobj);
<span style='color:#006e28;'>#endif</span>

}
<span style='color:#006e28;'>#endif</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> serial_write (<b>struct</b> tty_struct * tty, <span style='color:#0057ae;'>const</span> <span style='color:#0057ae;'>unsigned</span> <span style='color:#0057ae;'>char</span> *buf, <span style='color:#0057ae;'>int</span> count)
<span style='color:#006e28;'>#else</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> serial_write (<b>struct</b> tty_struct * tty, <span style='color:#0057ae;'>int</span> from_user, <span style='color:#0057ae;'>const</span> <span style='color:#0057ae;'>unsigned</span> <span style='color:#0057ae;'>char</span> *buf, <span style='color:#0057ae;'>int</span> count)
<span style='color:#006e28;'>#endif</span>
{
	<b>struct</b> usb_serial_port *port = tty-&gt;driver_data;
	<span style='color:#0057ae;'>int</span> retval = -EINVAL;

	<b>if</b> (!port)
		<b>goto</b> exit;

	dbg(<span style='color:#bf0303;'>&quot;%s - port %d, %d byte(s)&quot;</span>, __FUNCTION__, port-&gt;number, count);

	<b>if</b> (!port-&gt;open_count) {
		dbg(<span style='color:#bf0303;'>&quot;%s - port not opened&quot;</span>, __FUNCTION__);
		<b>goto</b> exit;
	}

	<i><span style='color:#898887;'>/* pass on to the driver specific version of this function */</span></i>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))</span>
	retval = port-&gt;serial-&gt;type-&gt;write(port, buf, count);
<span style='color:#006e28;'>#else	</span>
	retval = port-&gt;serial-&gt;type-&gt;write(port, from_user, buf, count);
<span style='color:#006e28;'>#endif</span>
exit:
	<b>return</b> retval;
}

<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> serial_write_room (<b>struct</b> tty_struct *tty) 
{
	<b>struct</b> usb_serial_port *port = tty-&gt;driver_data;
	<span style='color:#0057ae;'>int</span> retval = -EINVAL;

	<b>if</b> (!port)
		<b>goto</b> exit;

	dbg(<span style='color:#bf0303;'>&quot;%s - port %d&quot;</span>, __FUNCTION__, port-&gt;number);

	<b>if</b> (!port-&gt;open_count) {
		dbg(<span style='color:#bf0303;'>&quot;%s - port not open&quot;</span>, __FUNCTION__);
		<b>goto</b> exit;
	}

	<i><span style='color:#898887;'>/* pass on to the driver specific version of this function */</span></i>
	retval = port-&gt;serial-&gt;type-&gt;write_room(port);

exit:
	<b>return</b> retval;
}

<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> serial_chars_in_buffer (<b>struct</b> tty_struct *tty) 
{
	<b>struct</b> usb_serial_port *port = tty-&gt;driver_data;
	<span style='color:#0057ae;'>int</span> retval = -EINVAL;

	<b>if</b> (!port)
		<b>goto</b> exit;

	dbg(<span style='color:#bf0303;'>&quot;%s = port %d&quot;</span>, __FUNCTION__, port-&gt;number);

	<b>if</b> (!port-&gt;open_count) {
		dbg(<span style='color:#bf0303;'>&quot;%s - port not open&quot;</span>, __FUNCTION__);
		<b>goto</b> exit;
	}

	<i><span style='color:#898887;'>/* pass on to the driver specific version of this function */</span></i>
	retval = port-&gt;serial-&gt;type-&gt;chars_in_buffer(port);

exit:
	<b>return</b> retval;
}

<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>void</span> serial_throttle (<b>struct</b> tty_struct * tty)
{
	<b>struct</b> usb_serial_port *port = tty-&gt;driver_data;

	<b>if</b> (!port)
		<b>return</b>;

	dbg(<span style='color:#bf0303;'>&quot;%s - port %d&quot;</span>, __FUNCTION__, port-&gt;number);

	<b>if</b> (!port-&gt;open_count) {
		dbg (<span style='color:#bf0303;'>&quot;%s - port not open&quot;</span>, __FUNCTION__);
		<b>return</b>;
	}

	<i><span style='color:#898887;'>/* pass on to the driver specific version of this function */</span></i>
	<b>if</b> (port-&gt;serial-&gt;type-&gt;throttle)
		port-&gt;serial-&gt;type-&gt;throttle(port);
}

<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>void</span> serial_unthrottle (<b>struct</b> tty_struct * tty)
{
	<b>struct</b> usb_serial_port *port = tty-&gt;driver_data;

	<b>if</b> (!port)
		<b>return</b>;

	dbg(<span style='color:#bf0303;'>&quot;%s - port %d&quot;</span>, __FUNCTION__, port-&gt;number);

	<b>if</b> (!port-&gt;open_count) {
		dbg(<span style='color:#bf0303;'>&quot;%s - port not open&quot;</span>, __FUNCTION__);
		<b>return</b>;
	}

	<i><span style='color:#898887;'>/* pass on to the driver specific version of this function */</span></i>
	<b>if</b> (port-&gt;serial-&gt;type-&gt;unthrottle)
		port-&gt;serial-&gt;type-&gt;unthrottle(port);
}

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,39))</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> serial_ioctl (<b>struct</b> tty_struct *tty, <b>struct</b> file * file, <span style='color:#0057ae;'>unsigned</span> <span style='color:#0057ae;'>int</span> cmd, <span style='color:#0057ae;'>unsigned</span> <span style='color:#0057ae;'>long</span> arg)
<span style='color:#006e28;'>#else</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> serial_ioctl (<b>struct</b> tty_struct *tty, <span style='color:#0057ae;'>unsigned</span> <span style='color:#0057ae;'>int</span> cmd, <span style='color:#0057ae;'>unsigned</span> <span style='color:#0057ae;'>long</span> arg)
<span style='color:#006e28;'>#endif</span>
{
	<b>struct</b> usb_serial_port *port = tty-&gt;driver_data;
	<span style='color:#0057ae;'>int</span> retval = -ENODEV;

	<b>if</b> (!port)
		<b>goto</b> exit;

	dbg(<span style='color:#bf0303;'>&quot;%s - port %d, cmd 0x%.4x&quot;</span>, __FUNCTION__, port-&gt;number, cmd);

	<b>if</b> (!port-&gt;open_count) {
		dbg (<span style='color:#bf0303;'>&quot;%s - port not open&quot;</span>, __FUNCTION__);
		<b>goto</b> exit;
	}

	<i><span style='color:#898887;'>/* pass on to the driver specific version of this function if it is available */</span></i>
	<b>if</b> (port-&gt;serial-&gt;type-&gt;ioctl)
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,39))</span>
		retval = port-&gt;serial-&gt;type-&gt;ioctl(port, file, cmd, arg);
<span style='color:#006e28;'>#else</span>
		retval = port-&gt;serial-&gt;type-&gt;ioctl(port, cmd, arg);
<span style='color:#006e28;'>#endif</span>
	<b>else</b>
		retval = -ENOIOCTLCMD;

exit:
	<b>return</b> retval;
}


<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,19))</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>void</span> serial_set_termios (<b>struct</b> tty_struct *tty, <b>struct</b> ktermios * old)
<span style='color:#006e28;'>#else</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>void</span> serial_set_termios (<b>struct</b> tty_struct *tty, <b>struct</b> termios * old)
<span style='color:#006e28;'>#endif</span>
{
	<b>struct</b> usb_serial_port *port = tty-&gt;driver_data;

	<b>if</b> (!port)
		<b>return</b>;

	dbg(<span style='color:#bf0303;'>&quot;%s - port %d&quot;</span>, __FUNCTION__, port-&gt;number);

	<b>if</b> (!port-&gt;open_count) {
		dbg(<span style='color:#bf0303;'>&quot;%s - port not open&quot;</span>, __FUNCTION__);
		<b>return</b>;
	}

	<i><span style='color:#898887;'>/* pass on to the driver specific version of this function if it is available */</span></i>
	<b>if</b> (port-&gt;serial-&gt;type-&gt;set_termios)
		port-&gt;serial-&gt;type-&gt;set_termios(port, old);
}


<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,28))</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>void</span> serial_break (<b>struct</b> tty_struct *tty, <span style='color:#0057ae;'>int</span> break_state)
{
	<b>struct</b> usb_serial_port *port = tty-&gt;driver_data;

	<b>if</b> (!port)
		<b>return</b> ;

	dbg(<span style='color:#bf0303;'>&quot;%s - port %d&quot;</span>, __FUNCTION__, port-&gt;number);

	<b>if</b> (!port-&gt;open_count) {
		dbg(<span style='color:#bf0303;'>&quot;%s - port not open&quot;</span>, __FUNCTION__);
		<b>return</b> ;
	}

	<i><span style='color:#898887;'>/* pass on to the driver specific version of this function if it is available */</span></i>
	<b>if</b> (port-&gt;serial-&gt;type-&gt;break_ctl)
		port-&gt;serial-&gt;type-&gt;break_ctl(port, break_state);
}

<span style='color:#006e28;'>#else</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> serial_break (<b>struct</b> tty_struct *tty, <span style='color:#0057ae;'>int</span> break_state)
{
	<b>struct</b> usb_serial_port *port = tty-&gt;driver_data;

	<b>if</b> (!port)
		<b>return</b> <span style='color:#b08000;'>0</span>;

	dbg(<span style='color:#bf0303;'>&quot;%s - port %d&quot;</span>, __FUNCTION__, port-&gt;number);

	<b>if</b> (!port-&gt;open_count) {
		dbg(<span style='color:#bf0303;'>&quot;%s - port not open&quot;</span>, __FUNCTION__);
		<b>return</b> <span style='color:#b08000;'>0</span>;
	}

	<i><span style='color:#898887;'>/* pass on to the driver specific version of this function if it is available */</span></i>
	<b>if</b> (port-&gt;serial-&gt;type-&gt;break_ctl)
		port-&gt;serial-&gt;type-&gt;break_ctl(port, break_state);
	
	<b>return</b> <span style='color:#b08000;'>0</span>;
}
<span style='color:#006e28;'>#endif</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,30))</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> serial_read_proc (<span style='color:#0057ae;'>char</span> *page, <span style='color:#0057ae;'>char</span> **start, off_t off, <span style='color:#0057ae;'>int</span> count, <span style='color:#0057ae;'>int</span> *eof, <span style='color:#0057ae;'>void</span> *data)
{
	<b>struct</b> usb_serial *serial;
	<span style='color:#0057ae;'>int</span> length = <span style='color:#b08000;'>0</span>;
	<span style='color:#0057ae;'>int</span> i;
	off_t begin = <span style='color:#b08000;'>0</span>;
	<span style='color:#0057ae;'>char</span> tmp[<span style='color:#b08000;'>40</span>];

	dbg(<span style='color:#bf0303;'>&quot;%s&quot;</span>, __FUNCTION__);
	length += sprintf (page, <span style='color:#bf0303;'>&quot;usbserinfo:1.0 driver:2.0</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; SERIAL_TTY_MINORS &amp;&amp; length &lt; PAGE_SIZE; ++i) {
		serial = mx_usbserial_get_by_index(i);
		<b>if</b> (serial == NULL)
			<b>continue</b>;

		length += sprintf (page+length, <span style='color:#bf0303;'>&quot;%d:&quot;</span>, i);
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) </span>
		<b>if</b> (serial-&gt;type-&gt;driver.owner)
			length += sprintf (page+length, <span style='color:#bf0303;'>&quot; module:%s&quot;</span>, module_name(serial-&gt;type-&gt;driver.owner));
		length += sprintf (page+length, <span style='color:#bf0303;'>&quot; name:</span><span style='color:#ff80e0;'>\&quot;</span><span style='color:#bf0303;'>%s</span><span style='color:#ff80e0;'>\&quot;</span><span style='color:#bf0303;'>&quot;</span>, serial-&gt;type-&gt;description);
<span style='color:#006e28;'>#else</span>
		<b>if</b> (serial-&gt;type-&gt;owner)
			length += sprintf (page+length, <span style='color:#bf0303;'>&quot; module:%s&quot;</span>, module_name(serial-&gt;type-&gt;owner));
		length += sprintf (page+length, <span style='color:#bf0303;'>&quot; name:</span><span style='color:#ff80e0;'>\&quot;</span><span style='color:#bf0303;'>%s</span><span style='color:#ff80e0;'>\&quot;</span><span style='color:#bf0303;'>&quot;</span>, serial-&gt;type-&gt;name);		    		    
<span style='color:#006e28;'>#endif		    </span>
		length += sprintf (page+length, <span style='color:#bf0303;'>&quot; vendor:%04x product:%04x&quot;</span>, 
				   le16_to_cpu(serial-&gt;dev-&gt;descriptor.idVendor), 
				   le16_to_cpu(serial-&gt;dev-&gt;descriptor.idProduct));
		length += sprintf (page+length, <span style='color:#bf0303;'>&quot; num_ports:%d&quot;</span>, serial-&gt;num_ports);
		length += sprintf (page+length, <span style='color:#bf0303;'>&quot; port:%d&quot;</span>, i - serial-&gt;minor + <span style='color:#b08000;'>1</span>);

		usb_make_path(serial-&gt;dev, tmp, <b>sizeof</b>(tmp));
		length += sprintf (page+length, <span style='color:#bf0303;'>&quot; path:%s&quot;</span>, tmp);
			
		length += sprintf (page+length, <span style='color:#bf0303;'>&quot;</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
		<b>if</b> ((length + begin) &gt; (off + count))
			<b>goto</b> done;
		<b>if</b> ((length + begin) &lt; off) {
			begin += length;
			length = <span style='color:#b08000;'>0</span>;
		}

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,4))</span>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,8)) 			</span>
			kref_put(&amp;serial-&gt;kref, destroy_serial);
<span style='color:#006e28;'>#else</span>
			kref_put(&amp;serial-&gt;kref);			
<span style='color:#006e28;'>#endif</span>
<span style='color:#006e28;'>#else</span>
		    kobject_put (&amp;serial-&gt;kobj);
<span style='color:#006e28;'>#endif</span>

    }
	*eof = <span style='color:#b08000;'>1</span>;
done:
	<b>if</b> (off &gt;= (length + begin))
		<b>return</b> <span style='color:#b08000;'>0</span>;
	*start = page + (off-begin);
	<b>return</b> ((count &lt; begin+length-off) ? count : begin+length-off);
}
<span style='color:#006e28;'>#endif</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,39))</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> serial_tiocmget (<b>struct</b> tty_struct *tty, <b>struct</b> file *file)
<span style='color:#006e28;'>#else</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> serial_tiocmget (<b>struct</b> tty_struct *tty)
<span style='color:#006e28;'>#endif</span>
{
	<b>struct</b> usb_serial_port *port = tty-&gt;driver_data;

	<b>if</b> (!port)
		<b>goto</b> exit;

	dbg(<span style='color:#bf0303;'>&quot;%s - port %d&quot;</span>, __FUNCTION__, port-&gt;number);

	<b>if</b> (!port-&gt;open_count) {
		dbg(<span style='color:#bf0303;'>&quot;%s - port not open&quot;</span>, __FUNCTION__);
		<b>goto</b> exit;
	}

	<b>if</b> (port-&gt;serial-&gt;type-&gt;tiocmget)
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,39))</span>
		<b>return</b> port-&gt;serial-&gt;type-&gt;tiocmget(port, file);
<span style='color:#006e28;'>#else</span>
		<b>return</b> port-&gt;serial-&gt;type-&gt;tiocmget(port);
<span style='color:#006e28;'>#endif</span>
exit:
	<b>return</b> -EINVAL;
}

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,39))</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> serial_tiocmset (<b>struct</b> tty_struct *tty, <b>struct</b> file *file,
			    <span style='color:#0057ae;'>unsigned</span> <span style='color:#0057ae;'>int</span> set, <span style='color:#0057ae;'>unsigned</span> <span style='color:#0057ae;'>int</span> clear)
<span style='color:#006e28;'>#else</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>int</span> serial_tiocmset (<b>struct</b> tty_struct *tty,
			    <span style='color:#0057ae;'>unsigned</span> <span style='color:#0057ae;'>int</span> set, <span style='color:#0057ae;'>unsigned</span> <span style='color:#0057ae;'>int</span> clear)
<span style='color:#006e28;'>#endif</span>
{
	<b>struct</b> usb_serial_port *port = tty-&gt;driver_data;

	<b>if</b> (!port)
		<b>goto</b> exit;

	dbg(<span style='color:#bf0303;'>&quot;%s - port %d&quot;</span>, __FUNCTION__, port-&gt;number);

	<b>if</b> (!port-&gt;open_count) {
		dbg(<span style='color:#bf0303;'>&quot;%s - port not open&quot;</span>, __FUNCTION__);
		<b>goto</b> exit;
	}

	<b>if</b> (port-&gt;serial-&gt;type-&gt;tiocmset)
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,39))</span>
		<b>return</b> port-&gt;serial-&gt;type-&gt;tiocmset(port, file, set, clear);
<span style='color:#006e28;'>#else</span>
		<b>return</b> port-&gt;serial-&gt;type-&gt;tiocmset(port, set, clear);
<span style='color:#006e28;'>#endif</span>
exit:
	<b>return</b> -EINVAL;
}

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,19))</span>
<span style='color:#0057ae;'>void</span> mx_usbserial_port_softint(<b>struct</b> work_struct *work)
{
	<b>struct</b> usb_serial_port *port = 
               container_of(work, <b>struct</b> usb_serial_port, work);
<span style='color:#006e28;'>#else</span>
<span style='color:#0057ae;'>void</span> mx_usbserial_port_softint(<span style='color:#0057ae;'>void</span> *private)
{
	<b>struct</b> usb_serial_port *port = private;
<span style='color:#006e28;'>#endif</span>
	<b>struct</b> tty_struct *tty;

	dbg(<span style='color:#bf0303;'>&quot;%s - port %d&quot;</span>, __FUNCTION__, port-&gt;number);
	
	<b>if</b> (!port)
		<b>return</b>;

	tty = port-&gt;tty;
	<b>if</b> (!tty)
		<b>return</b>;
		
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,8))</span>
	tty_wakeup(tty);
<span style='color:#006e28;'>#else</span>
	<b>if</b> ((tty-&gt;flags &amp; (<span style='color:#b08000;'>1</span> &lt;&lt; TTY_DO_WRITE_WAKEUP)) &amp;&amp; tty-&gt;ldisc.write_wakeup) {
		dbg(<span style='color:#bf0303;'>&quot;%s - write wakeup call.&quot;</span>, __FUNCTION__);
		(tty-&gt;ldisc.write_wakeup)(tty);
	}

	wake_up_interruptible(&amp;tty-&gt;write_wait);
<span style='color:#006e28;'>#endif</span>
}

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,5))</span>
<span style='color:#0057ae;'>static</span> <b>struct</b> kobj_type usb_serial_kobj_type = {
	.release = destroy_serial,
};
<span style='color:#006e28;'>#endif</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>void</span> port_release(<b>struct</b> device *dev)
{
	<b>struct</b> usb_serial_port *port = to_usb_serial_port(dev);

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,30))</span>
	dbg (<span style='color:#bf0303;'>&quot;%s - %s&quot;</span>, __FUNCTION__, dev-&gt;bus_id);
<span style='color:#006e28;'>#else</span>

	dbg (<span style='color:#bf0303;'>&quot;%s - %s&quot;</span>, __FUNCTION__, dev_name(dev));
<span style='color:#006e28;'>#endif</span>
	usb_kill_urb(port-&gt;read_urb);
	usb_free_urb(port-&gt;read_urb);
	usb_kill_urb(port-&gt;write_urb);
	usb_free_urb(port-&gt;write_urb);
	usb_kill_urb(port-&gt;interrupt_in_urb);
	usb_free_urb(port-&gt;interrupt_in_urb);
	usb_kill_urb(port-&gt;interrupt_out_urb);
	usb_free_urb(port-&gt;interrupt_out_urb);
	kfree(port-&gt;bulk_in_buffer);
	kfree(port-&gt;bulk_out_buffer);
	kfree(port-&gt;interrupt_in_buffer);
	kfree(port-&gt;interrupt_out_buffer);
	kfree(port);
}
<span style='color:#006e28;'>#else</span>
<span style='color:#0057ae;'>static</span> <span style='color:#0057ae;'>void</span> port_release(<b>struct</b> device *dev)
{
	<b>struct</b> usb_serial_port *port = to_usb_serial_port(dev);

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,30))</span>
	dbg (<span style='color:#bf0303;'>&quot;%s - %s&quot;</span>, __FUNCTION__, dev-&gt;bus_id);
<span style='color:#006e28;'>#else</span>

	dbg (<span style='color:#bf0303;'>&quot;%s - %s&quot;</span>, __FUNCTION__, dev_name(dev));
<span style='color:#006e28;'>#endif</span>
	<b>if</b> (port-&gt;read_urb) {
		usb_unlink_urb(port-&gt;read_urb);
		usb_free_urb(port-&gt;read_urb);
	}
	<b>if</b> (port-&gt;write_urb) {
		usb_unlink_urb(port-&gt;write_urb);
		usb_free_urb(port-&gt;write_urb);
	}
	<b>if</b> (port-&gt;interrupt_in_urb) {
		usb_unlink_urb(port-&gt;interrupt_in_urb);
		usb_free_urb(port-&gt;interrupt_in_urb);
	}
	kfree(port-&gt;bulk_in_buffer);
	kfree(port-&gt;bulk_out_buffer);
	kfree(port-&gt;interrupt_in_buffer);
	kfree(port);
}
<span style='color:#006e28;'>#endif</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) </span>
<span style='color:#0057ae;'>static</span> <b>struct</b> usb_serial * create_serial (<b>struct</b> usb_device *dev, 
					  <b>struct</b> usb_interface *interface,
					  <b>struct</b> usb_serial_driver *driver)
<span style='color:#006e28;'>#else					  </span>
<span style='color:#0057ae;'>static</span> <b>struct</b> usb_serial * create_serial (<b>struct</b> usb_device *dev, 
					  <b>struct</b> usb_interface *interface,
					  <b>struct</b> usb_serial_device_type *driver)
<span style='color:#006e28;'>#endif					  </span>
{
	<b>struct</b> usb_serial *serial;

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,17))</span>
	serial = kmalloc(<b>sizeof</b>(*serial), GFP_KERNEL);
<span style='color:#006e28;'>#else</span>
	serial = kzalloc (<b>sizeof</b> (*serial), GFP_KERNEL);
<span style='color:#006e28;'>#endif</span>
	<b>if</b> (!serial) {
		dev_err(&amp;dev-&gt;dev, <span style='color:#bf0303;'>&quot;%s - out of memory</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>, __FUNCTION__);
		<b>return</b> NULL;
	}
	
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,17))</span>
	memset (serial, <span style='color:#b08000;'>0</span>, <b>sizeof</b>(*serial));
<span style='color:#006e28;'>#endif	</span>
	serial-&gt;dev = usb_get_dev(dev);
	serial-&gt;type = driver;
	serial-&gt;interface = interface;

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,10))</span>
	serial-&gt;vendor = dev-&gt;descriptor.idVendor;
	serial-&gt;product = dev-&gt;descriptor.idProduct;
<span style='color:#006e28;'>#endif</span>
	
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,4))</span>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,8)) 			</span>
	kref_init(&amp;serial-&gt;kref);
<span style='color:#006e28;'>#else</span>
	kref_init(&amp;serial-&gt;kref, destroy_serial);
<span style='color:#006e28;'>#endif</span>
<span style='color:#006e28;'>#else</span>
	kobject_init(&amp;serial-&gt;kobj);
	serial-&gt;kobj.ktype = &amp;usb_serial_kobj_type;
<span style='color:#006e28;'>#endif</span>

	<b>return</b> serial;
}

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))</span>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) </span>
<span style='color:#0057ae;'>static</span> <b>struct</b> usb_serial_driver *search_serial_device(<b>struct</b> usb_interface *iface)
<span style='color:#006e28;'>#else</span>
<span style='color:#0057ae;'>static</span> <b>struct</b> usb_serial_device_type *search_serial_device(<b>struct</b> usb_interface *iface)
<span style='color:#006e28;'>#endif</span>
{
	<b>struct</b> list_head *p;
	<span style='color:#0057ae;'>const</span> <b>struct</b> usb_device_id *id;
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) </span>
	<b>struct</b> usb_serial_driver *t;
<span style='color:#006e28;'>#else</span>
	<b>struct</b> usb_serial_device_type *t;
<span style='color:#006e28;'>#endif</span>
	<i><span style='color:#898887;'>/* Check if the usb id matches a known device */</span></i>
	list_for_each(p, &amp;usb_serial_driver_list) {
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) </span>
		t = list_entry(p, <b>struct</b> usb_serial_driver, driver_list);
<span style='color:#006e28;'>#else</span>
		t = list_entry(p, <b>struct</b> usb_serial_device_type, driver_list);
<span style='color:#006e28;'>#endif</span>
		id = usb_match_id(iface, t-&gt;id_table);
		<b>if</b> (id != NULL) {
			dbg(<span style='color:#bf0303;'>&quot;descriptor matches&quot;</span>);
			<b>return</b> t;
		}
	}

	<b>return</b> NULL;
}
<span style='color:#006e28;'>#endif</span>

<span style='color:#0057ae;'>int</span> mx_usbserial_probe(<b>struct</b> usb_interface *interface,
			       <span style='color:#0057ae;'>const</span> <b>struct</b> usb_device_id *id)
{
	<b>struct</b> usb_device *dev = interface_to_usbdev (interface);
	<b>struct</b> usb_serial *serial = NULL;
	<b>struct</b> usb_serial_port *port;
	<b>struct</b> usb_host_interface *iface_desc;
	<b>struct</b> usb_endpoint_descriptor *endpoint;
	<b>struct</b> usb_endpoint_descriptor *interrupt_in_endpoint[MAX_NUM_PORTS];
	<b>struct</b> usb_endpoint_descriptor *bulk_in_endpoint[MAX_NUM_PORTS];
	<b>struct</b> usb_endpoint_descriptor *bulk_out_endpoint[MAX_NUM_PORTS];
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) </span>
	<b>struct</b> usb_serial_driver *type = NULL;
<span style='color:#006e28;'>#else</span>
	<b>struct</b> usb_serial_device_type *type = NULL;	
<span style='color:#006e28;'>#endif	</span>
	<span style='color:#0057ae;'>int</span> retval;
	<span style='color:#0057ae;'>int</span> minor;
	<span style='color:#0057ae;'>int</span> buffer_size;
	<span style='color:#0057ae;'>int</span> i;
	<span style='color:#0057ae;'>int</span> num_interrupt_in = <span style='color:#b08000;'>0</span>;
	<span style='color:#0057ae;'>int</span> num_bulk_in = <span style='color:#b08000;'>0</span>;
	<span style='color:#0057ae;'>int</span> num_bulk_out = <span style='color:#b08000;'>0</span>;
	<span style='color:#0057ae;'>int</span> num_ports = <span style='color:#b08000;'>0</span>;
	<span style='color:#0057ae;'>int</span> max_endpoints;
	
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))</span>
	<b>struct</b> usb_endpoint_descriptor *interrupt_out_endpoint[MAX_NUM_PORTS];
	<span style='color:#0057ae;'>int</span> num_interrupt_out = <span style='color:#b08000;'>0</span>;
	
	type = search_serial_device(interface);
	<b>if</b> (!type) {
<span style='color:#006e28;'>#else	</span>
	<span style='color:#0057ae;'>int</span> found;
	<b>struct</b> list_head *tmp;
	<span style='color:#0057ae;'>const</span> <b>struct</b> usb_device_id *id_pattern = NULL;

	<i><span style='color:#898887;'>/* loop through our list of known serial converters, and see if this</span></i>
<i><span style='color:#898887;'>	   device matches. */</span></i>
	found = <span style='color:#b08000;'>0</span>;
	list_for_each (tmp, &amp;usb_serial_driver_list) {
		type = list_entry(tmp, <b>struct</b> usb_serial_device_type, driver_list);
		id_pattern = usb_match_id(interface, type-&gt;id_table);
		<b>if</b> (id_pattern != NULL) {
			dbg(<span style='color:#bf0303;'>&quot;descriptor matches&quot;</span>);
			found = <span style='color:#b08000;'>1</span>;
			<b>break</b>;
		}
	}
	<b>if</b> (!found) {
<span style='color:#006e28;'>#endif</span>
		dbg(<span style='color:#bf0303;'>&quot;none matched&quot;</span>);
		<b>return</b> -ENODEV;
	}

	serial = create_serial (dev, interface, type);
	<b>if</b> (!serial) {
		dev_err(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;%s - out of memory</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>, __FUNCTION__);
		<b>return</b> -ENOMEM;
	}

	<i><span style='color:#898887;'>/* if this device type has a probe function, call it */</span></i>
	<b>if</b> (type-&gt;probe) {

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))</span>
		<span style='color:#0057ae;'>const</span> <b>struct</b> usb_device_id *id;

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) </span>
		<b>if</b> (!try_module_get(type-&gt;driver.owner)) {
<span style='color:#006e28;'>#else</span>
		<b>if</b> (!try_module_get(type-&gt;owner)) {
<span style='color:#006e28;'>#endif</span>
			dev_err(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;module get failed, exiting</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
			kfree (serial);
			<b>return</b> -EIO;
		}

		id = usb_match_id(interface, type-&gt;id_table);
		retval = type-&gt;probe(serial, id);
<span style='color:#006e28;'>#else	    </span>
		<b>if</b> (!try_module_get(type-&gt;owner)) {
			dev_err(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;module get failed, exiting</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
			kfree (serial);
			<b>return</b> -EIO;
		}
		retval = type-&gt;probe (serial, id_pattern);
<span style='color:#006e28;'>#endif</span>
			
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) </span>
		module_put(type-&gt;driver.owner);
<span style='color:#006e28;'>#else</span>
		module_put(type-&gt;owner);
<span style='color:#006e28;'>#endif</span>

		<b>if</b> (retval) {
			dbg (<span style='color:#bf0303;'>&quot;sub driver rejected device&quot;</span>);
			kfree (serial);
			<b>return</b> retval;
		}
	}

	<i><span style='color:#898887;'>/* descriptor matches, let's find the endpoints needed */</span></i>
	<i><span style='color:#898887;'>/* check out the endpoints */</span></i>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,4))</span>
	iface_desc = interface-&gt;cur_altsetting;
<span style='color:#006e28;'>#else</span>
	iface_desc = &amp;interface-&gt;altsetting[<span style='color:#b08000;'>0</span>];
<span style='color:#006e28;'>#endif</span>
	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i) {
		endpoint = &amp;iface_desc-&gt;endpoint[i].desc;
		
		<b>if</b> ((endpoint-&gt;bEndpointAddress &amp; <span style='color:#b08000;'>0x80</span>) &amp;&amp;
		    ((endpoint-&gt;bmAttributes &amp; <span style='color:#b08000;'>3</span>) == <span style='color:#b08000;'>0x02</span>)) {
			<i><span style='color:#898887;'>/* we found a bulk in endpoint */</span></i>
			dbg(<span style='color:#bf0303;'>&quot;found bulk in on endpoint %d&quot;</span>, i);
			bulk_in_endpoint[num_bulk_in] = endpoint;
			++num_bulk_in;
		}

		<b>if</b> (((endpoint-&gt;bEndpointAddress &amp; <span style='color:#b08000;'>0x80</span>) == <span style='color:#b08000;'>0x00</span>) &amp;&amp;
		    ((endpoint-&gt;bmAttributes &amp; <span style='color:#b08000;'>3</span>) == <span style='color:#b08000;'>0x02</span>)) {
			<i><span style='color:#898887;'>/* we found a bulk out endpoint */</span></i>
			dbg(<span style='color:#bf0303;'>&quot;found bulk out on endpoint %d&quot;</span>, i);
			bulk_out_endpoint[num_bulk_out] = endpoint;
			++num_bulk_out;
		}
		
		<b>if</b> ((endpoint-&gt;bEndpointAddress &amp; <span style='color:#b08000;'>0x80</span>) &amp;&amp;
		    ((endpoint-&gt;bmAttributes &amp; <span style='color:#b08000;'>3</span>) == <span style='color:#b08000;'>0x03</span>)) {
			<i><span style='color:#898887;'>/* we found a interrupt in endpoint */</span></i>
			dbg(<span style='color:#bf0303;'>&quot;found interrupt in on endpoint %d&quot;</span>, i);
			interrupt_in_endpoint[num_interrupt_in] = endpoint;
			++num_interrupt_in;
		}

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))</span>
		<b>if</b> (((endpoint-&gt;bEndpointAddress &amp; <span style='color:#b08000;'>0x80</span>) == <span style='color:#b08000;'>0x00</span>) &amp;&amp;
		    ((endpoint-&gt;bmAttributes &amp; <span style='color:#b08000;'>3</span>) == <span style='color:#b08000;'>0x03</span>)) {
			<i><span style='color:#898887;'>/* we found an interrupt out endpoint */</span></i>
			dbg(<span style='color:#bf0303;'>&quot;found interrupt out on endpoint %d&quot;</span>, i);
			interrupt_out_endpoint[num_interrupt_out] = endpoint;
			++num_interrupt_out;
		}
<span style='color:#006e28;'>#endif		</span>
	}


	<i><span style='color:#898887;'>/* found all that we need */</span></i>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) </span>
	dev_info(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;%s converter detected</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>, type-&gt;description);
<span style='color:#006e28;'>#else</span>
	dev_info(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;%s converter detected</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>, type-&gt;name);
<span style='color:#006e28;'>#endif</span>

	<b>if</b> (!num_ports) {
		<i><span style='color:#898887;'>/* if this device type has a calc_num_ports function, call it */</span></i>
		<b>if</b> (type-&gt;calc_num_ports) {
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) </span>
			<b>if</b> (!try_module_get(type-&gt;driver.owner)) {
<span style='color:#006e28;'>#else</span>
			<b>if</b> (!try_module_get(type-&gt;owner)) {
<span style='color:#006e28;'>#endif			    </span>
				dev_err(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;module get failed, exiting</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
				kfree (serial);
				<b>return</b> -EIO;
			}
			num_ports = type-&gt;calc_num_ports (serial);
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) </span>
			module_put(type-&gt;driver.owner);
<span style='color:#006e28;'>#else</span>
			module_put(type-&gt;owner);
<span style='color:#006e28;'>#endif</span>
		}
		<b>if</b> (!num_ports)
			num_ports = type-&gt;num_ports;
	}

	<b>if</b> (get_free_serial (serial, num_ports, &amp;minor) == NULL) {
		dev_err(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;No more free serial devices</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
		kfree (serial);
		<b>return</b> -ENOMEM;
	}

	serial-&gt;minor = minor;
	serial-&gt;num_ports = num_ports;
	serial-&gt;num_bulk_in = num_bulk_in;
	serial-&gt;num_bulk_out = num_bulk_out;
	serial-&gt;num_interrupt_in = num_interrupt_in;
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))</span>
	serial-&gt;num_interrupt_out = num_interrupt_out;
<span style='color:#006e28;'>#endif</span>
	<i><span style='color:#898887;'>/* create our ports, we need as many as the max endpoints */</span></i>
	<i><span style='color:#898887;'>/* we don't use num_ports here cauz some devices have more endpoint pairs than ports */</span></i>
	max_endpoints = max(num_bulk_in, num_bulk_out);
	max_endpoints = max(max_endpoints, num_interrupt_in);
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))</span>
	max_endpoints = max(max_endpoints, num_interrupt_out);
<span style='color:#006e28;'>#endif	</span>
	max_endpoints = max(max_endpoints, (<span style='color:#0057ae;'>int</span>)serial-&gt;num_ports);
	serial-&gt;num_port_pointers = max_endpoints;
	dbg(<span style='color:#bf0303;'>&quot;%s - setting up %d port structures for this device&quot;</span>, __FUNCTION__, max_endpoints);
	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; max_endpoints; ++i) {
	    
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,17))</span>
		port = kmalloc(<b>sizeof</b>(<b>struct</b> usb_serial_port), GFP_KERNEL);
<span style='color:#006e28;'>#else</span>
		port = kzalloc(<b>sizeof</b>(<b>struct</b> usb_serial_port), GFP_KERNEL);
<span style='color:#006e28;'>#endif</span>
		<b>if</b> (!port)
			<b>goto</b> probe_error;
			
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,17))</span>
		memset(port, <span style='color:#b08000;'>0x00</span>, <b>sizeof</b>(<b>struct</b> usb_serial_port));			
<span style='color:#006e28;'>#endif</span>
		port-&gt;number = i + serial-&gt;minor;
		port-&gt;serial = serial;

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,7))</span>
		port-&gt;magic = USB_SERIAL_PORT_MAGIC;
		
<span style='color:#006e28;'>#endif		</span>

		
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,12))		</span>
		spin_lock_init(&amp;port-&gt;lock);
<span style='color:#006e28;'>#endif		</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,15))</span>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,17))</span>
		sema_init(&amp;port-&gt;sem, <span style='color:#b08000;'>1</span>);
<span style='color:#006e28;'>#endif</span>
<span style='color:#006e28;'>#endif</span>
		
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,16))</span>
		mutex_init(&amp;port-&gt;mutex);
<span style='color:#006e28;'>#endif</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,19))</span>
		INIT_WORK(&amp;port-&gt;work, mx_usbserial_port_softint);
<span style='color:#006e28;'>#else</span>
		INIT_WORK(&amp;port-&gt;work, mx_usbserial_port_softint, port);
<span style='color:#006e28;'>#endif</span>
		serial-&gt;port[i] = port;
	}

	<i><span style='color:#898887;'>/* set up the endpoint information */</span></i>
	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; num_bulk_in; ++i) {
		endpoint = bulk_in_endpoint[i];
		port = serial-&gt;port[i];
		port-&gt;read_urb = usb_alloc_urb (<span style='color:#b08000;'>0</span>, GFP_KERNEL);
		<b>if</b> (!port-&gt;read_urb) {
			dev_err(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;No free urbs available</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
			<b>goto</b> probe_error;
		}
		buffer_size = le16_to_cpu(endpoint-&gt;wMaxPacketSize);
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))</span>
		port-&gt;bulk_in_size = buffer_size;
<span style='color:#006e28;'>#endif		</span>
		port-&gt;bulk_in_endpointAddress = endpoint-&gt;bEndpointAddress;
		port-&gt;bulk_in_buffer = kmalloc (buffer_size, GFP_KERNEL);
		<b>if</b> (!port-&gt;bulk_in_buffer) {
			dev_err(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;Couldn't allocate bulk_in_buffer</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
			<b>goto</b> probe_error;
		}
		usb_fill_bulk_urb (port-&gt;read_urb, dev,
				   usb_rcvbulkpipe (dev,
					   	    endpoint-&gt;bEndpointAddress),
				   port-&gt;bulk_in_buffer, buffer_size,
				   serial-&gt;type-&gt;read_bulk_callback,
				   port);
	}

	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; num_bulk_out; ++i) {
		endpoint = bulk_out_endpoint[i];
		port = serial-&gt;port[i];
		port-&gt;write_urb = usb_alloc_urb(<span style='color:#b08000;'>0</span>, GFP_KERNEL);
		<b>if</b> (!port-&gt;write_urb) {
			dev_err(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;No free urbs available</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
			<b>goto</b> probe_error;
		}
		buffer_size = le16_to_cpu(endpoint-&gt;wMaxPacketSize);
		port-&gt;bulk_out_size = buffer_size;
		port-&gt;bulk_out_endpointAddress = endpoint-&gt;bEndpointAddress;
		port-&gt;bulk_out_buffer = kmalloc (buffer_size, GFP_KERNEL);
		<b>if</b> (!port-&gt;bulk_out_buffer) {
			dev_err(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;Couldn't allocate bulk_out_buffer</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
			<b>goto</b> probe_error;
		}
		usb_fill_bulk_urb (port-&gt;write_urb, dev,
				   usb_sndbulkpipe (dev,
						    endpoint-&gt;bEndpointAddress),
				   port-&gt;bulk_out_buffer, buffer_size, 
				   serial-&gt;type-&gt;write_bulk_callback,
				   port);
	}

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))</span>
	<b>if</b> (serial-&gt;type-&gt;read_int_callback) {
<span style='color:#006e28;'>#endif</span>
		<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; num_interrupt_in; ++i) {
			endpoint = interrupt_in_endpoint[i];
			port = serial-&gt;port[i];
			port-&gt;interrupt_in_urb = usb_alloc_urb(<span style='color:#b08000;'>0</span>, GFP_KERNEL);
			<b>if</b> (!port-&gt;interrupt_in_urb) {
				dev_err(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;No free urbs available</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
				<b>goto</b> probe_error;
			}
			buffer_size = le16_to_cpu(endpoint-&gt;wMaxPacketSize);
			port-&gt;interrupt_in_endpointAddress = endpoint-&gt;bEndpointAddress;
			port-&gt;interrupt_in_buffer = kmalloc (buffer_size, GFP_KERNEL);
			<b>if</b> (!port-&gt;interrupt_in_buffer) {
				dev_err(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;Couldn't allocate interrupt_in_buffer</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
				<b>goto</b> probe_error;
			}
			usb_fill_int_urb (port-&gt;interrupt_in_urb, dev, 
					  usb_rcvintpipe (dev,
							  endpoint-&gt;bEndpointAddress),
					  port-&gt;interrupt_in_buffer, buffer_size, 
					  serial-&gt;type-&gt;read_int_callback, port, 
					  endpoint-&gt;bInterval);
		}
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))</span>
	} <b>else</b> <b>if</b> (num_interrupt_in) {
		dbg(<span style='color:#bf0303;'>&quot;the device claims to support interrupt in transfers, but read_int_callback is not defined&quot;</span>);
	}
	
	<b>if</b> (serial-&gt;type-&gt;write_int_callback) {
		<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; num_interrupt_out; ++i) {
			endpoint = interrupt_out_endpoint[i];
			port = serial-&gt;port[i];
			port-&gt;interrupt_out_urb = usb_alloc_urb(<span style='color:#b08000;'>0</span>, GFP_KERNEL);
			<b>if</b> (!port-&gt;interrupt_out_urb) {
				dev_err(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;No free urbs available</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
				<b>goto</b> probe_error;
			}
			buffer_size = le16_to_cpu(endpoint-&gt;wMaxPacketSize);
			port-&gt;interrupt_out_size = buffer_size;
			port-&gt;interrupt_out_endpointAddress = endpoint-&gt;bEndpointAddress;
			port-&gt;interrupt_out_buffer = kmalloc (buffer_size, GFP_KERNEL);
			<b>if</b> (!port-&gt;interrupt_out_buffer) {
				dev_err(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;Couldn't allocate interrupt_out_buffer</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
				<b>goto</b> probe_error;
			}
			usb_fill_int_urb (port-&gt;interrupt_out_urb, dev,
					  usb_sndintpipe (dev,
							  endpoint-&gt;bEndpointAddress),
					  port-&gt;interrupt_out_buffer, buffer_size,
					  serial-&gt;type-&gt;write_int_callback, port,
					  endpoint-&gt;bInterval);
		}
	} <b>else</b> <b>if</b> (num_interrupt_out) {
		dbg(<span style='color:#bf0303;'>&quot;the device claims to support interrupt out transfers, but write_int_callback is not defined&quot;</span>);
	}
<span style='color:#006e28;'>#endif</span>
	<i><span style='color:#898887;'>/* if this device type has an attach function, call it */</span></i>
	<b>if</b> (type-&gt;attach) {
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) 	    </span>
		<b>if</b> (!try_module_get(type-&gt;driver.owner)) {
<span style='color:#006e28;'>#else		    </span>
		<b>if</b> (!try_module_get(type-&gt;owner)) {
<span style='color:#006e28;'>#endif		    </span>
			dev_err(&amp;interface-&gt;dev, <span style='color:#bf0303;'>&quot;module get failed, exiting</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
			<b>goto</b> probe_error;
		}
		retval = type-&gt;attach (serial);
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) 	    </span>
		module_put(type-&gt;driver.owner);
<span style='color:#006e28;'>#else</span>
		module_put(type-&gt;owner);
<span style='color:#006e28;'>#endif		</span>
		<b>if</b> (retval &lt; <span style='color:#b08000;'>0</span>)
			<b>goto</b> probe_error;
		<b>if</b> (retval &gt; <span style='color:#b08000;'>0</span>) {
			<i><span style='color:#898887;'>/* quietly accept this device, but don't bind to a serial port</span></i>
<i><span style='color:#898887;'>			 * as it's about to disappear */</span></i>
			<b>goto</b> exit;
		}
	}

	<i><span style='color:#898887;'>/* register all of the individual ports with the driver core */</span></i>
	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; num_ports; ++i) {
		port = serial-&gt;port[i];
		port-&gt;dev.parent = &amp;interface-&gt;dev;
		port-&gt;dev.driver = NULL;
		port-&gt;dev.bus = &amp;mx_usb_serial_bus_type;
		port-&gt;dev.release = &amp;port_release;

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,30))</span>
		snprintf (&amp;port-&gt;dev.bus_id[<span style='color:#b08000;'>0</span>], <b>sizeof</b>(port-&gt;dev.bus_id),
		<span style='color:#bf0303;'>&quot;ttyMXUSB%d&quot;</span>, port-&gt;number);

		dbg (<span style='color:#bf0303;'>&quot;%s - registering %s&quot;</span>, __FUNCTION__, port-&gt;dev.bus_id);

<span style='color:#006e28;'>#else</span>
		dev_set_name (&amp;port-&gt;dev, <span style='color:#bf0303;'>&quot;ttyMXUSB%d&quot;</span>, port-&gt;number);
		dbg (<span style='color:#bf0303;'>&quot;%s - registering %s&quot;</span>, __FUNCTION__, dev_name(&amp;port-&gt;dev));
<span style='color:#006e28;'>#endif</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,25))</span>
		retval = device_register (&amp;port-&gt;dev);
<span style='color:#006e28;'>#else</span>
		retval = device_register (&amp;port-&gt;dev);

<span style='color:#006e28;'>#endif</span>
	}

	<i><span style='color:#898887;'>//mx_usbserial_console_init (debug, minor);</span></i>

exit:
	<i><span style='color:#898887;'>/* success */</span></i>
	usb_set_intfdata (interface, serial);
	<b>return</b> <span style='color:#b08000;'>0</span>;

probe_error:
	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; num_bulk_in; ++i) {
		port = serial-&gt;port[i];
		<b>if</b> (!port)
			<b>continue</b>;
		<b>if</b> (port-&gt;read_urb)
			usb_free_urb (port-&gt;read_urb);
		kfree(port-&gt;bulk_in_buffer);
	}
	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; num_bulk_out; ++i) {
		port = serial-&gt;port[i];
		<b>if</b> (!port)
			<b>continue</b>;
		<b>if</b> (port-&gt;write_urb)
			usb_free_urb (port-&gt;write_urb);
		kfree(port-&gt;bulk_out_buffer);
	}
	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; num_interrupt_in; ++i) {
		port = serial-&gt;port[i];
		<b>if</b> (!port)
			<b>continue</b>;
		<b>if</b> (port-&gt;interrupt_in_urb)
			usb_free_urb (port-&gt;interrupt_in_urb);
		kfree(port-&gt;interrupt_in_buffer);
	}
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))</span>
	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; num_interrupt_out; ++i) {
		port = serial-&gt;port[i];
		<b>if</b> (!port)
			<b>continue</b>;
		<b>if</b> (port-&gt;interrupt_out_urb)
			usb_free_urb (port-&gt;interrupt_out_urb);
		kfree(port-&gt;interrupt_out_buffer);
	}
<span style='color:#006e28;'>#endif</span>

	<i><span style='color:#898887;'>/* return the minor range that this device had */</span></i>
	return_serial (serial);

	<i><span style='color:#898887;'>/* free up any memory that we allocated */</span></i>
	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; serial-&gt;num_port_pointers; ++i)
		kfree(serial-&gt;port[i]);
	kfree (serial);
	<b>return</b> -EIO;
}

<span style='color:#0057ae;'>void</span> mx_usbserial_disconnect(<b>struct</b> usb_interface *interface)
{
	<b>struct</b> usb_serial *serial = usb_get_intfdata (interface);
	<b>struct</b> device *dev = &amp;interface-&gt;dev;
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,10))</span>
	<span style='color:#0057ae;'>int</span> i;
	<b>struct</b> usb_serial_port *port;
<span style='color:#006e28;'>#endif</span>

	dbg (<span style='color:#bf0303;'>&quot;%s&quot;</span>, __FUNCTION__);

	usb_set_intfdata (interface, NULL);
	<b>if</b> (serial) {
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,10))</span>
		<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; serial-&gt;num_ports; ++i) {
			port = serial-&gt;port[i];
			<b>if</b> (port &amp;&amp; port-&gt;tty)
				tty_hangup(port-&gt;tty);
		}
<span style='color:#006e28;'>#endif		</span>
		<i><span style='color:#898887;'>/* let the last holder of this object </span></i>
<i><span style='color:#898887;'>		 * cause it to be cleaned up */</span></i>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,4))</span>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,8)) 			</span>
			kref_put(&amp;serial-&gt;kref, destroy_serial);
<span style='color:#006e28;'>#else</span>
			kref_put(&amp;serial-&gt;kref);			
<span style='color:#006e28;'>#endif</span>
<span style='color:#006e28;'>#else</span>
		    kobject_put (&amp;serial-&gt;kobj);
<span style='color:#006e28;'>#endif</span>
	}
	dev_info(dev, <span style='color:#bf0303;'>&quot;device disconnected</span><span style='color:#ff80e0;'>\n</span><span style='color:#bf0303;'>&quot;</span>);
}

<span style='color:#0057ae;'>static</span> <b>struct</b> tty_operations serial_ops = {
	.open =			serial_open,
	.close =		serial_close,
	.write =		serial_write,
	.write_room =		serial_write_room,
	.ioctl =		serial_ioctl,
	.set_termios =		serial_set_termios,
	.throttle =		serial_throttle,
	.unthrottle =		serial_unthrottle,
	.break_ctl =		serial_break,
	.chars_in_buffer =	serial_chars_in_buffer,
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,30))</span>
	.read_proc =		serial_read_proc,
<span style='color:#006e28;'>#endif</span>
	.tiocmget =		serial_tiocmget,
	.tiocmset =		serial_tiocmset,
};

<b>struct</b> tty_driver *mx_usbserial_tty_driver;

<span style='color:#0057ae;'>int</span> usb_serial_init(<span style='color:#0057ae;'>void</span>)
{
	<span style='color:#0057ae;'>int</span> i;
	<span style='color:#0057ae;'>int</span> result;

	mx_usbserial_tty_driver = alloc_tty_driver(SERIAL_TTY_MINORS);
	<b>if</b> (!mx_usbserial_tty_driver)
		<b>return</b> -ENOMEM;

	<i><span style='color:#898887;'>/* Initialize our global data */</span></i>
	<b>for</b> (i = <span style='color:#b08000;'>0</span>; i &lt; SERIAL_TTY_MINORS; ++i) {
		serial_table[i] = NULL;
	}


	result = bus_register(&amp;mx_usb_serial_bus_type);
	<b>if</b> (result) {
		err(<span style='color:#bf0303;'>&quot;%s - registering bus driver failed&quot;</span>, __FUNCTION__);
		<b>goto</b> exit_bus;
	}

	mx_usbserial_tty_driver-&gt;owner = THIS_MODULE;
	mx_usbserial_tty_driver-&gt;driver_name = <span style='color:#bf0303;'>&quot;mxusbserial&quot;</span>;
<span style='color:#bf0303;'>#if(LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,18))</span>
	mx_usbserial_tty_driver-&gt;devfs_name = <span style='color:#bf0303;'>&quot;usb/tts/&quot;</span>;
	mx_usbserial_tty_driver-&gt;flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
<span style='color:#006e28;'>#else</span>
	mx_usbserial_tty_driver-&gt;flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
<span style='color:#006e28;'>#endif</span>
	mx_usbserial_tty_driver-&gt;name = 	<span style='color:#bf0303;'>&quot;ttyMXUSB&quot;</span>;
	mx_usbserial_tty_driver-&gt;major = SERIAL_TTY_MAJOR;
	mx_usbserial_tty_driver-&gt;minor_start = <span style='color:#b08000;'>0</span>;
	mx_usbserial_tty_driver-&gt;type = TTY_DRIVER_TYPE_SERIAL;
	mx_usbserial_tty_driver-&gt;subtype = SERIAL_TYPE_NORMAL;
	mx_usbserial_tty_driver-&gt;init_termios = tty_std_termios;
	mx_usbserial_tty_driver-&gt;init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
	tty_set_operations(mx_usbserial_tty_driver, &amp;serial_ops);
	result = tty_register_driver(mx_usbserial_tty_driver);
	<b>if</b> (result) {
		err(<span style='color:#bf0303;'>&quot;%s - tty_register_driver failed&quot;</span>, __FUNCTION__);
		<b>goto</b> exit_reg_driver;
	}

	<i><span style='color:#898887;'>/* register the USB driver */</span></i>
	result = usb_register(&amp;usb_serial_driver);
	<b>if</b> (result &lt; <span style='color:#b08000;'>0</span>) {
		err(<span style='color:#bf0303;'>&quot;%s - usb_register failed&quot;</span>, __FUNCTION__);
		<b>goto</b> exit_tty;
	}

	printk(KERN_INFO DRIVER_DESC);

	<b>return</b> result;

exit_tty:
	tty_unregister_driver(mx_usbserial_tty_driver);

exit_reg_driver:
	bus_unregister(&amp;mx_usb_serial_bus_type);

exit_bus:
	err (<span style='color:#bf0303;'>&quot;%s - returning with error %d&quot;</span>, __FUNCTION__, result);
	put_tty_driver(mx_usbserial_tty_driver);
	<b>return</b> result;
}


<span style='color:#0057ae;'>void</span> usb_serial_exit(<span style='color:#0057ae;'>void</span>)
{
	<i><span style='color:#898887;'>//mx_usbserial_console_exit();</span></i>
	
	usb_deregister(&amp;usb_serial_driver);
	tty_unregister_driver(mx_usbserial_tty_driver);
	put_tty_driver(mx_usbserial_tty_driver);
	bus_unregister(&amp;mx_usb_serial_bus_type);
}


module_init(usb_serial_init);
module_exit(usb_serial_exit);

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,9))</span>
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) 	    </span>
<span style='color:#0057ae;'>int</span> mx_usbserial_register(<b>struct</b> usb_serial_driver *driver)
<span style='color:#006e28;'>#else</span>
<span style='color:#0057ae;'>int</span> mx_usbserial_register(<b>struct</b> usb_serial_device_type *driver)
<span style='color:#006e28;'>#endif</span>
{
	<span style='color:#0057ae;'>int</span> retval;


<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) 	    </span>
	<b>if</b> (!driver-&gt;description)
		driver-&gt;description = driver-&gt;driver.name;
<span style='color:#006e28;'>#endif</span>

	<i><span style='color:#898887;'>/* Add this device to our list of devices */</span></i>
	list_add(&amp;driver-&gt;driver_list, &amp;usb_serial_driver_list);

	retval = mx_usbserial_bus_register(driver);
	<b>if</b> (retval) {
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) 	    </span>
		err(<span style='color:#bf0303;'>&quot;problem %d when registering driver %s&quot;</span>, retval, driver-&gt;description);
<span style='color:#006e28;'>#else</span>
		err(<span style='color:#bf0303;'>&quot;problem %d when registering driver %s&quot;</span>, retval, driver-&gt;name);
<span style='color:#006e28;'>#endif		</span>
		list_del(&amp;driver-&gt;driver_list);
	}
	<b>else</b>{

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) 	    </span>
		printk(KERN_INFO <span style='color:#bf0303;'>&quot;USB Serial support registered for %s&quot;</span>, driver-&gt;description);
<span style='color:#006e28;'>#else</span>
		info(<span style='color:#bf0303;'>&quot;USB Serial support registered for %s&quot;</span>, driver-&gt;name);
<span style='color:#006e28;'>#endif    </span>

    }
    
	<b>return</b> retval;
}
<span style='color:#006e28;'>#else</span>
<span style='color:#0057ae;'>int</span> mx_usbserial_register(<b>struct</b> usb_serial_device_type *driver)
{
	<span style='color:#0057ae;'>int</span> retval;

	<i><span style='color:#898887;'>/* Add this device to our list of devices */</span></i>
	list_add(&amp;driver-&gt;driver_list, &amp;usb_serial_driver_list);

	retval =  mx_usbserial_bus_register (driver);

	<b>if</b> (retval)
		<b>goto</b> error;

	printk(KERN_INFO <span style='color:#bf0303;'>&quot;USB Serial support registered for %s&quot;</span>, driver-&gt;name);

	<b>return</b> retval;
error:
	err(<span style='color:#bf0303;'>&quot;problem %d when registering driver %s&quot;</span>, retval, driver-&gt;name);
	list_del(&amp;driver-&gt;driver_list);

	<b>return</b> retval;
}
<span style='color:#006e28;'>#endif</span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) 	    </span>
<span style='color:#0057ae;'>void</span> mx_usbserial_deregister(<b>struct</b> usb_serial_driver *device)
<span style='color:#006e28;'>#else</span>
<span style='color:#0057ae;'>void</span> mx_usbserial_deregister(<b>struct</b> usb_serial_device_type *device)
<span style='color:#006e28;'>#endif</span>
{
<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,8))</span>
	<b>struct</b> usb_serial *serial;
	<span style='color:#0057ae;'>int</span> i;

	printk(KERN_INFO <span style='color:#bf0303;'>&quot;USB Serial deregistering driver %s&quot;</span>, device-&gt;name);

	<i><span style='color:#898887;'>/* clear out the serial_table if the device is attached to a port */</span></i>
	<b>for</b>(i = <span style='color:#b08000;'>0</span>; i &lt; SERIAL_TTY_MINORS; ++i) {
		serial = serial_table[i];
		<b>if</b> ((serial != NULL) &amp;&amp; (serial-&gt;type == device)) {
			usb_driver_release_interface (&amp;usb_serial_driver, serial-&gt;interface);
			mx_usbserial_disconnect (serial-&gt;interface);
		}
	}
<span style='color:#006e28;'>#else        </span>

<span style='color:#006e28;'>#if (LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,14)) 	    </span>
	printk(KERN_INFO <span style='color:#bf0303;'>&quot;USB Serial deregistering driver %s&quot;</span>, device-&gt;description);
<span style='color:#006e28;'>#else</span>
	info(<span style='color:#bf0303;'>&quot;USB Serial deregistering driver %s&quot;</span>, device-&gt;name);
<span style='color:#006e28;'>#endif</span>

<span style='color:#006e28;'>#endif</span>
	list_del(&amp;device-&gt;driver_list);
	mx_usbserial_bus_deregister(device);
}



<i><span style='color:#898887;'>/* If the usb-serial core is built into the core, the usb-serial drivers</span></i>
<i><span style='color:#898887;'>   need these symbols to load properly as modules. */</span></i>

EXPORT_SYMBOL_GPL(mx_usbserial_register);
EXPORT_SYMBOL_GPL(mx_usbserial_deregister);
EXPORT_SYMBOL_GPL(mx_usbserial_probe);
EXPORT_SYMBOL_GPL(mx_usbserial_disconnect);
EXPORT_SYMBOL_GPL(mx_usbserial_port_softint);


<i><span style='color:#898887;'>/* Module information */</span></i>
MODULE_AUTHOR( DRIVER_AUTHOR );
MODULE_DESCRIPTION( DRIVER_DESC );
MODULE_LICENSE(<span style='color:#bf0303;'>&quot;GPL&quot;</span>);

module_param(debug, bool, S_IRUGO | S_IWUSR);
MODULE_PARM_DESC(debug, <span style='color:#bf0303;'>&quot;Debug enabled or not&quot;</span>);
</pre>
</body>
</html>
