\hypertarget{classmdt_usbtmc_port_manager}{
\section{mdtUsbtmcPortManager Class Reference}
\label{classmdt_usbtmc_port_manager}\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
}


USBTMC port manager.  




{\ttfamily \#include $<$mdtUsbtmcPortManager.h$>$}



Inheritance diagram for mdtUsbtmcPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=202pt]{classmdt_usbtmc_port_manager__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtUsbtmcPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=310pt]{classmdt_usbtmc_port_manager__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Slots}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_usbtmc_port_manager_aca42b343ae1f6a324e6e45968f03bbea}{fromThreadNewFrameReaden} ()
\begin{DoxyCompactList}\small\item\em Called by the thread whenn a frame was readen. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_usbtmc_port_manager_a99a24e4360e70ffc63677dbe888513f7}{mdtUsbtmcPortManager} (QObject $\ast$parent=0)
\begin{DoxyCompactList}\small\item\em Construct a USBTMC port manager. \end{DoxyCompactList}\item 
\hyperlink{classmdt_usbtmc_port_manager_aad6b2eef9b5cfb5c324affb6962a463b}{$\sim$mdtUsbtmcPortManager} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_usbtmc_port_manager_a992d1227810186d3c7dc166452e2e3b6}{scan} ()
\begin{DoxyCompactList}\small\item\em Scan for available ports with a USBTMC compatible device attached. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usbtmc_port_manager_aaab645cfcafbac7a83a69f2084900246}{sendCommand} (const QByteArray \&command, int timeout=0)
\begin{DoxyCompactList}\small\item\em Send a command to device. \end{DoxyCompactList}\item 
QByteArray \hyperlink{classmdt_usbtmc_port_manager_a858590909ce63319a3390140c4d0a6ca}{sendQuery} (const QByteArray \&query, int writeTimeout=0, int readTimeout=0)
\begin{DoxyCompactList}\small\item\em Send a query to device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usbtmc_port_manager_a58fbe73aad9b42214335187f8d21e3c6}{writeData} (const QByteArray \&data)
\begin{DoxyCompactList}\small\item\em Write data by copy. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usbtmc_port_manager_a2920bdd6b189f198f132de9e5555a78b}{sendReadRequest} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Send a read request to device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usbtmc_port_manager_ab1604a1c8f2e9192714d039dbf9a5158}{sendReadRequest} (bool enqueueResponse)
\begin{DoxyCompactList}\small\item\em Send a read request to device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usbtmc_port_manager_a7bcc280bd4a26ed523832550b1e61553}{sendReadStatusByteRequest} ()
\begin{DoxyCompactList}\small\item\em Send a READ\_\-STATUS\_\-BYTE request thru the control endpoint. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usbtmc_port_manager_af412ba1b1e7e56ebecd2e59cb6bf607a}{abortBulkOut} (quint8 bTag)
\begin{DoxyCompactList}\small\item\em Abort bulk OUT. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usbtmc_port_manager_a987b71d620dac06be85567a92f272f6b}{sendInitiateAbortBulkOutRequest} (quint8 bTag)
\begin{DoxyCompactList}\small\item\em Send a INITIATE\_\-ABORT\_\-BULK\_\-OUT request thru the control endpoint. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usbtmc_port_manager_a724a999c11ab0458f53427fbb6862d62}{sendCheckAbortBulkOutStatusRequest} (quint8 bTag)
\begin{DoxyCompactList}\small\item\em Send a CHECK\_\-ABORT\_\-BULK\_\-OUT\_\-STATUS request thru the control endpoint. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
USBTMC port manager. 

\begin{Desc}
\item[\hyperlink{bug__bug000002}{Bug}]abortBulkIn() does not work properly \end{Desc}


This is the easiest way to use the USBTMC port API.

All needed object are created by constructor. To alter configuration, use \hyperlink{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{config()}. To access the usb port object, use port().

Use \hyperlink{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{start()} to begin read/write and stop to end. 

Definition at line 44 of file mdtUsbtmcPortManager.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_usbtmc_port_manager_a99a24e4360e70ffc63677dbe888513f7}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{mdtUsbtmcPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtUsbtmcPortManager::mdtUsbtmcPortManager (
\begin{DoxyParamCaption}
\item[{QObject $\ast$}]{parent = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_a99a24e4360e70ffc63677dbe888513f7}


Construct a USBTMC port manager. 

Create a thread and setup port. 

connect(portThread, SIGNAL(messageInReaden()), this, SLOT(\hyperlink{classmdt_usb_port_manager_a9b7154590a4eb267aff4e11ba53dd7aa}{fromThreadMessageInReaden()})); 



Definition at line 37 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_aad6b2eef9b5cfb5c324affb6962a463b}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!$\sim$mdtUsbtmcPortManager@{$\sim$mdtUsbtmcPortManager}}
\index{$\sim$mdtUsbtmcPortManager@{$\sim$mdtUsbtmcPortManager}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{$\sim$mdtUsbtmcPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtUsbtmcPortManager::$\sim$mdtUsbtmcPortManager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_aad6b2eef9b5cfb5c324affb6962a463b}


Destructor. 

Stop the manager (if running), and close the port (if open). All internal objects (port, config and threads) are deleted here. 

Definition at line 62 of file mdtUsbtmcPortManager.cpp.



\subsection{Member Function Documentation}
\hypertarget{classmdt_usbtmc_port_manager_af412ba1b1e7e56ebecd2e59cb6bf607a}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!abortBulkOut@{abortBulkOut}}
\index{abortBulkOut@{abortBulkOut}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{abortBulkOut}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbtmcPortManager::abortBulkOut (
\begin{DoxyParamCaption}
\item[{quint8}]{bTag}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_af412ba1b1e7e56ebecd2e59cb6bf607a}


Abort bulk OUT. 

\begin{DoxyReturn}{Returns}
0 on success. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
port must be set before call of this method
\end{DoxyPrecond}
\begin{Desc}
\item[\hyperlink{todo__todo000038}{Todo}]Finish and test \end{Desc}


\begin{Desc}
\item[\hyperlink{todo__todo000039}{Todo}]Implement clear halt \end{Desc}




Definition at line 254 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_aca42b343ae1f6a324e6e45968f03bbea}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!fromThreadNewFrameReaden@{fromThreadNewFrameReaden}}
\index{fromThreadNewFrameReaden@{fromThreadNewFrameReaden}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{fromThreadNewFrameReaden}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbtmcPortManager::fromThreadNewFrameReaden (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual, slot\mbox{]}}}}
\label{classmdt_usbtmc_port_manager_aca42b343ae1f6a324e6e45968f03bbea}


Called by the thread whenn a frame was readen. 

\begin{Desc}
\item[\hyperlink{todo__todo000040}{Todo}]On complete frame, check bTag/bTagInverse, and INITIATE\_\-CLEAR on error. \end{Desc}


Reimplemented from \hyperlink{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{mdtPortManager}.



Definition at line 416 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_a992d1227810186d3c7dc166452e2e3b6}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!scan@{scan}}
\index{scan@{scan}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtUsbtmcPortManager::scan (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usbtmc_port_manager_a992d1227810186d3c7dc166452e2e3b6}


Scan for available ports with a USBTMC compatible device attached. 

Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).

\begin{DoxyPrecond}{Precondition}
Manager must no running 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_usb_port_manager_a3a2370c3a2d0353a880bf9b777728c3b}{mdtUsbPortManager}.



Definition at line 66 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_a724a999c11ab0458f53427fbb6862d62}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!sendCheckAbortBulkOutStatusRequest@{sendCheckAbortBulkOutStatusRequest}}
\index{sendCheckAbortBulkOutStatusRequest@{sendCheckAbortBulkOutStatusRequest}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{sendCheckAbortBulkOutStatusRequest}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbtmcPortManager::sendCheckAbortBulkOutStatusRequest (
\begin{DoxyParamCaption}
\item[{quint8}]{bTag}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_a724a999c11ab0458f53427fbb6862d62}


Send a CHECK\_\-ABORT\_\-BULK\_\-OUT\_\-STATUS request thru the control endpoint. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_usbtmc_port_manager_af412ba1b1e7e56ebecd2e59cb6bf607a}{abortBulkOut()} 
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
bTag on success or WriteQueueEmpty on error. 
\end{DoxyReturn}


Definition at line 384 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_aaab645cfcafbac7a83a69f2084900246}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!sendCommand@{sendCommand}}
\index{sendCommand@{sendCommand}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{sendCommand}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbtmcPortManager::sendCommand (
\begin{DoxyParamCaption}
\item[{const QByteArray \&}]{command, }
\item[{int}]{timeout = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_aaab645cfcafbac7a83a69f2084900246}


Send a command to device. 

Wait until it's possible to write to device, then send the command.

Note that the wait will not break the GUI's event loop (see \hyperlink{classmdt_port_manager_a1ca92c5ac120d87e5b10bff54ed1aa5c}{mdtPortManager::waitOnWriteReady()} for details).


\begin{DoxyParams}{Parameters}
{\em command} & Command to send. \\
\hline
{\em timeout} & Write timeout \mbox{[}ms\mbox{]} If 0, internal defined timeout is used (see \hyperlink{classmdt_port_manager_a9d6782be514745a1b1392216d17d41df}{mdtPortManager::adjustedWriteTimeout()} for details). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bTag on success, or a error $<$ 0 (see \hyperlink{classmdt_usbtmc_port_manager_a58fbe73aad9b42214335187f8d21e3c6}{mdtUsbtmcPortManager::writeData()} for details). 
\end{DoxyReturn}


Definition at line 93 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_a987b71d620dac06be85567a92f272f6b}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!sendInitiateAbortBulkOutRequest@{sendInitiateAbortBulkOutRequest}}
\index{sendInitiateAbortBulkOutRequest@{sendInitiateAbortBulkOutRequest}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{sendInitiateAbortBulkOutRequest}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbtmcPortManager::sendInitiateAbortBulkOutRequest (
\begin{DoxyParamCaption}
\item[{quint8}]{bTag}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_a987b71d620dac06be85567a92f272f6b}


Send a INITIATE\_\-ABORT\_\-BULK\_\-OUT request thru the control endpoint. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_usbtmc_port_manager_af412ba1b1e7e56ebecd2e59cb6bf607a}{abortBulkOut()} 
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
bTag on success or WriteQueueEmpty on error. 
\end{DoxyReturn}


Definition at line 353 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_a858590909ce63319a3390140c4d0a6ca}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!sendQuery@{sendQuery}}
\index{sendQuery@{sendQuery}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{sendQuery}]{\setlength{\rightskip}{0pt plus 5cm}QByteArray mdtUsbtmcPortManager::sendQuery (
\begin{DoxyParamCaption}
\item[{const QByteArray \&}]{query, }
\item[{int}]{writeTimeout = {\ttfamily 0}, }
\item[{int}]{readTimeout = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_a858590909ce63319a3390140c4d0a6ca}


Send a query to device. 

Wait until it's possible to write to device, send the query and wait until a response is available or timeout.

Note that the wait will not break the GUI's event loop.


\begin{DoxyParams}{Parameters}
{\em query} & Query to send. \\
\hline
{\em writeTimeout} & Write timeout \mbox{[}ms\mbox{]} If 0, internal defined timeout is used (see \hyperlink{classmdt_port_manager_a9d6782be514745a1b1392216d17d41df}{mdtPortManager::adjustedWriteTimeout()} for details). \\
\hline
{\em readTimeout} & Response timeout \mbox{[}ms\mbox{]} If 0, internal defined timeout is used (see \hyperlink{classmdt_port_manager_a7cb3155940e23db0122d14f21fca858d}{mdtPortManager::adjustedReadTimeout()} for details). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Result as string (empty string on error) Note that \hyperlink{classmdt_frame_codec_scpi}{mdtFrameCodecScpi} can be helpful to decode returned result.
\end{DoxyReturn}
\begin{Desc}
\item[\hyperlink{todo__todo000036}{Todo}]Remove timeouts \end{Desc}


Definition at line 104 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_a2920bdd6b189f198f132de9e5555a78b}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!sendReadRequest@{sendReadRequest}}
\index{sendReadRequest@{sendReadRequest}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{sendReadRequest}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbtmcPortManager::sendReadRequest (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_a2920bdd6b189f198f132de9e5555a78b}


Send a read request to device. 

USBTMC standard need that a read request is sent to device before we can read any data.


\begin{DoxyParams}{Parameters}
{\em transaction} & A pointer to a valid transaction, with queryReplyMode set. (id will be set internally). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bTag ID on success or value $<$ 0 if write queue is full. On failure, the transaction is restored to pool. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
port must be set 

transaction must be a valid pointer 
\end{DoxyPrecond}


Definition at line 174 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_ab1604a1c8f2e9192714d039dbf9a5158}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!sendReadRequest@{sendReadRequest}}
\index{sendReadRequest@{sendReadRequest}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{sendReadRequest}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbtmcPortManager::sendReadRequest (
\begin{DoxyParamCaption}
\item[{bool}]{enqueueResponse}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_ab1604a1c8f2e9192714d039dbf9a5158}


Send a read request to device. 

USBTMC standard need that a read request is sent to device before we can read any data.


\begin{DoxyParams}{Parameters}
{\em enqueueResponse} & When data comes in,\\
\hline
\end{DoxyParams}
\begin{Desc}
\item[\hyperlink{todo__todo000041}{Todo}]SigName is emited. In blocking mode, data must (additionally) be enqueued until there are readen. So, for blocking mode (\char`\"{}script\char`\"{}), set this parameter true. \end{Desc}
\begin{DoxyReturn}{Returns}
bTag ID on success or value $<$ 0 if write queue is full. 
\end{DoxyReturn}


Definition at line 214 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_a7bcc280bd4a26ed523832550b1e61553}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!sendReadStatusByteRequest@{sendReadStatusByteRequest}}
\index{sendReadStatusByteRequest@{sendReadStatusByteRequest}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{sendReadStatusByteRequest}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbtmcPortManager::sendReadStatusByteRequest (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_a7bcc280bd4a26ed523832550b1e61553}


Send a READ\_\-STATUS\_\-BYTE request thru the control endpoint. 

\begin{DoxyReturn}{Returns}
bTag on success or WriteQueueEmpty on error.
\end{DoxyReturn}
\begin{Desc}
\item[\hyperlink{todo__todo000037}{Todo}]finish ! \end{Desc}


m.sendControlRequest(f); End Sandbox ! 



Definition at line 226 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_a58fbe73aad9b42214335187f8d21e3c6}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!writeData@{writeData}}
\index{writeData@{writeData}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{writeData}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbtmcPortManager::writeData (
\begin{DoxyParamCaption}
\item[{const QByteArray \&}]{data}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_a58fbe73aad9b42214335187f8d21e3c6}


Write data by copy. 

Data will be encoded regarding USBTMC standard and passed to the mdtUsbPort's write queue by copy. This method returns immediatly after enqueue, and don't wait until data was written.

This method does not use transaction, because no response will be returned.


\begin{DoxyParams}{Parameters}
{\em data} & Data to write \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bTag ID on success or mdtAbstractPort::WriteQueueEmpty ($<$ 0). 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Definition at line 139 of file mdtUsbtmcPortManager.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtUsbtmcPortManager.h\item 
src/mdtport/mdtUsbtmcPortManager.cpp\end{DoxyCompactItemize}
