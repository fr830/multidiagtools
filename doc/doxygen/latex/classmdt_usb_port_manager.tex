\hypertarget{classmdt_usb_port_manager}{
\section{mdtUsbPortManager Class Reference}
\label{classmdt_usb_port_manager}\index{mdtUsbPortManager@{mdtUsbPortManager}}
}


Helper class that simplify access to USB port API.  




{\ttfamily \#include $<$mdtUsbPortManager.h$>$}



Inheritance diagram for mdtUsbPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=202pt]{classmdt_usb_port_manager__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtUsbPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=310pt]{classmdt_usb_port_manager__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Slots}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_usb_port_manager_af043c75c74665b23d13f3cb73150935c}{fromThreadControlResponseReaden} ()
\begin{DoxyCompactList}\small\item\em Called from USB thread when a control reply was received. \end{DoxyCompactList}\item 
\hypertarget{classmdt_usb_port_manager_a9b7154590a4eb267aff4e11ba53dd7aa}{
void \hyperlink{classmdt_usb_port_manager_a9b7154590a4eb267aff4e11ba53dd7aa}{fromThreadMessageInReaden} ()}
\label{classmdt_usb_port_manager_a9b7154590a4eb267aff4e11ba53dd7aa}

\begin{DoxyCompactList}\small\item\em Called from USB thread when a message IN was received ( on additionnal interrupt IN endpoint). \end{DoxyCompactList}\item 
\hypertarget{classmdt_usb_port_manager_a8f53dc5445b7f8f4a077f3cc25880b5d}{
void \hyperlink{classmdt_usb_port_manager_a8f53dc5445b7f8f4a077f3cc25880b5d}{fromThreadReadUntilShortPacketReceivedFinished} ()}
\label{classmdt_usb_port_manager_a8f53dc5445b7f8f4a077f3cc25880b5d}

\begin{DoxyCompactList}\small\item\em Called by thread when the read until a short packet process is finished. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_usb_port_manager_a7f82574e84d0a99d1c8bef7fd79283e3}{mdtUsbPortManager} (QObject $\ast$parent=0)
\begin{DoxyCompactList}\small\item\em Contruct a USB port manager. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_usb_port_manager_ac0da1cf62e664b78fe91b873da5835ce}{$\sim$mdtUsbPortManager} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
virtual QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_usb_port_manager_a3a2370c3a2d0353a880bf9b777728c3b}{scan} ()
\begin{DoxyCompactList}\small\item\em Get a list of attached USB devices. \end{DoxyCompactList}\item 
QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_usb_port_manager_ab28253c46c80bb12cbbd116b05c4bcd3}{scan} (int bDeviceClass, int bDeviceSubClass, int bDeviceProtocol)
\begin{DoxyCompactList}\small\item\em Get a list of attached USB devices. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_usb_port_manager_a7e7e6a29c2cf8d1d6bee23dd3f69d829}{openPort} ()
\begin{DoxyCompactList}\small\item\em Open the port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_manager_adff8a1f8ed2b0e68229e2016c75e04a6}{readUntilShortPacketReceived} ()
\begin{DoxyCompactList}\small\item\em Request port to read until a short frame is received. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_usb_port_manager_aea4a67550effcba13acfc110d6d30c3e}{sendControlRequest} (const \hyperlink{classmdt_frame_usb_control}{mdtFrameUsbControl} \&request, bool setwIndexAsbInterfaceNumber=false)
\begin{DoxyCompactList}\small\item\em Send a control request by copy. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_usb_port_manager_ad91c432e85737f2224bbae651fb65a8d}{waitReadenControlResponse} (int timeout=0)
\begin{DoxyCompactList}\small\item\em Wait until a control response is readen. \end{DoxyCompactList}\item 
QList$<$ \hyperlink{classmdt_frame_usb_control}{mdtFrameUsbControl} $>$ \hyperlink{classmdt_usb_port_manager_a84c26fee7dfb26290659aa002e0842c6}{readenControlResponses} ()
\begin{DoxyCompactList}\small\item\em Get all readen control responses. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_manager_a982256ed17db155e1c95d544683a6dba}{flushIn} (bool flushPortManagerBuffers, bool flushPortBuffers)
\begin{DoxyCompactList}\small\item\em Flush input buffers. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_manager_ab723086376175c40635df44adf358985}{flushOut} (bool flushPortManagerBuffers, bool flushPortBuffers)
\begin{DoxyCompactList}\small\item\em Flush output buffers. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Helper class that simplify access to USB port API. 

Based on \hyperlink{classmdt_port_manager}{mdtPortManager}, some USB specific methods are added. The internal configuration (a \hyperlink{classmdt_port_config}{mdtPortConfig} object) is keeped default. 

Definition at line 33 of file mdtUsbPortManager.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_usb_port_manager_a7f82574e84d0a99d1c8bef7fd79283e3}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!mdtUsbPortManager@{mdtUsbPortManager}}
\index{mdtUsbPortManager@{mdtUsbPortManager}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{mdtUsbPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtUsbPortManager::mdtUsbPortManager (
\begin{DoxyParamCaption}
\item[{QObject $\ast$}]{parent = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_manager_a7f82574e84d0a99d1c8bef7fd79283e3}


Contruct a USB port manager. 

Will create \hyperlink{classmdt_usb_port}{mdtUsbPort} and setup. Thread will be created at first call of \hyperlink{classmdt_usb_port_manager_a7e7e6a29c2cf8d1d6bee23dd3f69d829}{openPort()}. 

pvReadUntilShortPacketReceivedFinished = false; 



Definition at line 34 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_ac0da1cf62e664b78fe91b873da5835ce}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!$\sim$mdtUsbPortManager@{$\sim$mdtUsbPortManager}}
\index{$\sim$mdtUsbPortManager@{$\sim$mdtUsbPortManager}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{$\sim$mdtUsbPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtUsbPortManager::$\sim$mdtUsbPortManager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_manager_ac0da1cf62e664b78fe91b873da5835ce}


Destructor. 

Stop the manager (if running), and close the port (if open). All internal objects (port, config and threads) are deleted here. 

Definition at line 47 of file mdtUsbPortManager.cpp.



\subsection{Member Function Documentation}
\hypertarget{classmdt_usb_port_manager_a982256ed17db155e1c95d544683a6dba}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!flushIn@{flushIn}}
\index{flushIn@{flushIn}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{flushIn}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPortManager::flushIn (
\begin{DoxyParamCaption}
\item[{bool}]{flushPortManagerBuffers, }
\item[{bool}]{flushPortBuffers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_manager_a982256ed17db155e1c95d544683a6dba}


Flush input buffers. 


\begin{DoxyParams}{Parameters}
{\em flushPortManagerBuffers} & If true, port manager buffers will be cleared. \\
\hline
{\em flushPortBuffers} & If true, port's buffers will be cleared. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before calling this method. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_port_manager_ac0844a5cd4043a95a479d458ac7ce590}{mdtPortManager}.



Definition at line 291 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_ab723086376175c40635df44adf358985}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!flushOut@{flushOut}}
\index{flushOut@{flushOut}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{flushOut}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPortManager::flushOut (
\begin{DoxyParamCaption}
\item[{bool}]{flushPortManagerBuffers, }
\item[{bool}]{flushPortBuffers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_manager_ab723086376175c40635df44adf358985}


Flush output buffers. 


\begin{DoxyParams}{Parameters}
{\em flushPortManagerBuffers} & If true, port manager buffers will be cleared. (Has no effect in this implementation, but some subclass can have output buffers). \\
\hline
{\em flushPortBuffers} & If true, port's buffers will be cleared. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before calling this method. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_port_manager_a3f0c2722a41c49de2bea9013bccd049c}{mdtPortManager}.



Definition at line 302 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_af043c75c74665b23d13f3cb73150935c}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!fromThreadControlResponseReaden@{fromThreadControlResponseReaden}}
\index{fromThreadControlResponseReaden@{fromThreadControlResponseReaden}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{fromThreadControlResponseReaden}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPortManager::fromThreadControlResponseReaden (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}slot\mbox{]}}}}
\label{classmdt_usb_port_manager_af043c75c74665b23d13f3cb73150935c}


Called from USB thread when a control reply was received. 

Will add a copy of received control responses to internal queue and restore frame back to port's pool. 

Definition at line 309 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_a7e7e6a29c2cf8d1d6bee23dd3f69d829}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!openPort@{openPort}}
\index{openPort@{openPort}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{openPort}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtUsbPortManager::openPort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_manager_a7e7e6a29c2cf8d1d6bee23dd3f69d829}


Open the port. 

Overloads \hyperlink{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{mdtPortManager::openPort()}.

Will construct the thread if not allready exists. This is because \hyperlink{classmdt_usbtmc_port_manager}{mdtUsbtmcPortManager} uses a different thread, so this task can not be done in constructor.

Internally, \hyperlink{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{mdtPortManager::openPort()} is called. 

connect(portThread, SIGNAL(messageInReaden()), this, SLOT(\hyperlink{classmdt_usb_port_manager_a9b7154590a4eb267aff4e11ba53dd7aa}{fromThreadMessageInReaden()})); connect(portThread, SIGNAL(readUntilShortPacketReceivedFinished()), this, SLOT(\hyperlink{classmdt_usb_port_manager_a8f53dc5445b7f8f4a077f3cc25880b5d}{fromThreadReadUntilShortPacketReceivedFinished()})); 



Reimplemented from \hyperlink{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{mdtPortManager}.



Definition at line 178 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_a84c26fee7dfb26290659aa002e0842c6}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!readenControlResponses@{readenControlResponses}}
\index{readenControlResponses@{readenControlResponses}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{readenControlResponses}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtFrameUsbControl} $>$ mdtUsbPortManager::readenControlResponses (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_manager_a84c26fee7dfb26290659aa002e0842c6}


Get all readen control responses. 

Note that calling this methode will clear the internal queue. (A second call will return a empty list). 

Definition at line 279 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_adff8a1f8ed2b0e68229e2016c75e04a6}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!readUntilShortPacketReceived@{readUntilShortPacketReceived}}
\index{readUntilShortPacketReceived@{readUntilShortPacketReceived}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{readUntilShortPacketReceived}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPortManager::readUntilShortPacketReceived (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_manager_adff8a1f8ed2b0e68229e2016c75e04a6}


Request port to read until a short frame is received. 

This is, for example, used by USBTMC bulk in abort process. If such request is pending, thread will read until a short frame is received.

Will send the request and wait until it is finished (will not break GUI event loop).

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} with a \hyperlink{classmdt_usb_port}{mdtUsbPort} (or subclass) before use of this method. 
\end{DoxyPrecond}


Definition at line 193 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_ab28253c46c80bb12cbbd116b05c4bcd3}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!scan@{scan}}
\index{scan@{scan}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtUsbPortManager::scan (
\begin{DoxyParamCaption}
\item[{int}]{bDeviceClass, }
\item[{int}]{bDeviceSubClass, }
\item[{int}]{bDeviceProtocol}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_manager_ab28253c46c80bb12cbbd116b05c4bcd3}


Get a list of attached USB devices. 

Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).


\begin{DoxyParams}{Parameters}
{\em bDeviceClass} & If $>$= 0, only devices with matching bDeviceClass are listed \\
\hline
{\em bDeviceSubClass} & If $>$= 0, only devices with matching bDeviceSubClass are listed \\
\hline
{\em bDeviceProtocol} & If $>$= 0, only devices with matching bDeviceProtocol are listed\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Manager must no running 
\end{DoxyPrecond}


Definition at line 60 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_a3a2370c3a2d0353a880bf9b777728c3b}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!scan@{scan}}
\index{scan@{scan}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtUsbPortManager::scan (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_manager_a3a2370c3a2d0353a880bf9b777728c3b}


Get a list of attached USB devices. 

Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).

\begin{DoxyPrecond}{Precondition}
Manager must no running 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}{mdtPortManager}.



Reimplemented in \hyperlink{classmdt_usbtmc_port_manager_a992d1227810186d3c7dc166452e2e3b6}{mdtUsbtmcPortManager}.



Definition at line 55 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_aea4a67550effcba13acfc110d6d30c3e}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!sendControlRequest@{sendControlRequest}}
\index{sendControlRequest@{sendControlRequest}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{sendControlRequest}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbPortManager::sendControlRequest (
\begin{DoxyParamCaption}
\item[{const {\bf mdtFrameUsbControl} \&}]{request, }
\item[{bool}]{setwIndexAsbInterfaceNumber = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_manager_aea4a67550effcba13acfc110d6d30c3e}


Send a control request by copy. 

Request will be passed to the mdtPort's control request queue by copy. This method returns immediatly after enqueue, and don't wait until data was written.


\begin{DoxyParams}{Parameters}
{\em frame} & Frame containing request to send. \\
\hline
{\em setwIndexAsbInterfaceNumber} & If true, wIndex will be set with USB port's current bInterfaceNumber \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success or value $<$ 0 on error. In this implementation, the only possible error is mdtAbstractPort::WriteQueueEmpty . Some subclass can return a frame ID on success, or a other error. See subclass documentation for details. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} with a \hyperlink{classmdt_usb_port}{mdtUsbPort} (or subclass) before use of this method.
\end{DoxyPrecond}
Subclass notes:\par
 This method can be reimplemented in subclass if needed. Typically usefull if a frame ID must be generated for each request (f.ex. bTag on USBTMC). A frame must be taken from port's request frames pool with mdtAbstractPort::controlFramesPool() dequeue() method (see Qt's QQueue documentation for more details on dequeue() ), then added to port's request queue with mdtAbstractPort::addControlRequest() . If protocol supports frame identification (like USBTMC's bTag), it should be returned here and incremented. 

Definition at line 215 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_ad91c432e85737f2224bbae651fb65a8d}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!waitReadenControlResponse@{waitReadenControlResponse}}
\index{waitReadenControlResponse@{waitReadenControlResponse}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{waitReadenControlResponse}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtUsbPortManager::waitReadenControlResponse (
\begin{DoxyParamCaption}
\item[{int}]{timeout = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_manager_ad91c432e85737f2224bbae651fb65a8d}


Wait until a control response is readen. 

This method will return when a control response was readen.

Internally, a couple of sleep and process event are called, so Qt's event loop will not be broken.

This method can return if timeout occurs, or for other reason depending on specific port (port timeout, read canceled, ...).


\begin{DoxyParams}{Parameters}
{\em timeout} & Maximum wait time \mbox{[}ms\mbox{]}. Must be a multiple of 50 \mbox{[}ms\mbox{]} If 0, the minimal timeout will be used (see \hyperlink{classmdt_port_manager_a7cb3155940e23db0122d14f21fca858d}{adjustedReadTimeout()} ). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if Ok, false on timeout 
\end{DoxyReturn}


Definition at line 252 of file mdtUsbPortManager.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtUsbPortManager.h\item 
src/mdtport/mdtUsbPortManager.cpp\end{DoxyCompactItemize}
