<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Multi diag tools: mdtPortThread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Multi diag tools</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">mdtPortThread Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="mdtPortThread" --><div class="dynheader">
Inheritance diagram for mdtPortThread:</div>
<div class="dyncontent">
<div class="center"><img src="classmdt_port_thread__inherit__graph.png" border="0" usemap="#mdt_port_thread_inherit__map" alt="Inheritance graph"/></div>
<map name="mdt_port_thread_inherit__map" id="mdt_port_thread_inherit__map">
<area shape="rect" id="node3" href="classmdt_port_read_thread.html" title="Reader thread for port I/O." alt="" coords="173,5,312,35"/><area shape="rect" id="node5" href="classmdt_port_write_thread.html" title="mdtPortWriteThread" alt="" coords="173,59,312,88"/><area shape="rect" id="node7" href="classmdt_serial_port_ctl_thread.html" title="mdtSerialPortCtlThread" alt="" coords="164,112,321,141"/><area shape="rect" id="node9" href="classmdt_tcp_socket_thread.html" title="mdtTcpSocketThread" alt="" coords="169,165,316,195"/><area shape="rect" id="node11" href="classmdt_usb_port_thread.html" title="mdtUsbPortThread" alt="" coords="177,219,308,248"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mdtPortThread:</div>
<div class="dyncontent">
<div class="center"><img src="classmdt_port_thread__coll__graph.png" border="0" usemap="#mdt_port_thread_coll__map" alt="Collaboration graph"/></div>
<map name="mdt_port_thread_coll__map" id="mdt_port_thread_coll__map">
<area shape="rect" id="node2" href="classmdt_abstract_port.html" title="Base class for port I/O." alt="" coords="5,101,123,131"/><area shape="rect" id="node4" href="classmdt_port_config.html" title="mdtPortConfig" alt="" coords="11,5,117,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classmdt_port_thread-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="signals"></a>
Signals</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_port_thread.html#a8f3d8f3d70839e5ae7b108a3a199e94d">ioProcessBegin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted when a I/O process begins.  <a href="#a8f3d8f3d70839e5ae7b108a3a199e94d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_port_thread.html#a7fc2245c753fd65e1beffec211c41461">newFrameReaden</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emited when a new frame is available.  <a href="#a7fc2245c753fd65e1beffec211c41461"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_port_thread.html#ab31cbe1a85aa830cd368654d1f806326">errorOccured</a> (int error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted on error.  <a href="#ab31cbe1a85aa830cd368654d1f806326"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa20869c68d7a016f9e547464f0d8b71e"></a><!-- doxytag: member="mdtPortThread::mdtPortThread" ref="aa20869c68d7a016f9e547464f0d8b71e" args="(QObject *parent=0)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>mdtPortThread</b> (QObject *parent=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_port_thread.html#acd51474c3a2683676423317bc9cb31b2">setPort</a> (<a class="el" href="classmdt_abstract_port.html">mdtAbstractPort</a> *port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the port instance.  <a href="#acd51474c3a2683676423317bc9cb31b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_port_thread.html#a29b434534a5564efbd9dfe570a61b143">detachPort</a> (bool releaseMemory)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach the port from thread.  <a href="#a29b434534a5564efbd9dfe570a61b143"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_port_thread.html#a9c45f260b8d58b7475151df79b3d8510">start</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the thread.  <a href="#a9c45f260b8d58b7475151df79b3d8510"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_port_thread.html#a5746ea96689ed80179751ad1353f0b39">stop</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the running thread.  <a href="#a5746ea96689ed80179751ad1353f0b39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1becf17263dd9fbf5dfcc6c51eddd72"></a><!-- doxytag: member="mdtPortThread::isRunning" ref="ae1becf17263dd9fbf5dfcc6c51eddd72" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_port_thread.html#ae1becf17263dd9fbf5dfcc6c51eddd72">isRunning</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the thread is running This function overloads the QThread::isRunning() function. Note for subclass: when the thread is started and ready, the private member pvRunning must be set to true. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_port_thread.html#a55d7ef615447823bf9878492a2c88fd4">isFinished</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false if the thread is running.  <a href="#a55d7ef615447823bf9878492a2c88fd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_port_thread.html#a3d57f15a864ae45c98eb40dd89f4cec6">isReader</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this thread reads data and send the <a class="el" href="classmdt_port_thread.html#a7fc2245c753fd65e1beffec211c41461" title="Emited when a new frame is available.">newFrameReaden()</a> signal.  <a href="#a3d57f15a864ae45c98eb40dd89f4cec6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_frame.html">mdtFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_port_thread.html#a611211e56620ec9c699019452716e4fc">getNewFrameRead</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a new frame for reading data from port.  <a href="#a611211e56620ec9c699019452716e4fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_frame.html">mdtFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_port_thread.html#a7e6e152839e35b8fbd1eb299c1d0b2fe">readFromPort</a> (<a class="el" href="classmdt_frame.html">mdtFrame</a> *frame)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from port.  <a href="#a7e6e152839e35b8fbd1eb299c1d0b2fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_frame.html">mdtFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_port_thread.html#acba4fce38a633da68ec23fe191ba6105">getNewFrameWrite</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a new frame for writing data to port.  <a href="#acba4fce38a633da68ec23fe191ba6105"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_port_thread.html#a9372a53561362b0c86f499b8a36805e1">writeToPort</a> (<a class="el" href="classmdt_frame.html">mdtFrame</a> *frame, bool bytePerByteWrite, int interByteTime)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to port.  <a href="#a9372a53561362b0c86f499b8a36805e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_port_thread.html#aaea2513ab1611574111dd1c2b7e61b7c">reconnect</a> (int timeout, int maxTry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to reconnect to device/peer.  <a href="#aaea2513ab1611574111dd1c2b7e61b7c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01d2362e0dfcece4cba242cb586d8d1c"></a><!-- doxytag: member="mdtPortThread::sigactionHandle" ref="a01d2362e0dfcece4cba242cb586d8d1c" args="(int signum)" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><b>sigactionHandle</b> (int signum)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59735ef01b761361b1055a0356be525a"></a><!-- doxytag: member="mdtPortThread::pvRunning" ref="a59735ef01b761361b1055a0356be525a" args="" -->
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><b>pvRunning</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5c4bed0c9fb012f220fba013d0f69b8"></a><!-- doxytag: member="mdtPortThread::pvPort" ref="af5c4bed0c9fb012f220fba013d0f69b8" args="" -->
<a class="el" href="classmdt_abstract_port.html">mdtAbstractPort</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pvPort</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7154af7d387eecaea113ddb5900ff23c"></a><!-- doxytag: member="mdtPortThread::pvNativePthreadObject" ref="a7154af7d387eecaea113ddb5900ff23c" args="" -->
pthread_t&#160;</td><td class="memItemRight" valign="bottom"><b>pvNativePthreadObject</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae22f83fd56b06cdaa9b77abafe85a6b4"></a><!-- doxytag: member="mdtPortThread::pvSigaction" ref="ae22f83fd56b06cdaa9b77abafe85a6b4" args="" -->
struct sigaction&#160;</td><td class="memItemRight" valign="bottom"><b>pvSigaction</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="mdt_port_thread_8h_source.html#l00036">36</a> of file <a class="el" href="mdt_port_thread_8h_source.html">mdtPortThread.h</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a29b434534a5564efbd9dfe570a61b143"></a><!-- doxytag: member="mdtPortThread::detachPort" ref="a29b434534a5564efbd9dfe570a61b143" args="(bool releaseMemory)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtPortThread::detachPort </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>releaseMemory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detach the port from thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">releaseMemory</td><td>If true, the port object that was set with <a class="el" href="classmdt_port_thread.html#acd51474c3a2683676423317bc9cb31b2" title="Set the port instance.">setPort()</a> will be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The thread must not running </dd></dl>

<p>Definition at line <a class="el" href="mdt_port_thread_8cpp_source.html#l00061">61</a> of file <a class="el" href="mdt_port_thread_8cpp_source.html">mdtPortThread.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab31cbe1a85aa830cd368654d1f806326"></a><!-- doxytag: member="mdtPortThread::errorOccured" ref="ab31cbe1a85aa830cd368654d1f806326" args="(int error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtPortThread::errorOccured </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emitted on error. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000029">Todo:</a></b></dt><dd>Adapt threads + port managers</dd></dl>
<p>When a error occurs, this signal is emited.</p>
<p>The error is one of the <a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e" title="Error.">mdtAbstractPort::error_t</a>.</p>
<p><a class="el" href="classmdt_port_manager.html" title="Port manager base class.">mdtPortManager</a> uses this signal. If the <a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85ea8b70726d03f75a691ac4ad65722a5f3c">mdtAbstractPort::Disconnected</a> error happens, the port manager stops the thread and closes the port. Optionnaly, it can try to re-open the port, and start the thread again on success. </p>

</div>
</div>
<a class="anchor" id="a611211e56620ec9c699019452716e4fc"></a><!-- doxytag: member="mdtPortThread::getNewFrameRead" ref="a611211e56620ec9c699019452716e4fc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_frame.html">mdtFrame</a> * mdtPortThread::getNewFrameRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a new frame for reading data from port. </p>
<p>This is a helper method for subclass to get a new frame in port's read frames pool.</p>
<p>It can hapen that the read frames pool is empty. In this case, a error will be generated in the <a class="el" href="classmdt_error.html">mdtError</a> log system, the signal <a class="el" href="classmdt_port_thread.html#ab31cbe1a85aa830cd368654d1f806326" title="Emitted on error.">errorOccured()</a> will be emited with MDT_PORT_QUEUE_EMPTY_ERROR value, and method will go sleep until a new frame is available in pool.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000030">Todo:</a></b></dt><dd>Currently implemented in polling, should be done with a wait condition.</dd></dl>
<p>Note about port mutex handling:<br/>
 The port mutext must be locked before calling this method. Internally, it will be unlocked during wait, and will be locked again. So, the port mutex is allways locked when this method returns.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to a new frame. This frame is cleared (with <a class="el" href="classmdt_frame.html#acdf8a921a3f36ca91af88b55b90febdc" title="Overloaded function.">mdtFrame::clear()</a> ). If the runnig flag becomes false, a Null pointer is returned, and thread should stop.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Port must be set with <a class="el" href="classmdt_port_thread.html#acd51474c3a2683676423317bc9cb31b2" title="Set the port instance.">setPort()</a> before using this method. </dd></dl>

<p>Definition at line <a class="el" href="mdt_port_thread_8cpp_source.html#l00173">173</a> of file <a class="el" href="mdt_port_thread_8cpp_source.html">mdtPortThread.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acba4fce38a633da68ec23fe191ba6105"></a><!-- doxytag: member="mdtPortThread::getNewFrameWrite" ref="acba4fce38a633da68ec23fe191ba6105" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_frame.html">mdtFrame</a> * mdtPortThread::getNewFrameWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a new frame for writing data to port. </p>
<p>This is a helper method for subclass to get a new frame in port's write frames.</p>
<p>If no frame is available for write, this method will block the caller thread until one is avaliable.</p>
<p>Note about port mutex handling:<br/>
 The port mutext must be locked before calling this method. Internally, it will be unlocked during wait, and will be locked again. So, the port mutex is allways locked when this method returns.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to a new frame, or Null on stop request.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Port must be set with <a class="el" href="classmdt_port_thread.html#acd51474c3a2683676423317bc9cb31b2" title="Set the port instance.">setPort()</a> before using this method. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classmdt_abstract_port.html" title="Base class for port I/O.">mdtAbstractPort</a> </dd></dl>

<p>Definition at line <a class="el" href="mdt_port_thread_8cpp_source.html#l00278">278</a> of file <a class="el" href="mdt_port_thread_8cpp_source.html">mdtPortThread.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f3d8f3d70839e5ae7b108a3a199e94d"></a><!-- doxytag: member="mdtPortThread::ioProcessBegin" ref="a8f3d8f3d70839e5ae7b108a3a199e94d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtPortThread::ioProcessBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emitted when a I/O process begins. </p>
<p>This can be used to display read/write state. Please consider that this signal is emitted each time the I/O process begins, and not when it ends. This is because asynch I/O calls are fast, and nothing will be seen from user if we update state before/after I/O call. To handle this, use this signal as trigger, and hold the state some stime (f.ex. 100 [ms]) </p>

</div>
</div>
<a class="anchor" id="a55d7ef615447823bf9878492a2c88fd4"></a><!-- doxytag: member="mdtPortThread::isFinished" ref="a55d7ef615447823bf9878492a2c88fd4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mdtPortThread::isFinished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns false if the thread is running. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classmdt_port_thread.html#ae1becf17263dd9fbf5dfcc6c51eddd72" title="Returns true if the thread is running This function overloads the QThread::isRunning() function...">isRunning()</a> </dd></dl>

<p>Definition at line <a class="el" href="mdt_port_thread_8cpp_source.html#l00159">159</a> of file <a class="el" href="mdt_port_thread_8cpp_source.html">mdtPortThread.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d57f15a864ae45c98eb40dd89f4cec6"></a><!-- doxytag: member="mdtPortThread::isReader" ref="a3d57f15a864ae45c98eb40dd89f4cec6" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mdtPortThread::isReader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this thread reads data and send the <a class="el" href="classmdt_port_thread.html#a7fc2245c753fd65e1beffec211c41461" title="Emited when a new frame is available.">newFrameReaden()</a> signal. </p>
<p><a class="el" href="classmdt_port_manager.html" title="Port manager base class.">mdtPortManager</a> can handle many threads. It needs to know wich one will send the <a class="el" href="classmdt_port_thread.html#a7fc2245c753fd65e1beffec211c41461" title="Emited when a new frame is available.">newFrameReaden()</a> signal, so it can connect it to his slot.</p>
<p>This method must be implemented in subclass. </p>

<p>Implemented in <a class="el" href="classmdt_port_read_thread.html#a0138d613b61056c9f8373331de2d9a84">mdtPortReadThread</a>, <a class="el" href="classmdt_port_write_thread.html#ac37bb988773f624def51e841998a2f1e">mdtPortWriteThread</a>, <a class="el" href="classmdt_tcp_socket_thread.html#a3224f12c8ff8d695975030f3f6215010">mdtTcpSocketThread</a>, <a class="el" href="classmdt_usb_port_thread.html#aed82b57c84745f1e2391750697db1022">mdtUsbPortThread</a>, and <a class="el" href="classmdt_serial_port_ctl_thread.html#ab87413cedc8d0540eac553e55a3f6407">mdtSerialPortCtlThread</a>.</p>

</div>
</div>
<a class="anchor" id="a7fc2245c753fd65e1beffec211c41461"></a><!-- doxytag: member="mdtPortThread::newFrameReaden" ref="a7fc2245c753fd65e1beffec211c41461" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtPortThread::newFrameReaden </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emited when a new frame is available. </p>
<p>This signal is emited when a new frame is available.</p>
<p>To get the frame, the simplest way is to use a <a class="el" href="classmdt_port_manager.html" title="Port manager base class.">mdtPortManager</a>.</p>
<p>It's also possible to use <a class="el" href="classmdt_port.html">mdtPort</a>, but this solution needs to handle the mutex, verify the readen queue state, ...</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classmdt_port_manager.html" title="Port manager base class.">mdtPortManager</a> </dd>
<dd>
<a class="el" href="classmdt_port.html">mdtPort</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7e6e152839e35b8fbd1eb299c1d0b2fe"></a><!-- doxytag: member="mdtPortThread::readFromPort" ref="a7e6e152839e35b8fbd1eb299c1d0b2fe" args="(mdtFrame *frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_frame.html">mdtFrame</a> * mdtPortThread::readFromPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmdt_frame.html">mdtFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data from port. </p>
<p>This is a helper method for subclass to store chunk of data into a frame.</p>
<p>Note about port mutex handling:<br/>
 The port mutext must be locked before calling this method. Internally, it will be unlocked during wait, and will be locked again. So, the port mutex is allways locked when this method returns.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>Data readen from port will be stored in this frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the current frame (can be different from frame passed as argument!). It can happen that a Null pointer is returned, and this is a fatal error, and thread should be stopped.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Port must be set with <a class="el" href="classmdt_port_thread.html#acd51474c3a2683676423317bc9cb31b2" title="Set the port instance.">setPort()</a> before using this method. </dd>
<dd>
frame must be a valid pointer (not Null). </dd></dl>

<p>Definition at line <a class="el" href="mdt_port_thread_8cpp_source.html#l00206">206</a> of file <a class="el" href="mdt_port_thread_8cpp_source.html">mdtPortThread.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaea2513ab1611574111dd1c2b7e61b7c"></a><!-- doxytag: member="mdtPortThread::reconnect" ref="aaea2513ab1611574111dd1c2b7e61b7c" args="(int timeout, int maxTry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> mdtPortThread::reconnect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxTry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to reconnect to device/peer. </p>
<p>This is a helper method for subclass. When a port method returns a Disconnected error, the thread can call this method, wich will try to reconnect (using <a class="el" href="classmdt_abstract_port.html#aec74b2db1a629d98a95d8f042ea96653" title="Reconnect device/peer.">mdtAbstractPort::reconnect()</a> ) until max retry was reached.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Timeout per try [ms] </td></tr>
    <tr><td class="paramname">maxTry</td><td>Maximum try </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NoError if reconnection worked or UnhandledError else.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Port must be set with <a class="el" href="classmdt_port_thread.html#acd51474c3a2683676423317bc9cb31b2" title="Set the port instance.">setPort()</a> before using this method. </dd></dl>

<p>Definition at line <a class="el" href="mdt_port_thread_8cpp_source.html#l00349">349</a> of file <a class="el" href="mdt_port_thread_8cpp_source.html">mdtPortThread.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd51474c3a2683676423317bc9cb31b2"></a><!-- doxytag: member="mdtPortThread::setPort" ref="acd51474c3a2683676423317bc9cb31b2" args="(mdtAbstractPort *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtPortThread::setPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmdt_abstract_port.html">mdtAbstractPort</a> *&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the port instance. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>port must be a valid pointer </dd>
<dd>
The thread must not running </dd></dl>

<p>Definition at line <a class="el" href="mdt_port_thread_8cpp_source.html#l00053">53</a> of file <a class="el" href="mdt_port_thread_8cpp_source.html">mdtPortThread.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c45f260b8d58b7475151df79b3d8510"></a><!-- doxytag: member="mdtPortThread::start" ref="a9c45f260b8d58b7475151df79b3d8510" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mdtPortThread::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start the thread. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on sucsessfull start, or flase on start timeout </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Serial port instance must be defined. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>setSerialPort() </dd></dl>

<p>Definition at line <a class="el" href="mdt_port_thread_8cpp_source.html#l00071">71</a> of file <a class="el" href="mdt_port_thread_8cpp_source.html">mdtPortThread.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5746ea96689ed80179751ad1353f0b39"></a><!-- doxytag: member="mdtPortThread::stop" ref="a5746ea96689ed80179751ad1353f0b39" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtPortThread::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop the running thread. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Serial port instance must be defined. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>setSerialPort() </dd></dl>

<p>Reimplemented in <a class="el" href="classmdt_port_write_thread.html#a69702ab3a95c238fb451f866efc7cb34">mdtPortWriteThread</a>, <a class="el" href="classmdt_tcp_socket_thread.html#a0fd2b3f8b497427d84ae358c6f72122e">mdtTcpSocketThread</a>, and <a class="el" href="classmdt_usb_port_thread.html#a0be9bce0248ada81087282deea70505b">mdtUsbPortThread</a>.</p>

<p>Definition at line <a class="el" href="mdt_port_thread_8cpp_source.html#l00098">98</a> of file <a class="el" href="mdt_port_thread_8cpp_source.html">mdtPortThread.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9372a53561362b0c86f499b8a36805e1"></a><!-- doxytag: member="mdtPortThread::writeToPort" ref="a9372a53561362b0c86f499b8a36805e1" args="(mdtFrame *frame, bool bytePerByteWrite, int interByteTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> mdtPortThread::writeToPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmdt_frame.html">mdtFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bytePerByteWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interByteTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write data to port. </p>
<p>This is a helper method for subclass to write a frame to the port. Internally, it will call <a class="el" href="classmdt_abstract_port.html#a35e4686f50e2c53c7e3618cf2c485d92" title="Wait until data can be written to port.">mdtAbstractPort::waitEventWriteReady()</a> before writing.</p>
<p>Note about port mutex handling:<br/>
 The port mutex must be locked before calling this method. Internally, it will be unlocked during wait, and will be locked again. So, the port mutex is allways locked when this method returns.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>Data stored in this frame will be written to port. </td></tr>
    <tr><td class="paramname">bytePerByteWrite</td><td>If true, one byte will be written once. </td></tr>
    <tr><td class="paramname">interByteTime</td><td>Time between each byte write [ms] (has only effect if bytePerByteWrite is true)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NoError on success or a <a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e" title="Error.">mdtAbstractPort::error_t</a> error.</dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Port must be set with <a class="el" href="classmdt_port_thread.html#acd51474c3a2683676423317bc9cb31b2" title="Set the port instance.">setPort()</a> before using this method. </dd>
<dd>
frame must be a valid pointer (not Null). </dd></dl>

<p>Definition at line <a class="el" href="mdt_port_thread_8cpp_source.html#l00285">285</a> of file <a class="el" href="mdt_port_thread_8cpp_source.html">mdtPortThread.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/mdtport/<a class="el" href="mdt_port_thread_8h_source.html">mdtPortThread.h</a></li>
<li>src/mdtport/<a class="el" href="mdt_port_thread_8cpp_source.html">mdtPortThread.cpp</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 5 2012 22:25:01 for Multi diag tools by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
