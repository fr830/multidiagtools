\hypertarget{classmdt_device}{
\section{mdtDevice Class Reference}
\label{classmdt_device}\index{mdtDevice@{mdtDevice}}
}


Base class for a device connected to a port.  




{\ttfamily \#include $<$mdtDevice.h$>$}



Inheritance diagram for mdtDevice:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{classmdt_device__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtDevice:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=156pt]{classmdt_device__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1e}{state\_\-t} \{ \par
\hyperlink{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1ea577f509c27c399a211c5dc18c0235b69}{Ready} =  0, 
\hyperlink{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1eae06fa1b4e5872df7470aeed0878a2947}{Disconnected}, 
\hyperlink{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1ead8adc8658ebaa24f7525fe18558de4c1}{Connecting}, 
\hyperlink{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1ea4a064f3dc9a486991b3ec09127b1c42a}{Busy}, 
\par
\hyperlink{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1ea2f51ec62521e93aad70fe1071e32fa92}{Warning}, 
\hyperlink{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1ea68b5596661e1489134e11545e92274de}{Error}
 \}
\begin{DoxyCompactList}\small\item\em State of device. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Slots}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_device_a40234a70a37b097baa48bdfbb402cdc4}{setAnalogOutputValue} (int address)
\begin{DoxyCompactList}\small\item\em Set value on a analog output on physical device. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_a83b170f1805a05101409bb6d8e15d03a}{setDigitalOutputState} (int address)
\begin{DoxyCompactList}\small\item\em Set state on a digital output on physical device. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_a14634fec6cd6bae810562b3bd88a5c05}{runQueries} ()
\begin{DoxyCompactList}\small\item\em Queries to send periodically. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_aef41742272cbf069890ea95605f41d44}{showStatusMessage} (const QString \&message, int timeout=0)
\begin{DoxyCompactList}\small\item\em Used to show a message in status bar. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_a52a13e5692fccb5aea1f7c3c991823f3}{showStatusMessage} (const QString \&message, const QString \&details, int timeout=0)
\begin{DoxyCompactList}\small\item\em Used to show a message and details in status bar. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Signals}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_device_aecd2d9d2cc3665f2084d0fd20eb3db2d}{stateChanged} (int state)
\begin{DoxyCompactList}\small\item\em Emitted when state has changed. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_a3fbc6e71241e2e9daa2d8557f870c03c}{statusMessageChanged} (const QString \&message, const QString \&details, int timeout)
\begin{DoxyCompactList}\small\item\em Emitted when a new status message is to display. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_device_a6d501791e7243358cc61b144254b80db}{mdtDevice} (QObject $\ast$parent=0)
\item 
\hypertarget{classmdt_device_a80186f1aa6fbdc13f1652de978c35518}{
void \hyperlink{classmdt_device_a80186f1aa6fbdc13f1652de978c35518}{setName} (const QString \&name)}
\label{classmdt_device_a80186f1aa6fbdc13f1652de978c35518}

\begin{DoxyCompactList}\small\item\em Set the device name. \end{DoxyCompactList}\item 
\hypertarget{classmdt_device_a7ad893c6885dbaef5a6cb980bfe627e0}{
QString \hyperlink{classmdt_device_a7ad893c6885dbaef5a6cb980bfe627e0}{name} () const }
\label{classmdt_device_a7ad893c6885dbaef5a6cb980bfe627e0}

\begin{DoxyCompactList}\small\item\em Get device name. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \hyperlink{classmdt_device_abab1b6e45af527880ce469ae318474c0}{connectToDevice} (const \hyperlink{classmdt_device_info}{mdtDeviceInfo} \&devInfo)
\begin{DoxyCompactList}\small\item\em Search and connect to physical device. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos} (\hyperlink{classmdt_device_ios}{mdtDeviceIos} $\ast$ios, bool autoOutputUpdate=false)
\begin{DoxyCompactList}\small\item\em Set the I/O's container. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_aa241c40514683254990e742cf1bbb155}{setBackToReadyStateTimeout} (int timeout)
\begin{DoxyCompactList}\small\item\em Set back to ready state timeout. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_a3477278b4fa937f7667becb14333ef2f}{setAnalogOutputAddressOffset} (int offset)
\begin{DoxyCompactList}\small\item\em Set analog output address offset. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_af5c2759221878a4d0306343f43e3cc45}{setDigitalOutputAddressOffset} (int offset)
\begin{DoxyCompactList}\small\item\em Set digital output address offset. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_port_manager}{mdtPortManager} $\ast$ \hyperlink{classmdt_device_a06d9178b4133fd7b23084e712af20976}{portManager} ()
\begin{DoxyCompactList}\small\item\em Get internal port manager instance. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_a721c5bf2cfa0eef5304333f08da182f7}{start} (int queryInterval)
\begin{DoxyCompactList}\small\item\em Start periodic device querying. \end{DoxyCompactList}\item 
\hypertarget{classmdt_device_adc7ff8f01d68506283a3d0cc6bc25407}{
void \hyperlink{classmdt_device_adc7ff8f01d68506283a3d0cc6bc25407}{stop} ()}
\label{classmdt_device_adc7ff8f01d68506283a3d0cc6bc25407}

\begin{DoxyCompactList}\small\item\em Stop periodic device querying. \end{DoxyCompactList}\item 
QVariant \hyperlink{classmdt_device_ab28a8276ce07524c351b8e9ebdc6ce1e}{getAnalogInputValue} (int address, bool realValue, bool queryDevice, bool waitOnReply)
\begin{DoxyCompactList}\small\item\em Read one analog input on physical device and update (G)UI representation. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_a585cc32f6aac4d5788928ecf1fdacf51}{getAnalogInputs} (int timeout)
\begin{DoxyCompactList}\small\item\em Read all analog inputs on physical device and update (G)UI representation. \end{DoxyCompactList}\item 
QVariant \hyperlink{classmdt_device_a7085491cf2d96fd2afd3004de6caef0d}{getAnalogOutputValue} (int address, int timeout, bool realValue=true)
\begin{DoxyCompactList}\small\item\em Read one analog output on physical device and update (G)UI representation. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_a12f717202e9860d0c24b9dff8d672ef8}{getAnalogOutputs} (int timeout)
\begin{DoxyCompactList}\small\item\em Read all analog outputs on physical device and update (G)UI representation. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_a4b01925cfbbb62e32a3e85a9c4b1538a}{setAnalogOutputValue} (int address, QVariant value, int timeout)
\begin{DoxyCompactList}\small\item\em Write one analog output to physical device and update (G)UI representation. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_ae45c39c2ef38b5952171fdc1c3284748}{setAnalogOutputs} (int timeout)
\begin{DoxyCompactList}\small\item\em Write all analog outputs on physical device and update (G)UI representation. \end{DoxyCompactList}\item 
QVariant \hyperlink{classmdt_device_aad589d5c8c769299fdf0ea4e34d3bc0a}{getDigitalInputState} (int address, int timeout)
\begin{DoxyCompactList}\small\item\em Read one digital input on physical device and update (G)UI representation. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_ae482b28263b2ce61735f42f1245c1e99}{getDigitalInputs} (int timeout)
\begin{DoxyCompactList}\small\item\em Read all digital inputs on physical device and update (G)UI representation. \end{DoxyCompactList}\item 
QVariant \hyperlink{classmdt_device_a719401fec13501047ffdf7f51583937c}{getDigitalOutputState} (int address, int timeout)
\begin{DoxyCompactList}\small\item\em Read one digital output on physical device and update (G)UI representation. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_a6bd6ad4f8d07121dd8b988594927e9c8}{getDigitalOutputs} (int timeout)
\begin{DoxyCompactList}\small\item\em Read all digital outputs on physical device and update (G)UI representation. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_a702a5f49680b03f04a9f58ae6906bf83}{setDigitalOutputState} (int address, bool state, int timeout)
\begin{DoxyCompactList}\small\item\em Write one digital output to physical device and update (G)UI representation. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_ae68a400d5f27fe142d41b674f473bf98}{setDigitalOutputs} (int timeout)
\begin{DoxyCompactList}\small\item\em Write all digital outputs to physical device and update (G)UI representation. \end{DoxyCompactList}\item 
\hypertarget{classmdt_device_afde11f7cb1d6a932db3824011f7ccccc}{
\hyperlink{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1e}{state\_\-t} \hyperlink{classmdt_device_afde11f7cb1d6a932db3824011f7ccccc}{state} () const }
\label{classmdt_device_afde11f7cb1d6a932db3824011f7ccccc}

\begin{DoxyCompactList}\small\item\em Get device state. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Slots}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classmdt_device_a5556423c2e2b3a3adcca5d4efb5af04e}{decodeReadenFrame} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} transaction)
\begin{DoxyCompactList}\small\item\em Decode incoming frames. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual int \hyperlink{classmdt_device_acecf7934ce29b3a957accb0f4c98c746}{readAnalogInput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read one analog input on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_a40674e7bf0c367bb3edb407d73a5bd8e}{readAnalogInputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all analog inputs on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_a7934063c3f41a742515f1232c9598c2a}{readAnalogOutput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read one analog output on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_ab0232ac83c38bc93d3bc2aa91d94c291}{readAnalogOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all analog outputs on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_ae764634bba2b321ac2b4731c0353e45f}{writeAnalogOutput} (int value, \hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write value on a analog output to physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_abc52b797df29945bf0a6358aab1b7245}{writeAnalogOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write all analog outputs to physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_af128b606050035abaf8d049bb2227015}{readDigitalInput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read one digital input on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_a150e3abae6db5bf1ad11017bf2b76c14}{readDigitalInputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all digital inputs on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_a1faee6ab31b094731211ea0943544501}{readDigitalOutput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read one digital output on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_aac038c24c3b91757584bdf0d09fb8b02}{readDigitalOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all digital outputs on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_a0fbe57503d86554829e708b2b83d73f1}{writeDigitalOutput} (bool state, \hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write state on a digital output to physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_aa9e8ae7b4ff2455b4105d280d8523fc1}{writeDigitalOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write all digital outputs to physical device. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classmdt_device_acba50968d201ad95c4eaa2ab2ed48b4f}{queriesSequence} ()
\begin{DoxyCompactList}\small\item\em Sequence of queries to send periodically. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$ \hyperlink{classmdt_device_a0e57cc8b749581cff447d514b9a1ff8e}{getNewTransaction} ()
\begin{DoxyCompactList}\small\item\em Get a new transaction. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_a4619d8be240cafe48865a89f7424de92}{restoreTransaction} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Restore a transaction into pool. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{waitTransactionDone} (int id, int timeout=0, int granularity=50)
\begin{DoxyCompactList}\small\item\em Wait until a transaction is done without break the GUI's event loop. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_device_aa84e01b13f98fc35476a2654f1c8d2b3}{
\hyperlink{classmdt_device_ios}{mdtDeviceIos} $\ast$ {\bfseries pvIos}}
\label{classmdt_device_aa84e01b13f98fc35476a2654f1c8d2b3}

\item 
\hypertarget{classmdt_device_a7578dfa3df390d20b1bdce1319d45dbc}{
int {\bfseries pvDigitalOutputAddressOffset}}
\label{classmdt_device_a7578dfa3df390d20b1bdce1319d45dbc}

\item 
\hypertarget{classmdt_device_a50a6824fe8b9ae2a7e7c56b8e0686a76}{
int {\bfseries pvAnalogOutputAddressOffset}}
\label{classmdt_device_a50a6824fe8b9ae2a7e7c56b8e0686a76}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Base class for a device connected to a port. 

\begin{Desc}
\item[\hyperlink{todo__todo000004}{Todo}]Adapt get...() methods like \hyperlink{classmdt_device_ab28a8276ce07524c351b8e9ebdc6ce1e}{getAnalogInputValue()} \end{Desc}


Querying a device can be done several ways. Some devices sends a confirmation after each query.

Some queries (f.ex. read a input value or state) give a result after query. In some applications, we need to display the reult priodically. In other application, we need to send the query and wait on result before we can continue. This base class gives a interface for these two cases.

At basis, all query methods are not blocking by default. The normal way is to connect \hyperlink{classmdt_port_manager_a77ef4a432306638f5b0f91df7863ac62}{mdtPortManager::newReadenFrame()} to \hyperlink{classmdt_device_a5556423c2e2b3a3adcca5d4efb5af04e}{decodeReadenFrame()} slot (must be done in subclass). This way, a query will be sent to device and method returns. When device returns a result, \hyperlink{classmdt_port_manager}{mdtPortManager} will send the newReadenFrame() signal, and decoding will be processed in \hyperlink{classmdt_device_a5556423c2e2b3a3adcca5d4efb5af04e}{decodeReadenFrame()} and I/O's are updated.

Because the blocking behaviour is sometimes needed, the concept of transaction is implemented. At first, we tell the query method that we will wait on a reply by passing a timeout $>$ 0. Then, the query is sent to device and a transaction ID is added to a list with addTransaction(). At next, \hyperlink{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{waitTransactionDone()} is called, and finally result is returned. Note that \hyperlink{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{waitTransactionDone()} will not breack the Qt's event loop because it uses the \hyperlink{classmdt_port_manager_acc5c63ad33fdd3cc153fc23e00c6e69c}{mdtPortManager::wait()} method (see documentation of \hyperlink{classmdt_port_manager}{mdtPortManager} for details).

Give some helper methods for event handling, ....

If it is needed to continiusly update the representation of device's inputs (digital/analog I/O, voltage, temperature, ...), two things can happen:
\begin{DoxyItemize}
\item 1) Used port can receive data continiusly (f.ex. RS232) and device send data automatically
\item 2) Used port need that a request is sent for each read (TCP, USB, ...) or device need such request Continous update is typical usefull for a GUI representing a real device.
\end{DoxyItemize}

A other usage is automated sequence. In this case, the sequence will tell when it need to set a output and when a input value is reuqierd.

A device can accept one or many request befor results must be read. This depends most case on used port and protocol.

It can be useful to find on witch port a device is attached (f.ex. setup of a automated test application).

A device can have several states (ready, busy, disconnected, ...). To help the application programmer to keep coherence, this states are updated in this class. 

Definition at line 87 of file mdtDevice.h.



\subsection{Member Enumeration Documentation}
\hypertarget{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1e}{
\index{mdtDevice@{mdtDevice}!state\_\-t@{state\_\-t}}
\index{state\_\-t@{state\_\-t}!mdtDevice@{mdtDevice}}
\subsubsection[{state\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf mdtDevice::state\_\-t}}}
\label{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1e}


State of device. 

\begin{Desc}
\item[Enumerator: ]\par
\begin{description}
\index{Ready@{Ready}!mdtDevice@{mdtDevice}}\index{mdtDevice@{mdtDevice}!Ready@{Ready}}\item[{\em 
\hypertarget{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1ea577f509c27c399a211c5dc18c0235b69}{
Ready}
\label{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1ea577f509c27c399a211c5dc18c0235b69}
}]Device is connected and ready to receive queries \index{Disconnected@{Disconnected}!mdtDevice@{mdtDevice}}\index{mdtDevice@{mdtDevice}!Disconnected@{Disconnected}}\item[{\em 
\hypertarget{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1eae06fa1b4e5872df7470aeed0878a2947}{
Disconnected}
\label{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1eae06fa1b4e5872df7470aeed0878a2947}
}]Device is not connected \index{Connecting@{Connecting}!mdtDevice@{mdtDevice}}\index{mdtDevice@{mdtDevice}!Connecting@{Connecting}}\item[{\em 
\hypertarget{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1ead8adc8658ebaa24f7525fe18558de4c1}{
Connecting}
\label{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1ead8adc8658ebaa24f7525fe18558de4c1}
}]Trying to connect to device \index{Busy@{Busy}!mdtDevice@{mdtDevice}}\index{mdtDevice@{mdtDevice}!Busy@{Busy}}\item[{\em 
\hypertarget{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1ea4a064f3dc9a486991b3ec09127b1c42a}{
Busy}
\label{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1ea4a064f3dc9a486991b3ec09127b1c42a}
}]Device is connected but cannot accept requests for the moment \index{Warning@{Warning}!mdtDevice@{mdtDevice}}\index{mdtDevice@{mdtDevice}!Warning@{Warning}}\item[{\em 
\hypertarget{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1ea2f51ec62521e93aad70fe1071e32fa92}{
Warning}
\label{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1ea2f51ec62521e93aad70fe1071e32fa92}
}]Device or port communication handled error occured \index{Error@{Error}!mdtDevice@{mdtDevice}}\index{mdtDevice@{mdtDevice}!Error@{Error}}\item[{\em 
\hypertarget{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1ea68b5596661e1489134e11545e92274de}{
Error}
\label{classmdt_device_a39c301b1fda803dba0c9ab98164a9d1ea68b5596661e1489134e11545e92274de}
}]Device or port communication unhandled error occured \end{description}
\end{Desc}



Definition at line 95 of file mdtDevice.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_device_a6d501791e7243358cc61b144254b80db}{
\index{mdtDevice@{mdtDevice}!mdtDevice@{mdtDevice}}
\index{mdtDevice@{mdtDevice}!mdtDevice@{mdtDevice}}
\subsubsection[{mdtDevice}]{\setlength{\rightskip}{0pt plus 5cm}mdtDevice::mdtDevice (
\begin{DoxyParamCaption}
\item[{QObject $\ast$}]{parent = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a6d501791e7243358cc61b144254b80db}


connect(pvBackToReadyStateTimer, SIGNAL(timeout()), this, SLOT(setStateReady())); connect(pvBackToReadyStateTimer, SIGNAL(timeout()), this, SIGNAL(deviceReady())); 



Definition at line 30 of file mdtDevice.cpp.



\subsection{Member Function Documentation}
\hypertarget{classmdt_device_abab1b6e45af527880ce469ae318474c0}{
\index{mdtDevice@{mdtDevice}!connectToDevice@{connectToDevice}}
\index{connectToDevice@{connectToDevice}!mdtDevice@{mdtDevice}}
\subsubsection[{connectToDevice}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtDevice::connectToDevice (
\begin{DoxyParamCaption}
\item[{const {\bf mdtDeviceInfo} \&}]{devInfo}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_device_abab1b6e45af527880ce469ae318474c0}


Search and connect to physical device. 

Will scan available ports and open the first port that has device attached maching request.


\begin{DoxyParams}{Parameters}
{\em devInfo} & Requested device's informations. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A error listed in \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} (NoError on success)
\end{DoxyReturn}
Note: default implementation does nothing and returns allways a UnhandledError. See subclass documentation for more details. 

Reimplemented in \hyperlink{classmdt_device_d_s_o1000_a_a84431cf929750a8a25d5218893736c72}{mdtDeviceDSO1000A}, \hyperlink{classmdt_device_modbus_wago_a025f0411a708a529054a0e3c0b6461cd}{mdtDeviceModbusWago}, \hyperlink{classmdt_device_scpi_ae8e886b362cbf9d1bf7064b48348b8e8}{mdtDeviceScpi}, and \hyperlink{classmdt_device_u3606_a_acf3b48b13bc179ad4f94b3011b7d607a}{mdtDeviceU3606A}.



Definition at line 68 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a5556423c2e2b3a3adcca5d4efb5af04e}{
\index{mdtDevice@{mdtDevice}!decodeReadenFrame@{decodeReadenFrame}}
\index{decodeReadenFrame@{decodeReadenFrame}!mdtDevice@{mdtDevice}}
\subsubsection[{decodeReadenFrame}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::decodeReadenFrame (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction}}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual, slot\mbox{]}}}}
\label{classmdt_device_a5556423c2e2b3a3adcca5d4efb5af04e}


Decode incoming frames. 

Subclass notes:\par

\begin{DoxyItemize}
\item This default implementation does nothing.
\item This slot should be connected with \hyperlink{classmdt_port_manager_a915ff3372cccd5f412b828cc81a3381f}{mdtPortManager::newReadenFrame(mdtPortTransaction)} signal.
\item In this class, this connection is not made, it is the sublcass responsability to do this.
\item To update (G)UI, \hyperlink{classmdt_device_ios_a82850ee99957ec5a787de71299ad785b}{mdtDeviceIos::updateAnalogInputValues()} should be used. 
\end{DoxyItemize}

Definition at line 777 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a585cc32f6aac4d5788928ecf1fdacf51}{
\index{mdtDevice@{mdtDevice}!getAnalogInputs@{getAnalogInputs}}
\index{getAnalogInputs@{getAnalogInputs}!mdtDevice@{mdtDevice}}
\subsubsection[{getAnalogInputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::getAnalogInputs (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a585cc32f6aac4d5788928ecf1fdacf51}


Read all analog inputs on physical device and update (G)UI representation. 

Will call \hyperlink{classmdt_device_a40674e7bf0c367bb3edb407d73a5bd8e}{readAnalogInputs()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_a40674e7bf0c367bb3edb407d73a5bd8e}{readAnalogInputs()} for details).

Once results are available, the internal analog inputs are updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em timeout} & If 0, the request is sent and this method returns immediately. Else it will wait until a reply comes in, or timeout. (See \hyperlink{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{waitTransactionDone()} ). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout ar other error, a value $<$ 0 is returned. 
\end{DoxyReturn}


setStateFromPortError(transactionId);

setStateFromPortError(transactionId); 



Definition at line 211 of file mdtDevice.cpp.

\hypertarget{classmdt_device_ab28a8276ce07524c351b8e9ebdc6ce1e}{
\index{mdtDevice@{mdtDevice}!getAnalogInputValue@{getAnalogInputValue}}
\index{getAnalogInputValue@{getAnalogInputValue}!mdtDevice@{mdtDevice}}
\subsubsection[{getAnalogInputValue}]{\setlength{\rightskip}{0pt plus 5cm}QVariant mdtDevice::getAnalogInputValue (
\begin{DoxyParamCaption}
\item[{int}]{address, }
\item[{bool}]{realValue, }
\item[{bool}]{queryDevice, }
\item[{bool}]{waitOnReply}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_ab28a8276ce07524c351b8e9ebdc6ce1e}


Read one analog input on physical device and update (G)UI representation. 

Will call \hyperlink{classmdt_device_acecf7934ce29b3a957accb0f4c98c746}{readAnalogInput()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_acecf7934ce29b3a957accb0f4c98c746}{readAnalogInput()} for details).

Once result is available, the internal analog input is updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em address} & Depending on device organisation and protocol, this can be a relative or absolute address (f.ex. MODBUS queries), a input number, etc... \\
\hline
{\em realValue} & If true, the real value (as double) is returned, else the device's specific integer value (see \hyperlink{classmdt_analog_io_a55d3e346dd13a580dc4ac77e8e946b01}{mdtAnalogIo::value()} for details). \\
\hline
{\em queryDevice} & If true, value is readen from device, else cached value is returned. \\
\hline
{\em waitOnReply} & If true, this method will wait until reply comes in, or timeout (See \hyperlink{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{waitTransactionDone()} ), else it will return immediately after the query was sent.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A valid value if timeout is $>$ 0 and on successfull query/reply process. (See the Qt's QVariant documentation to know how to check validity). 
\end{DoxyReturn}


setStateFromPortError(transactionId); \begin{Desc}
\item[\hyperlink{todo__todo000003}{Todo}]Restore transaction ??? \end{Desc}


setStateFromPortError(transactionId); 



Definition at line 147 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a12f717202e9860d0c24b9dff8d672ef8}{
\index{mdtDevice@{mdtDevice}!getAnalogOutputs@{getAnalogOutputs}}
\index{getAnalogOutputs@{getAnalogOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{getAnalogOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::getAnalogOutputs (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a12f717202e9860d0c24b9dff8d672ef8}


Read all analog outputs on physical device and update (G)UI representation. 

Will call \hyperlink{classmdt_device_ab0232ac83c38bc93d3bc2aa91d94c291}{readAnalogOutputs()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_ab0232ac83c38bc93d3bc2aa91d94c291}{readAnalogOutputs()} for details).

Once results are available, the internal analog outputs are updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em timeout} & If 0, the request is sent and this method returns immediately. Else it will wait until a reply comes in, or timeout. (See \hyperlink{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{waitTransactionDone()} ). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout ar other error, a value $<$ 0 is returned. 
\end{DoxyReturn}


setStateFromPortError(transactionId);

setStateFromPortError(transactionId); 



Definition at line 307 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a7085491cf2d96fd2afd3004de6caef0d}{
\index{mdtDevice@{mdtDevice}!getAnalogOutputValue@{getAnalogOutputValue}}
\index{getAnalogOutputValue@{getAnalogOutputValue}!mdtDevice@{mdtDevice}}
\subsubsection[{getAnalogOutputValue}]{\setlength{\rightskip}{0pt plus 5cm}QVariant mdtDevice::getAnalogOutputValue (
\begin{DoxyParamCaption}
\item[{int}]{address, }
\item[{int}]{timeout, }
\item[{bool}]{realValue = {\ttfamily true}}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a7085491cf2d96fd2afd3004de6caef0d}


Read one analog output on physical device and update (G)UI representation. 

Will call \hyperlink{classmdt_device_a7934063c3f41a742515f1232c9598c2a}{readAnalogOutput()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_a7934063c3f41a742515f1232c9598c2a}{readAnalogOutput()} for details).

Once result is available, the internal analog output is updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em address} & Depending on device organisation and protocol, this can be a relative or absolute address (f.ex. MODBUS queries), a input number, etc... \\
\hline
{\em timeout} & If 0, the request is sent and this method returns immediately. If $<$ 0, no query is sent to device and cached value is returned. Else it will wait until a reply comes in, or timeout. (See \hyperlink{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{waitTransactionDone()} ). \\
\hline
{\em realValue} & If true, the real value (as double) is returned, else the device's specific integer value (see \hyperlink{classmdt_analog_io_a55d3e346dd13a580dc4ac77e8e946b01}{mdtAnalogIo::value()} for details). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A valid value if timeout is $>$ 0 and on successfull query/reply process. (See the Qt's QVariant documentation to know how to check validity). 
\end{DoxyReturn}


setStateFromPortError(transactionId);

setStateFromPortError(transactionId); 



Definition at line 248 of file mdtDevice.cpp.

\hypertarget{classmdt_device_ae482b28263b2ce61735f42f1245c1e99}{
\index{mdtDevice@{mdtDevice}!getDigitalInputs@{getDigitalInputs}}
\index{getDigitalInputs@{getDigitalInputs}!mdtDevice@{mdtDevice}}
\subsubsection[{getDigitalInputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::getDigitalInputs (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_ae482b28263b2ce61735f42f1245c1e99}


Read all digital inputs on physical device and update (G)UI representation. 

Will call \hyperlink{classmdt_device_a150e3abae6db5bf1ad11017bf2b76c14}{readDigitalInputs()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_a150e3abae6db5bf1ad11017bf2b76c14}{readDigitalInputs()} for details).

Once results are available, the internal digital inputs are updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em timeout} & If 0, the request is sent and this method returns immediately. Else it will wait until a reply comes in, or timeout. (See \hyperlink{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{waitTransactionDone()} ). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout ar other error, a value $<$ 0 is returned. 
\end{DoxyReturn}


setStateFromPortError(transactionId);

setStateFromPortError(transactionId); 



Definition at line 491 of file mdtDevice.cpp.

\hypertarget{classmdt_device_aad589d5c8c769299fdf0ea4e34d3bc0a}{
\index{mdtDevice@{mdtDevice}!getDigitalInputState@{getDigitalInputState}}
\index{getDigitalInputState@{getDigitalInputState}!mdtDevice@{mdtDevice}}
\subsubsection[{getDigitalInputState}]{\setlength{\rightskip}{0pt plus 5cm}QVariant mdtDevice::getDigitalInputState (
\begin{DoxyParamCaption}
\item[{int}]{address, }
\item[{int}]{timeout}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_aad589d5c8c769299fdf0ea4e34d3bc0a}


Read one digital input on physical device and update (G)UI representation. 

Will call \hyperlink{classmdt_device_af128b606050035abaf8d049bb2227015}{readDigitalInput()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_af128b606050035abaf8d049bb2227015}{readDigitalInput()} for details).

Once result is available, the internal digital input is updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em address} & Depending on device organisation and protocol, this can be a relative or absolute address (f.ex. MODBUS queries), a input number, etc... \\
\hline
{\em timeout} & If 0, the request is sent and this method returns immediately. If $<$ 0, no query will be sent to device and the cached state is returned. Else it will wait until a reply comes in, or timeout. (See \hyperlink{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{waitTransactionDone()} ). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A valid state if timeout is $>$ 0 and on successfull query/reply process. (See the Qt's QVariant documentation to know how to check validity). 
\end{DoxyReturn}


setStateFromPortError(transactionId);

setStateFromPortError(transactionId); 



Definition at line 441 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a6bd6ad4f8d07121dd8b988594927e9c8}{
\index{mdtDevice@{mdtDevice}!getDigitalOutputs@{getDigitalOutputs}}
\index{getDigitalOutputs@{getDigitalOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{getDigitalOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::getDigitalOutputs (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a6bd6ad4f8d07121dd8b988594927e9c8}


Read all digital outputs on physical device and update (G)UI representation. 

Will call \hyperlink{classmdt_device_aac038c24c3b91757584bdf0d09fb8b02}{readDigitalOutputs()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_aac038c24c3b91757584bdf0d09fb8b02}{readDigitalOutputs()} for details).

Once results are available, the internal digital outputs are updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em timeout} & If 0, the request is sent and this method returns immediately. Else it will wait until a reply comes in, or timeout. (See \hyperlink{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{waitTransactionDone()} ). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout ar other error, a value $<$ 0 is returned. 
\end{DoxyReturn}


setStateFromPortError(transactionId);

setStateFromPortError(transactionId); 



Definition at line 578 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a719401fec13501047ffdf7f51583937c}{
\index{mdtDevice@{mdtDevice}!getDigitalOutputState@{getDigitalOutputState}}
\index{getDigitalOutputState@{getDigitalOutputState}!mdtDevice@{mdtDevice}}
\subsubsection[{getDigitalOutputState}]{\setlength{\rightskip}{0pt plus 5cm}QVariant mdtDevice::getDigitalOutputState (
\begin{DoxyParamCaption}
\item[{int}]{address, }
\item[{int}]{timeout}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a719401fec13501047ffdf7f51583937c}


Read one digital output on physical device and update (G)UI representation. 

Will call \hyperlink{classmdt_device_a1faee6ab31b094731211ea0943544501}{readDigitalOutput()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_a1faee6ab31b094731211ea0943544501}{readDigitalOutput()} for details).

Once result is available, the internal digital output is updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em address} & Depending on device organisation and protocol, this can be a relative or absolute address (f.ex. MODBUS queries), a input number, etc... \\
\hline
{\em timeout} & If 0, the request is sent and this method returns immediately. If $<$ 0, no query will be sent to device and the cached state is returned. Else it will wait until a reply comes in, or timeout. (See \hyperlink{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{waitTransactionDone()} ). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A valid state if timeout is $>$ 0 and on successfull query/reply process. (See the Qt's QVariant documentation to know how to check validity). 
\end{DoxyReturn}


setStateFromPortError(transactionId);

setStateFromPortError(transactionId); 



Definition at line 528 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a0e57cc8b749581cff447d514b9a1ff8e}{
\index{mdtDevice@{mdtDevice}!getNewTransaction@{getNewTransaction}}
\index{getNewTransaction@{getNewTransaction}!mdtDevice@{mdtDevice}}
\subsubsection[{getNewTransaction}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortTransaction} $\ast$ mdtDevice::getNewTransaction (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_device_a0e57cc8b749581cff447d514b9a1ff8e}


Get a new transaction. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}{mdtPortManager::getNewTransaction()}
\end{DoxySeeAlso}
\begin{DoxyPrecond}{Precondition}
portManager must be set before calling this method 
\end{DoxyPrecond}


Definition at line 842 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a06d9178b4133fd7b23084e712af20976}{
\index{mdtDevice@{mdtDevice}!portManager@{portManager}}
\index{portManager@{portManager}!mdtDevice@{mdtDevice}}
\subsubsection[{portManager}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortManager} $\ast$ mdtDevice::portManager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_device_a06d9178b4133fd7b23084e712af20976}


Get internal port manager instance. 

Note that port manager is set by subclass, and that a Null pointer can be returned. (See subclass documentation for details) 

Reimplemented in \hyperlink{classmdt_device_modbus_aed892b501f8cbd372ccfda1a4fafa536}{mdtDeviceModbus}, and \hyperlink{classmdt_device_scpi_a7dc5ab8856a766a45bcc7e9cba0f54ca}{mdtDeviceScpi}.



Definition at line 129 of file mdtDevice.cpp.

\hypertarget{classmdt_device_acba50968d201ad95c4eaa2ab2ed48b4f}{
\index{mdtDevice@{mdtDevice}!queriesSequence@{queriesSequence}}
\index{queriesSequence@{queriesSequence}!mdtDevice@{mdtDevice}}
\subsubsection[{queriesSequence}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtDevice::queriesSequence (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_acba50968d201ad95c4eaa2ab2ed48b4f}


Sequence of queries to send periodically. 

This method is called from \hyperlink{classmdt_device_a14634fec6cd6bae810562b3bd88a5c05}{runQueries()}.

\begin{DoxyReturn}{Returns}
true if all queries are sent successfully.
\end{DoxyReturn}
Subclass notes:\par

\begin{DoxyItemize}
\item This default implementation does nothing and allways returns false.
\item This method can be reimplemented periodic queries must be sent to device. 
\end{DoxyItemize}

Reimplemented in \hyperlink{classmdt_device_modbus_a3b83b926ed1f9c3bdf7024de2745c285}{mdtDeviceModbus}.



Definition at line 762 of file mdtDevice.cpp.

\hypertarget{classmdt_device_acecf7934ce29b3a957accb0f4c98c746}{
\index{mdtDevice@{mdtDevice}!readAnalogInput@{readAnalogInput}}
\index{readAnalogInput@{readAnalogInput}!mdtDevice@{mdtDevice}}
\subsubsection[{readAnalogInput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readAnalogInput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_acecf7934ce29b3a957accb0f4c98c746}


Read one analog input on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from getAnalogInput().


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details). 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_aa2a024793ae2a5e81c7e92260a70cd9e}{mdtDeviceModbus}.



Definition at line 781 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a40674e7bf0c367bb3edb407d73a5bd8e}{
\index{mdtDevice@{mdtDevice}!readAnalogInputs@{readAnalogInputs}}
\index{readAnalogInputs@{readAnalogInputs}!mdtDevice@{mdtDevice}}
\subsubsection[{readAnalogInputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readAnalogInputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_a40674e7bf0c367bb3edb407d73a5bd8e}


Read all analog inputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a585cc32f6aac4d5788928ecf1fdacf51}{getAnalogInputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a846af6dbf80bbf747f3f966420ef6f92}{mdtDeviceModbus}.



Definition at line 786 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a7934063c3f41a742515f1232c9598c2a}{
\index{mdtDevice@{mdtDevice}!readAnalogOutput@{readAnalogOutput}}
\index{readAnalogOutput@{readAnalogOutput}!mdtDevice@{mdtDevice}}
\subsubsection[{readAnalogOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readAnalogOutput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_a7934063c3f41a742515f1232c9598c2a}


Read one analog output on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a7085491cf2d96fd2afd3004de6caef0d}{getAnalogOutputValue()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a30c815cbe5e603e8114dcbc09849e322}{mdtDeviceModbus}.



Definition at line 791 of file mdtDevice.cpp.

\hypertarget{classmdt_device_ab0232ac83c38bc93d3bc2aa91d94c291}{
\index{mdtDevice@{mdtDevice}!readAnalogOutputs@{readAnalogOutputs}}
\index{readAnalogOutputs@{readAnalogOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{readAnalogOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readAnalogOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_ab0232ac83c38bc93d3bc2aa91d94c291}


Read all analog outputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a7085491cf2d96fd2afd3004de6caef0d}{getAnalogOutputValue()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_ae02dd44f1d873fcc15ff75d781b62b0b}{mdtDeviceModbus}.



Definition at line 796 of file mdtDevice.cpp.

\hypertarget{classmdt_device_af128b606050035abaf8d049bb2227015}{
\index{mdtDevice@{mdtDevice}!readDigitalInput@{readDigitalInput}}
\index{readDigitalInput@{readDigitalInput}!mdtDevice@{mdtDevice}}
\subsubsection[{readDigitalInput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readDigitalInput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_af128b606050035abaf8d049bb2227015}


Read one digital input on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_aad589d5c8c769299fdf0ea4e34d3bc0a}{getDigitalInputState()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a9dd05e51223ee5bb79970fbe84c501f9}{mdtDeviceModbus}.



Definition at line 811 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a150e3abae6db5bf1ad11017bf2b76c14}{
\index{mdtDevice@{mdtDevice}!readDigitalInputs@{readDigitalInputs}}
\index{readDigitalInputs@{readDigitalInputs}!mdtDevice@{mdtDevice}}
\subsubsection[{readDigitalInputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readDigitalInputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_a150e3abae6db5bf1ad11017bf2b76c14}


Read all digital inputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_ae482b28263b2ce61735f42f1245c1e99}{getDigitalInputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a3fba9e113092f9da187cf684fb62b132}{mdtDeviceModbus}.



Definition at line 816 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a1faee6ab31b094731211ea0943544501}{
\index{mdtDevice@{mdtDevice}!readDigitalOutput@{readDigitalOutput}}
\index{readDigitalOutput@{readDigitalOutput}!mdtDevice@{mdtDevice}}
\subsubsection[{readDigitalOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readDigitalOutput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_a1faee6ab31b094731211ea0943544501}


Read one digital output on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a719401fec13501047ffdf7f51583937c}{getDigitalOutputState()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a13a334ac86135751893f37064d8f548d}{mdtDeviceModbus}.



Definition at line 821 of file mdtDevice.cpp.

\hypertarget{classmdt_device_aac038c24c3b91757584bdf0d09fb8b02}{
\index{mdtDevice@{mdtDevice}!readDigitalOutputs@{readDigitalOutputs}}
\index{readDigitalOutputs@{readDigitalOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{readDigitalOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readDigitalOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_aac038c24c3b91757584bdf0d09fb8b02}


Read all digital outputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a6bd6ad4f8d07121dd8b988594927e9c8}{getDigitalOutputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a8915a036472bff0f356756992c1eae51}{mdtDeviceModbus}.



Definition at line 826 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a4619d8be240cafe48865a89f7424de92}{
\index{mdtDevice@{mdtDevice}!restoreTransaction@{restoreTransaction}}
\index{restoreTransaction@{restoreTransaction}!mdtDevice@{mdtDevice}}
\subsubsection[{restoreTransaction}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::restoreTransaction (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_device_a4619d8be240cafe48865a89f7424de92}


Restore a transaction into pool. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}{mdtPortManager::restoreTransaction()}
\end{DoxySeeAlso}
\begin{DoxyPrecond}{Precondition}
portManager must be set before calling this method 
\end{DoxyPrecond}


Definition at line 849 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a14634fec6cd6bae810562b3bd88a5c05}{
\index{mdtDevice@{mdtDevice}!runQueries@{runQueries}}
\index{runQueries@{runQueries}!mdtDevice@{mdtDevice}}
\subsubsection[{runQueries}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::runQueries (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}slot\mbox{]}}}}
\label{classmdt_device_a14634fec6cd6bae810562b3bd88a5c05}


Queries to send periodically. 

This slot is periodically called after a call of \hyperlink{classmdt_device_a721c5bf2cfa0eef5304333f08da182f7}{start()}. 

Definition at line 753 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a3477278b4fa937f7667becb14333ef2f}{
\index{mdtDevice@{mdtDevice}!setAnalogOutputAddressOffset@{setAnalogOutputAddressOffset}}
\index{setAnalogOutputAddressOffset@{setAnalogOutputAddressOffset}!mdtDevice@{mdtDevice}}
\subsubsection[{setAnalogOutputAddressOffset}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::setAnalogOutputAddressOffset (
\begin{DoxyParamCaption}
\item[{int}]{offset}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a3477278b4fa937f7667becb14333ef2f}


Set analog output address offset. 

Some devices has a offset for output addresses. F.ex. the Wago 750 system has a offset of 0x0200 

Definition at line 119 of file mdtDevice.cpp.

\hypertarget{classmdt_device_ae45c39c2ef38b5952171fdc1c3284748}{
\index{mdtDevice@{mdtDevice}!setAnalogOutputs@{setAnalogOutputs}}
\index{setAnalogOutputs@{setAnalogOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{setAnalogOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::setAnalogOutputs (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_ae45c39c2ef38b5952171fdc1c3284748}


Write all analog outputs on physical device and update (G)UI representation. 

To send the analog outputs values once, it's possible to set them without sending query. See \hyperlink{classmdt_device_ios}{mdtDeviceIos} and \hyperlink{classmdt_analog_io}{mdtAnalogIo} for details. Then, call this method to sent all analog outputs values to device.

\hyperlink{classmdt_device_abc52b797df29945bf0a6358aab1b7245}{writeAnalogOutputs()} will be called, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_abc52b797df29945bf0a6358aab1b7245}{writeAnalogOutputs()} for details).

Once results are available, the internal analog outputs are updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em timeout} & If 0, the request is sent and this method returns immediately. Else it will wait until a reply comes in, or timeout. (See \hyperlink{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{waitTransactionDone()} ). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout ar other error, a value $<$ 0 is returned. 
\end{DoxyReturn}


setStateFromPortError(transactionId);

setStateFromPortError(transactionId); 



Definition at line 405 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a40234a70a37b097baa48bdfbb402cdc4}{
\index{mdtDevice@{mdtDevice}!setAnalogOutputValue@{setAnalogOutputValue}}
\index{setAnalogOutputValue@{setAnalogOutputValue}!mdtDevice@{mdtDevice}}
\subsubsection[{setAnalogOutputValue}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::setAnalogOutputValue (
\begin{DoxyParamCaption}
\item[{int}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}slot\mbox{]}}}}
\label{classmdt_device_a40234a70a37b097baa48bdfbb402cdc4}


Set value on a analog output on physical device. 

Checks device's state and send request if Ready.

This slot is used by \hyperlink{classmdt_device_ios}{mdtDeviceIos} to notify that a value has changed.

Will call \hyperlink{classmdt_device_ae764634bba2b321ac2b4731c0353e45f}{writeAnalogOutput()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_ae764634bba2b321ac2b4731c0353e45f}{writeAnalogOutput()} for details).

Once result is available, the internal analog output is updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em address} & Depending on device organisation and protocol, this can be a relative or absolute address (f.ex. MODBUS queries), a output number, etc... \\
\hline
\end{DoxyParams}


Definition at line 707 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a4b01925cfbbb62e32a3e85a9c4b1538a}{
\index{mdtDevice@{mdtDevice}!setAnalogOutputValue@{setAnalogOutputValue}}
\index{setAnalogOutputValue@{setAnalogOutputValue}!mdtDevice@{mdtDevice}}
\subsubsection[{setAnalogOutputValue}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::setAnalogOutputValue (
\begin{DoxyParamCaption}
\item[{int}]{address, }
\item[{QVariant}]{value, }
\item[{int}]{timeout}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a4b01925cfbbb62e32a3e85a9c4b1538a}


Write one analog output to physical device and update (G)UI representation. 

Will call \hyperlink{classmdt_device_ae764634bba2b321ac2b4731c0353e45f}{writeAnalogOutput()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_ae764634bba2b321ac2b4731c0353e45f}{writeAnalogOutput()} for details).

Once result is available, the internal analog output is updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em timeout} & If 0, the request is sent and this method returns immediately. If $<$ 0, the analog output is updated, but no query is sent to device. Else it will wait until a reply comes in, or timeout. (See \hyperlink{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{waitTransactionDone()} ). \\
\hline
{\em value} & The value to set. If type is a integer, value will be passed as is. If type is bool, it will be converted by \hyperlink{classmdt_analog_io}{mdtAnalogIo}. \\
\hline
{\em address} & Depending on device organisation and protocol, this can be a relative or absolute address (f.ex. MODBUS queries), a output number, etc... \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout, on invalid value or other error, a value $<$ 0 is returned. 
\end{DoxyReturn}


setStateFromPortError(transactionId);

setStateFromPortError(transactionId); 



Definition at line 345 of file mdtDevice.cpp.

\hypertarget{classmdt_device_aa241c40514683254990e742cf1bbb155}{
\index{mdtDevice@{mdtDevice}!setBackToReadyStateTimeout@{setBackToReadyStateTimeout}}
\index{setBackToReadyStateTimeout@{setBackToReadyStateTimeout}!mdtDevice@{mdtDevice}}
\subsubsection[{setBackToReadyStateTimeout}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::setBackToReadyStateTimeout (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_aa241c40514683254990e742cf1bbb155}


Set back to ready state timeout. 

After some event (device disconnected, response timeout, ...) the state can be changed from Ready to another.

Note: if state is different than Ready, the slots \hyperlink{classmdt_device_a40234a70a37b097baa48bdfbb402cdc4}{setAnalogOutputValue(int)} and \hyperlink{classmdt_device_a83b170f1805a05101409bb6d8e15d03a}{setDigitalOutputState(int)} will return immediately, without trying to send a request.

In some application, it can be usefull that state comes back automatically to ready.


\begin{DoxyParams}{Parameters}
{\em timeout} & Time before go back to ready state \mbox{[}ms\mbox{]} If timeout is $<$ 0, device still in current state, and setStateReady() can be used. \\
\hline
\end{DoxyParams}


Definition at line 114 of file mdtDevice.cpp.

\hypertarget{classmdt_device_af5c2759221878a4d0306343f43e3cc45}{
\index{mdtDevice@{mdtDevice}!setDigitalOutputAddressOffset@{setDigitalOutputAddressOffset}}
\index{setDigitalOutputAddressOffset@{setDigitalOutputAddressOffset}!mdtDevice@{mdtDevice}}
\subsubsection[{setDigitalOutputAddressOffset}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::setDigitalOutputAddressOffset (
\begin{DoxyParamCaption}
\item[{int}]{offset}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_af5c2759221878a4d0306343f43e3cc45}


Set digital output address offset. 

Some devices has a offset for output addresses. F.ex. the Wago 750 system has a offset of 0x0200 

Definition at line 124 of file mdtDevice.cpp.

\hypertarget{classmdt_device_ae68a400d5f27fe142d41b674f473bf98}{
\index{mdtDevice@{mdtDevice}!setDigitalOutputs@{setDigitalOutputs}}
\index{setDigitalOutputs@{setDigitalOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{setDigitalOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::setDigitalOutputs (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_ae68a400d5f27fe142d41b674f473bf98}


Write all digital outputs to physical device and update (G)UI representation. 

To send the digital outputs states once, it's possible to set them without sending query. See \hyperlink{classmdt_device_ios}{mdtDeviceIos} and \hyperlink{classmdt_digital_io}{mdtDigitalIo} for details. Then, call this method to sent all digital outputs states to device.

\hyperlink{classmdt_device_aa9e8ae7b4ff2455b4105d280d8523fc1}{writeDigitalOutputs()} will be called, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_aa9e8ae7b4ff2455b4105d280d8523fc1}{writeDigitalOutputs()} for details).

Once results are available, the internal digital outputs are updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em timeout} & If 0, the request is sent and this method returns immediately. Else it will wait until a reply comes in, or timeout. (See \hyperlink{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{waitTransactionDone()} ). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout ar other error, a value $<$ 0 is returned. 
\end{DoxyReturn}


setStateFromPortError(transactionId);

setStateFromPortError(transactionId); 



Definition at line 668 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a702a5f49680b03f04a9f58ae6906bf83}{
\index{mdtDevice@{mdtDevice}!setDigitalOutputState@{setDigitalOutputState}}
\index{setDigitalOutputState@{setDigitalOutputState}!mdtDevice@{mdtDevice}}
\subsubsection[{setDigitalOutputState}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::setDigitalOutputState (
\begin{DoxyParamCaption}
\item[{int}]{address, }
\item[{bool}]{state, }
\item[{int}]{timeout}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a702a5f49680b03f04a9f58ae6906bf83}


Write one digital output to physical device and update (G)UI representation. 

Will call \hyperlink{classmdt_device_a0fbe57503d86554829e708b2b83d73f1}{writeDigitalOutput()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_a0fbe57503d86554829e708b2b83d73f1}{writeDigitalOutput()} for details).

Once result is available, the internal digital output is updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em state} & The state (ON/OFF) to set. \\
\hline
{\em address} & Depending on device organisation and protocol, this can be a relative or absolute address (f.ex. MODBUS queries), a output number, etc... \\
\hline
{\em timeout} & If 0, the request is sent and this method returns immediately. If $<$ 0, the digital output is updated, but no query is sent to device. Else it will wait until a reply comes in, or timeout. (See \hyperlink{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{waitTransactionDone()} ). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout, on invalid value or other error, a value $<$ 0 is returned. 
\end{DoxyReturn}


qDebug() $<$$<$ \char`\"{}mdtDevice::setDigitalOutputState(): Out \char`\"{} $<$$<$ address $<$$<$ \char`\"{} : \char`\"{} $<$$<$ dout-\/$>$isOn();

qDebug() $<$$<$ \char`\"{}mdtDevice::setDigitalOutputState(): Out \char`\"{} $<$$<$ address $<$$<$ \char`\"{} : \char`\"{} $<$$<$ dout-\/$>$isOn();

setStateFromPortError(transactionId);

setStateFromPortError(transactionId); 



Definition at line 615 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a83b170f1805a05101409bb6d8e15d03a}{
\index{mdtDevice@{mdtDevice}!setDigitalOutputState@{setDigitalOutputState}}
\index{setDigitalOutputState@{setDigitalOutputState}!mdtDevice@{mdtDevice}}
\subsubsection[{setDigitalOutputState}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::setDigitalOutputState (
\begin{DoxyParamCaption}
\item[{int}]{address}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}slot\mbox{]}}}}
\label{classmdt_device_a83b170f1805a05101409bb6d8e15d03a}


Set state on a digital output on physical device. 

Checks device's state and send request if Ready.

This slot is used by \hyperlink{classmdt_device_ios}{mdtDeviceIos} to notify that a state has changed.

Will call \hyperlink{classmdt_device_a0fbe57503d86554829e708b2b83d73f1}{writeDigitalOutput()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_a0fbe57503d86554829e708b2b83d73f1}{writeDigitalOutput()} for details).

Once result is available, the internal digital output is updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em address} & Depending on device organisation and protocol, this can be a relative or absolute address (f.ex. MODBUS queries), a output number, etc... \\
\hline
\end{DoxyParams}


Definition at line 730 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{
\index{mdtDevice@{mdtDevice}!setIos@{setIos}}
\index{setIos@{setIos}!mdtDevice@{mdtDevice}}
\subsubsection[{setIos}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::setIos (
\begin{DoxyParamCaption}
\item[{{\bf mdtDeviceIos} $\ast$}]{ios, }
\item[{bool}]{autoOutputUpdate = {\ttfamily false}}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}


Set the I/O's container. 


\begin{DoxyParams}{Parameters}
{\em ios} & A pointer to a \hyperlink{classmdt_device_ios}{mdtDeviceIos} object \\
\hline
{\em autoOutputUpdate} & If true, \hyperlink{classmdt_analog_io_ad658090469cc6b69fa92d9bca73d8a16}{mdtAnalogIo::valueChanged()} signal will be connected to setAnalogOutputValue(int, int) slot for each analog output and \hyperlink{classmdt_digital_io_a69c20119906682c0bd90833598127328}{mdtDigitalIo::stateChanged()} signal will be connected to setDigitalOutputState(int, bool) slot for each digital output.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
ios must be a valid pointer 
\end{DoxyPrecond}


Definition at line 73 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a52a13e5692fccb5aea1f7c3c991823f3}{
\index{mdtDevice@{mdtDevice}!showStatusMessage@{showStatusMessage}}
\index{showStatusMessage@{showStatusMessage}!mdtDevice@{mdtDevice}}
\subsubsection[{showStatusMessage}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::showStatusMessage (
\begin{DoxyParamCaption}
\item[{const QString \&}]{message, }
\item[{const QString \&}]{details, }
\item[{int}]{timeout = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}slot\mbox{]}}}}
\label{classmdt_device_a52a13e5692fccb5aea1f7c3c991823f3}


Used to show a message and details in status bar. 


\begin{DoxyParams}{Parameters}
{\em message} & Message to show \\
\hline
{\em details} & Details to show \\
\hline
{\em timeout} & If $>$ 0, message will be cleared after timeout \mbox{[}ms\mbox{]} \\
\hline
\end{DoxyParams}


Definition at line 772 of file mdtDevice.cpp.

\hypertarget{classmdt_device_aef41742272cbf069890ea95605f41d44}{
\index{mdtDevice@{mdtDevice}!showStatusMessage@{showStatusMessage}}
\index{showStatusMessage@{showStatusMessage}!mdtDevice@{mdtDevice}}
\subsubsection[{showStatusMessage}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::showStatusMessage (
\begin{DoxyParamCaption}
\item[{const QString \&}]{message, }
\item[{int}]{timeout = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}slot\mbox{]}}}}
\label{classmdt_device_aef41742272cbf069890ea95605f41d44}


Used to show a message in status bar. 


\begin{DoxyParams}{Parameters}
{\em message} & Message to show \\
\hline
{\em timeout} & If $>$ 0, message will be cleared after timeout \mbox{[}ms\mbox{]} \\
\hline
\end{DoxyParams}


Definition at line 767 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a721c5bf2cfa0eef5304333f08da182f7}{
\index{mdtDevice@{mdtDevice}!start@{start}}
\index{start@{start}!mdtDevice@{mdtDevice}}
\subsubsection[{start}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::start (
\begin{DoxyParamCaption}
\item[{int}]{queryInterval}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a721c5bf2cfa0eef5304333f08da182f7}


Start periodic device querying. 

Internally, the \hyperlink{classmdt_device_a14634fec6cd6bae810562b3bd88a5c05}{runQueries()} slot will be called each queryInterval of time.


\begin{DoxyParams}{Parameters}
{\em queryInterval} & Query interval \mbox{[}ms\mbox{]} \\
\hline
\end{DoxyParams}


Definition at line 134 of file mdtDevice.cpp.

\hypertarget{classmdt_device_aecd2d9d2cc3665f2084d0fd20eb3db2d}{
\index{mdtDevice@{mdtDevice}!stateChanged@{stateChanged}}
\index{stateChanged@{stateChanged}!mdtDevice@{mdtDevice}}
\subsubsection[{stateChanged}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::stateChanged (
\begin{DoxyParamCaption}
\item[{int}]{state}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_device_aecd2d9d2cc3665f2084d0fd20eb3db2d}


Emitted when state has changed. 

Typically used with mdtDeviceStatusWidget \hypertarget{classmdt_device_a3fbc6e71241e2e9daa2d8557f870c03c}{
\index{mdtDevice@{mdtDevice}!statusMessageChanged@{statusMessageChanged}}
\index{statusMessageChanged@{statusMessageChanged}!mdtDevice@{mdtDevice}}
\subsubsection[{statusMessageChanged}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::statusMessageChanged (
\begin{DoxyParamCaption}
\item[{const QString \&}]{message, }
\item[{const QString \&}]{details, }
\item[{int}]{timeout}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_device_a3fbc6e71241e2e9daa2d8557f870c03c}


Emitted when a new status message is to display. 

Typically used with mdtDeviceStatusWidget \hypertarget{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}{
\index{mdtDevice@{mdtDevice}!waitTransactionDone@{waitTransactionDone}}
\index{waitTransactionDone@{waitTransactionDone}!mdtDevice@{mdtDevice}}
\subsubsection[{waitTransactionDone}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtDevice::waitTransactionDone (
\begin{DoxyParamCaption}
\item[{int}]{id, }
\item[{int}]{timeout = {\ttfamily 0}, }
\item[{int}]{granularity = {\ttfamily 50}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_device_ab67f2da4f294482dd39ce6294ada8bc4}


Wait until a transaction is done without break the GUI's event loop. 

\begin{Desc}
\item[\hyperlink{todo__todo000005}{Todo}]Adapt, comment\end{Desc}


This is a helper method that provide a blocking wait. Internally, a couple of sleep and event processing is done, avoiding freesing the GUI.

Internally, \hyperlink{classmdt_port_manager_a680546498a0cd486c4fc16d28f44e4c6}{mdtPortManager::waitOnFrame()} is called.


\begin{DoxyParams}{Parameters}
{\em id} & Id returned by query method \\
\hline
{\em timeout} & Timeout \mbox{[}ms\mbox{]} If 0, device's defined read timeout is used (see \hyperlink{classmdt_port_manager_a680546498a0cd486c4fc16d28f44e4c6}{mdtPortManager::waitOnFrame(int, int, int)} for details). \\
\hline
{\em granularity} & Sleep time between each call of event processing \mbox{[}ms\mbox{]}\par
 A little value needs more CPU and big value can freese the GUI. Should be between 50 and 100, and must be $>$ 0. Note that msecs must be a multiple of granularity. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True on success, false on timeout. If id was not found in transactions list, a warning will be generated in \hyperlink{classmdt_error}{mdtError} system, and false will be returned. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
granularity must be $>$ 0. 
\end{DoxyPrecond}


Definition at line 856 of file mdtDevice.cpp.

\hypertarget{classmdt_device_ae764634bba2b321ac2b4731c0353e45f}{
\index{mdtDevice@{mdtDevice}!writeAnalogOutput@{writeAnalogOutput}}
\index{writeAnalogOutput@{writeAnalogOutput}!mdtDevice@{mdtDevice}}
\subsubsection[{writeAnalogOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::writeAnalogOutput (
\begin{DoxyParamCaption}
\item[{int}]{value, }
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_ae764634bba2b321ac2b4731c0353e45f}


Write value on a analog output to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a4b01925cfbbb62e32a3e85a9c4b1538a}{setAnalogOutputValue()}.


\begin{DoxyParams}{Parameters}
{\em value} & Value encoded regarding device format. \\
\hline
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_ac63297a31205759622f341525c34251f}{mdtDeviceModbus}.



Definition at line 801 of file mdtDevice.cpp.

\hypertarget{classmdt_device_abc52b797df29945bf0a6358aab1b7245}{
\index{mdtDevice@{mdtDevice}!writeAnalogOutputs@{writeAnalogOutputs}}
\index{writeAnalogOutputs@{writeAnalogOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{writeAnalogOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::writeAnalogOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_abc52b797df29945bf0a6358aab1b7245}


Write all analog outputs to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_ae45c39c2ef38b5952171fdc1c3284748}{setAnalogOutputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a87af02c83cede03d6ee988c678e0fc00}{mdtDeviceModbus}.



Definition at line 806 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a0fbe57503d86554829e708b2b83d73f1}{
\index{mdtDevice@{mdtDevice}!writeDigitalOutput@{writeDigitalOutput}}
\index{writeDigitalOutput@{writeDigitalOutput}!mdtDevice@{mdtDevice}}
\subsubsection[{writeDigitalOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::writeDigitalOutput (
\begin{DoxyParamCaption}
\item[{bool}]{state, }
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_a0fbe57503d86554829e708b2b83d73f1}


Write state on a digital output to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a702a5f49680b03f04a9f58ae6906bf83}{setDigitalOutputState()}.


\begin{DoxyParams}{Parameters}
{\em state} & State (ON/OFF). \\
\hline
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a6950c10fc521b193fb3c754223879694}{mdtDeviceModbus}.



Definition at line 831 of file mdtDevice.cpp.

\hypertarget{classmdt_device_aa9e8ae7b4ff2455b4105d280d8523fc1}{
\index{mdtDevice@{mdtDevice}!writeDigitalOutputs@{writeDigitalOutputs}}
\index{writeDigitalOutputs@{writeDigitalOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{writeDigitalOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::writeDigitalOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_aa9e8ae7b4ff2455b4105d280d8523fc1}


Write all digital outputs to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_ae68a400d5f27fe142d41b674f473bf98}{setDigitalOutputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_aad3ce85a19307e3056b940da99fe512b}{mdtDeviceModbus}.



Definition at line 836 of file mdtDevice.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtdevice/mdtDevice.h\item 
src/mdtdevice/mdtDevice.cpp\end{DoxyCompactItemize}
