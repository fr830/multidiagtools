\hypertarget{classmdt_port_manager}{
\section{mdtPortManager Class Reference}
\label{classmdt_port_manager}\index{mdtPortManager@{mdtPortManager}}
}


Port manager base class.  




{\ttfamily \#include $<$mdtPortManager.h$>$}



Inheritance diagram for mdtPortManager:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{classmdt_port_manager__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=310pt]{classmdt_port_manager__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382da}{state\_\-t} \{ \par
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daaf2ba40e19587c3a98235ee96a4acf20e}{Ready} =  0, 
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa4004253e25d51b1e628bb5006dbbd153}{Disconnected}, 
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa89e805c9c75c39ecc8371d5f38131227}{Connecting}, 
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa5da3fa5dd98a264ecb4a37a1983ea0ff}{Busy}, 
\par
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa8ca72085e29c5c6745294e58684e5d3c}{Warning}, 
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa687598301ad573e51cafaa209da72718}{Error}
 \}
\begin{DoxyCompactList}\small\item\em State of device. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Slots}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classmdt_port_manager_a1d185e9bb610aee16ccd9499ae7bff0d}{abort} ()
\begin{DoxyCompactList}\small\item\em Cancel read and write operations. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Signals}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_port_manager_a416a24db1048e9f66aef27ea810954d2}{newTransactionDone} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Try to. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a7f9437d084e136d8d265dace7431395f}{errorStateChanged} (int error, const QString \&message=QString(), const QString \&details=QString())
\begin{DoxyCompactList}\small\item\em Emitted when error number has changed. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a6f6c6f8a8430d8631a08c765565db9ab}{statusMessageChanged} (const QString \&message, const QString \&details, int timeout)
\begin{DoxyCompactList}\small\item\em Emitted when a new status message is to display. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a1c9e1848373831962b7ec83fd4fe5d35}{
void \hyperlink{classmdt_port_manager_a1c9e1848373831962b7ec83fd4fe5d35}{stateChanged} (int newState)}
\label{classmdt_port_manager_a1c9e1848373831962b7ec83fd4fe5d35}

\begin{DoxyCompactList}\small\item\em Emitted when state has changed. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a6095719fbd3967428d48e7f57f23c56e}{connecting} ()
\begin{DoxyCompactList}\small\item\em Connecting event. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ac6cfb9054c3b77689132dcf3a906eeb6}{disconnected} ()
\begin{DoxyCompactList}\small\item\em Disconnected event. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_afc4e88b2ade86ac13469bc0732c95f59}{ready} ()
\begin{DoxyCompactList}\small\item\em Device ready event event. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a0936c65454409ffcf64ecb0632f6dbe3}{busy} ()
\begin{DoxyCompactList}\small\item\em Device busy event event. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a30fac00920ab8d760df777f917183add}{handledError} ()
\begin{DoxyCompactList}\small\item\em Handled error event. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a75111efb0c8956ddc98a87a9aedec695}{unhandledError} ()
\begin{DoxyCompactList}\small\item\em Unhandled error event. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_port_manager_a5ec36523089b7528d973e29cdbc64d01}{mdtPortManager} (QObject $\ast$parent=0)
\begin{DoxyCompactList}\small\item\em Contruct a port manager. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_port_manager_adf797f8fd7a3ffdc000890a224e4c1b6}{$\sim$mdtPortManager} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
virtual QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}{scan} ()
\begin{DoxyCompactList}\small\item\em Scan for available ports. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort} (\hyperlink{classmdt_abstract_port}{mdtAbstractPort} $\ast$port)
\begin{DoxyCompactList}\small\item\em Set port object. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a39cb4af4aedc0b6b7c4d4f53002c3fd1}{detachPort} (bool deletePort, bool deleteThreads)
\begin{DoxyCompactList}\small\item\em Detach port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}{addThread} (\hyperlink{classmdt_port_thread}{mdtPortThread} $\ast$thread)
\begin{DoxyCompactList}\small\item\em Add a thread and assign it to port. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_thread}{mdtPortThread} $\ast$ \hyperlink{classmdt_port_manager_ad9233b5156a45f2684783317d75fdf9b}{readThread} ()
\begin{DoxyCompactList}\small\item\em Returns instance of reader thread. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_thread}{mdtPortThread} $\ast$ \hyperlink{classmdt_port_manager_af44b6e9876e6687b1d4fe7e05ffd5a91}{writeThread} ()
\begin{DoxyCompactList}\small\item\em Returns instance of writer thread. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_aaa0a474183bcae0fff4fb9ef43023c25}{removeThreads} (bool releaseMemory)
\begin{DoxyCompactList}\small\item\em Detach threads from port and remove threads. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{start} ()
\begin{DoxyCompactList}\small\item\em Start threads. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_af460167e604b8b6e2e933a98b2b6b5a2}{isRunning} ()
\begin{DoxyCompactList}\small\item\em Get the running state. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_aacbf87cc3d9c37c87e21696f8a6514bd}{stop} ()
\begin{DoxyCompactList}\small\item\em Stop threads. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}{setPortName} (const QString \&portName)
\begin{DoxyCompactList}\small\item\em Set port name. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a7e2ef93ec2731e66aa2b2d5f7ce9bc1c}{setPortInfo} (\hyperlink{classmdt_port_info}{mdtPortInfo} info)
\begin{DoxyCompactList}\small\item\em Set port info. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}{
\hyperlink{classmdt_port_info}{mdtPortInfo} \hyperlink{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}{portInfo} ()}
\label{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}

\begin{DoxyCompactList}\small\item\em Get current port info. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_af4fcab6aaad98d74aeabfc972da1d406}{
QString \hyperlink{classmdt_port_manager_af4fcab6aaad98d74aeabfc972da1d406}{portName} () const }
\label{classmdt_port_manager_af4fcab6aaad98d74aeabfc972da1d406}

\begin{DoxyCompactList}\small\item\em Get current port name. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_port_config}{mdtPortConfig} \& \hyperlink{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{config} ()
\begin{DoxyCompactList}\small\item\em Get the port's config object. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_config}{mdtPortConfig} \& \hyperlink{classmdt_port_manager_a735b7dc766fc2f45fb2cf9772c4201b0}{config} () const 
\begin{DoxyCompactList}\small\item\em Get the port's config object. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{openPort} ()
\begin{DoxyCompactList}\small\item\em Open the port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ace8065f1f5083041ee7f65c2892bc77d}{closePort} ()
\begin{DoxyCompactList}\small\item\em Close the port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a9adb5098766c9df588bc9978b00c5eb2}{setKeepTransactionsDone} (bool keep)
\begin{DoxyCompactList}\small\item\em Force transactions done to be keeped. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a798ce0939234870ae3b9995108e54380}{
bool \hyperlink{classmdt_port_manager_a798ce0939234870ae3b9995108e54380}{keepTransactionsDone} () const }
\label{classmdt_port_manager_a798ce0939234870ae3b9995108e54380}

\begin{DoxyCompactList}\small\item\em Get the keepTransactionsDone flag. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$ \hyperlink{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}{getNewTransaction} ()
\begin{DoxyCompactList}\small\item\em Get a new transaction. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}{restoreTransaction} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Restore a transaction into pool. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_a1ca92c5ac120d87e5b10bff54ed1aa5c}{waitOnWriteReady} (int timeout=0, int granularity=50)
\begin{DoxyCompactList}\small\item\em Wait until data can be written. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_port_manager_a328abc7f5f2677c19ea11567df6597da}{writeData} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write data to port. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_port_manager_a9b902a60c8b21585904bcb1d6e604369}{writeData} (const QByteArray \&data, bool queryReplyMode=false)
\begin{DoxyCompactList}\small\item\em Write data to port. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_aaa8845faa91904dba625fe7f1d23bc51}{waitTransactionDone} (int id, int timeout=0, int granularity=50)
\begin{DoxyCompactList}\small\item\em Wait until a transaction is done. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_aeb8a98c8bf4ce8279bd897dece6d731a}{waitOneTransactionDone} (int timeout=0, int granularity=50)
\begin{DoxyCompactList}\small\item\em Wait until current transaction is done. \end{DoxyCompactList}\item 
QByteArray \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame} (int id)
\begin{DoxyCompactList}\small\item\em Get data by frame ID. \end{DoxyCompactList}\item 
QList$<$ QByteArray $>$ \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames} ()
\begin{DoxyCompactList}\small\item\em Get all readen data. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_port_manager_a7cb3155940e23db0122d14f21fca858d}{adjustedReadTimeout} (int requestedTimeout, bool warn=true) const 
\begin{DoxyCompactList}\small\item\em Adjust a requested timeout to minimal timeout. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_port_manager_a9d6782be514745a1b1392216d17d41df}{adjustedWriteTimeout} (int requestedTimeout, bool warn=true) const 
\begin{DoxyCompactList}\small\item\em Adjust a requested timeout to minimal timeout. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_port_manager_ac0844a5cd4043a95a479d458ac7ce590}{flushIn} (bool flushPortManagerBuffers, bool flushPortBuffers)
\begin{DoxyCompactList}\small\item\em Flush input buffers. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a4c44ce6ec40c4afc6be441c10d7ee827}{flushIn} ()
\begin{DoxyCompactList}\small\item\em Flush input buffers. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_port_manager_a3f0c2722a41c49de2bea9013bccd049c}{flushOut} (bool flushPortManagerBuffers, bool flushPortBuffers)
\begin{DoxyCompactList}\small\item\em Flush output buffers. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ab34018a9653a5af784fa7da06a9e50d3}{flushOut} ()
\begin{DoxyCompactList}\small\item\em Flush output buffers. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a97b91e7c1641836eb6afb47fd244a18e}{flush} (bool flushPortManagerBuffers, bool flushPortBuffers)
\begin{DoxyCompactList}\small\item\em Flush I/O buffers. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a3eab774008d7530ae341ce9c38265d65}{flush} ()
\begin{DoxyCompactList}\small\item\em Flush I/O buffers. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a59241d9e6b6ee71e6c1aeb3e6c0ca81a}{
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382da}{state\_\-t} \hyperlink{classmdt_port_manager_a59241d9e6b6ee71e6c1aeb3e6c0ca81a}{currentState} () const }
\label{classmdt_port_manager_a59241d9e6b6ee71e6c1aeb3e6c0ca81a}

\begin{DoxyCompactList}\small\item\em Get current state. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classmdt_port_manager_acc5c63ad33fdd3cc153fc23e00c6e69c}{wait} (int msecs, int granularity=50)
\begin{DoxyCompactList}\small\item\em Wait some time without break the GUI's event loop. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Slots}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{fromThreadNewFrameReaden} ()
\begin{DoxyCompactList}\small\item\em Called by the read thread whenn a complete frame was readen. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}{onThreadsErrorOccured} (int error)
\begin{DoxyCompactList}\small\item\em Manage errors comming from port threads. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_port_manager_a3f1d25b2441c467c0de9908c73422a93}{
void \hyperlink{classmdt_port_manager_a3f1d25b2441c467c0de9908c73422a93}{setCurrentTransactionId} (int id)}
\label{classmdt_port_manager_a3f1d25b2441c467c0de9908c73422a93}

\begin{DoxyCompactList}\small\item\em Set the current transaction ID. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a19abf29c8948cde0337d67c9722c25aa}{
int \hyperlink{classmdt_port_manager_a19abf29c8948cde0337d67c9722c25aa}{currentTransactionId} () const }
\label{classmdt_port_manager_a19abf29c8948cde0337d67c9722c25aa}

\begin{DoxyCompactList}\small\item\em Get the current transaction ID. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a4d009936a0a5130f3bfecb69fee4ce42}{
void \hyperlink{classmdt_port_manager_a4d009936a0a5130f3bfecb69fee4ce42}{incrementCurrentTransactionId} (int min=0, int max=INT\_\-MAX)}
\label{classmdt_port_manager_a4d009936a0a5130f3bfecb69fee4ce42}

\begin{DoxyCompactList}\small\item\em Increment current transaction ID. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ac58ed84e0e9230d1931557bc4bbe8a50}{addTransactionPending} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Add a transaction to pending queue. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$ \hyperlink{classmdt_port_manager_a18478707a9be7638b06cde48ced48297}{transactionPending} (int id)
\begin{DoxyCompactList}\small\item\em Take pending transaction matching id. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}{
void \hyperlink{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}{flushTransactionsPending} ()}
\label{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}

\begin{DoxyCompactList}\small\item\em Restore all transactions pending to pool. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a4b584d9005316be9991e6026e4c5e5a4}{addTransactionDone} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Add a transaction to the DONE queue. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a3293066f4c3ed2e4b116f28dca8c5d64}{
bool \hyperlink{classmdt_port_manager_a3293066f4c3ed2e4b116f28dca8c5d64}{transactionsDoneContains} (int id) const }
\label{classmdt_port_manager_a3293066f4c3ed2e4b116f28dca8c5d64}

\begin{DoxyCompactList}\small\item\em Check if a transaction with given ID exists in done queue. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$ \hyperlink{classmdt_port_manager_a5869bcf6774a86fb9d3b00a0d4211bb5}{transactionDone} (int id)
\begin{DoxyCompactList}\small\item\em Take transaction from DONE queue matching id. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_aad801de5f93a3619d98b7ea3cae6b999}{
void \hyperlink{classmdt_port_manager_aad801de5f93a3619d98b7ea3cae6b999}{flushTransactionsDone} ()}
\label{classmdt_port_manager_aad801de5f93a3619d98b7ea3cae6b999}

\begin{DoxyCompactList}\small\item\em Restore all transactions done to pool. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a84d37b380080eb26e56c68424dedd958}{commitFrames} ()
\begin{DoxyCompactList}\small\item\em Emit signals for each done transactions. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a016996e823cc729eb1f595307f3dd1cf}{cancelReadWait} ()
\begin{DoxyCompactList}\small\item\em Set the wait cancel flag. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_a83ade128d6e70f7216355e9df840c2a6}{readWaitCanceled} ()
\begin{DoxyCompactList}\small\item\em Get the wait cancel flag. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_port_manager_af856162aab4f1c5202c1dfb330fae538}{
\hyperlink{classmdt_abstract_port}{mdtAbstractPort} $\ast$ {\bfseries pvPort}}
\label{classmdt_port_manager_af856162aab4f1c5202c1dfb330fae538}

\item 
\hypertarget{classmdt_port_manager_a8e0d49b789f8b01d469e84b487799573}{
QList$<$ \hyperlink{classmdt_port_thread}{mdtPortThread} $\ast$ $>$ {\bfseries pvThreads}}
\label{classmdt_port_manager_a8e0d49b789f8b01d469e84b487799573}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Port manager base class. 

Manages a port based on \hyperlink{classmdt_abstract_port}{mdtAbstractPort} an several threads based on \hyperlink{classmdt_port_thread}{mdtPortThread}. The goal is to hide the complexity of the port API.

Example: 
\begin{DoxyCode}
 mdtPortManager m;
 mdtPort *port;
 mdtPortConfig *config;
 QList<QByteArray> responses;

 // Setup
 config = new mdtPortConfig;
 config->setFrameType(mdtFrame::FT_ASCII);
 config->setEndOfFrameSeq("$");

 // Init port
 port = new mdtPort;
 port->setConfig(config);

 // Init port manager - We wand blocking mode
 m.setTransactionsDisabled(true);
 m.setPort(port);
 m.addThread(mew mdtPortWriteThread);
 m.addThread(mew mdtPortReadThread);
 m.setPortName("/dev/xyz"));
 if(!m.openPort()){
  // Handle error
 }

 // Start threads
 if(!m.start()){
  // Handle error
 }

 // Send some data
 if(!m.writeData("Test$")){
  // Handle error
 }

 // Wait on answer - Timout: 1500 [ms]
 if(!m.waitReadenFrame(1500)){
  // Timout , handle error
 }

 // Do something with received data
 responses = m.readenFrames();
 for(int i=0; i<responses.size(); i++){
  qDebug() << responses.at(i);
 }

 // Cleanup - detachPort() will delete port and threads objects
 m.detachPort(true, true);
 delete config;
\end{DoxyCode}


A (recommended) alternative is to disable frames enqueuing and use the newReadenFrame(QByteArray) signal.
\begin{DoxyItemize}
\item Disable enqueuing with setTransactionsDisabled(false)
\item Connect newReadenFrame(QByteArray) to a slot
\end{DoxyItemize}

-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/

Manage a port based on \hyperlink{classmdt_abstract_port}{mdtAbstractPort} and related threads. Goal is to hide complexity of \hyperlink{classmdt_abstract_port}{mdtAbstractPort} API.

Depending on application, it's possible to use a event approach, or also a blocking approach with wait methods.

Some protocols support frame identifier (like MODBUS/TCP, USBTMC, or others), and other don't (for example raw bytes transfert on a serial port). For this reason, the concept of transactions is aodpted here. A transaction is based on \hyperlink{classmdt_port_transaction}{mdtPortTransaction} class. It was introduced for protocols that support identification, and can store some other meta data, usefull to decode a reply.

This base class can be used directly for ports that supports raw transfers. For specific protocol, it can be subclassed.

\begin{Desc}
\item[\hyperlink{todo__todo000023}{Todo}]Document init, open, close, ...\end{Desc}


Now, we can see the data transfer workflow:
\begin{DoxyItemize}
\item 1) Wait until it's possible to send some data with \hyperlink{classmdt_port_manager_a1ca92c5ac120d87e5b10bff54ed1aa5c}{waitOnWriteReady()}
\item 2) Get a new transaction with \hyperlink{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}{getNewTransaction()} , and setup it as needed (see remarks below).
\item 3) Send data using \hyperlink{classmdt_port_manager_a328abc7f5f2677c19ea11567df6597da}{writeData(mdtPortTransaction$\ast$)}. This will set the currentTransactionId to the ID given in transaction.
\item 4a) If you choosed a blocking approach, use \hyperlink{classmdt_port_manager_aaa8845faa91904dba625fe7f1d23bc51}{waitTransactionDone()}.
\item 4b) If you choosed a event approach, connect the \hyperlink{classmdt_port_manager_a5869bcf6774a86fb9d3b00a0d4211bb5}{transactionDone()} signal to a slot. Each time a transaction is done, you will receive a transaction.
\item 5) Get the transaction with \hyperlink{classmdt_port_manager_a5869bcf6774a86fb9d3b00a0d4211bb5}{transactionDone()}.
\item 6) Restore transaction with \hyperlink{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}{restoreTransaction()}.
\end{DoxyItemize}

Steps 2) and 3) can be done once by using \hyperlink{classmdt_port_manager_a9b902a60c8b21585904bcb1d6e604369}{writeData(const QByteArray\&, bool)}. Steps 5) and 6) can be done once by using getReadenData(int).

Here is a little example of the simple approach: 
\begin{DoxyCode}
 mdtPortManager m;
 int transactionId;
 // Setup...

 // Wait until we can write
 if(!waitOnWriteReady()){
   // Handle error
 }

 // Send data to port
 transactionId = writeData("SomeData", true);
 if(transactionId < 0){
   // Handle error
 }

 // Wait until data come in
 if(waitTransactionDone(transactionId)){
   // Handle error
 }

 // Get only data for a specific transaction (should be used only for protocols t
      hat support transaction)
 qDebug() << readenFrame(transactionId);
 // Get all received data
 qDebug() << readenFrames();
\end{DoxyCode}


Internally, once data was send to port's write queue, the transaction is stored in the pending transactions queue.

Dealing with incomming data: In above example, 2 methods are shown to get incomming data:
\begin{DoxyItemize}
\item \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame(int)} : will work with protocols that support frame ID. See specific port manager subclass for details.
\item \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()} : see below.
\end{DoxyItemize}

If we are using a protocol that not support frame ID, it's possible that we receive data each time, also without sending any request. This must be handled in \hyperlink{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{fromThreadNewFrameReaden()} slot. In this \hyperlink{classmdt_port_manager}{mdtPortManager} class, the following will happen:
\begin{DoxyItemize}
\item When sending data with \hyperlink{classmdt_port_manager_a9b902a60c8b21585904bcb1d6e604369}{writeData(const QByteArray\&, bool)}, current transaction ID will be incremented with \hyperlink{classmdt_port_manager_a4d009936a0a5130f3bfecb69fee4ce42}{incrementCurrentTransactionId()}.
\item In \hyperlink{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{fromThreadNewFrameReaden()} slot, \hyperlink{classmdt_port_manager_a19abf29c8948cde0337d67c9722c25aa}{currentTransactionId()} is used to get pending transaction with \hyperlink{classmdt_port_manager_a18478707a9be7638b06cde48ced48297}{transactionPending()}. If it was found, frame's data is copied, and transaction is moved to done queue. If not found, a new transaction is taken with \hyperlink{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}{getNewTransaction()}, frame's data is copied, and transaction is enqueued to done queue with \hyperlink{classmdt_port_manager_a4b584d9005316be9991e6026e4c5e5a4}{addTransactionDone()}.
\item \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()} will return a list of data that comes from transactions Done list. Current transaction ID will be restet to 0.
\end{DoxyItemize}

The Query/Reply mode: port manager is able to handle event or blocking mode in same time. This cause a problem for done transactions handling. For example, when we choosed the event based aproach for a transaction, port manager will emit the \hyperlink{classmdt_port_manager_a416a24db1048e9f66aef27ea810954d2}{newTransactionDone(mdtPortTransaction$\ast$)} signal, then restore transaction back to pool. When we choosed blocking approach, port manager will also emit \hyperlink{classmdt_port_manager_a416a24db1048e9f66aef27ea810954d2}{newTransactionDone(mdtPortTransaction$\ast$)} signal, wich can be usefull to keep, for example, a GUI coherent in each mode. But here, the transaction must not be restored directly, but only once data was readen with \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} or \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()}. To handle this, \hyperlink{classmdt_port_manager_a84d37b380080eb26e56c68424dedd958}{commitFrames()} will use \hyperlink{classmdt_port_transaction_a9da1cc7a191cd21a2e532d277aa3c628}{mdtPortTransaction::isQueryReplyMode()}. 

Definition at line 195 of file mdtPortManager.h.



\subsection{Member Enumeration Documentation}
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382da}{
\index{mdtPortManager@{mdtPortManager}!state\_\-t@{state\_\-t}}
\index{state\_\-t@{state\_\-t}!mdtPortManager@{mdtPortManager}}
\subsubsection[{state\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf mdtPortManager::state\_\-t}}}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382da}


State of device. 

\begin{Desc}
\item[Enumerator: ]\par
\begin{description}
\index{Ready@{Ready}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!Ready@{Ready}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daaf2ba40e19587c3a98235ee96a4acf20e}{
Ready}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daaf2ba40e19587c3a98235ee96a4acf20e}
}]Port is open, setup is done and threads are running. Depending on port type, device is connected (USB, TCP). \index{Disconnected@{Disconnected}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!Disconnected@{Disconnected}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa4004253e25d51b1e628bb5006dbbd153}{
Disconnected}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa4004253e25d51b1e628bb5006dbbd153}
}]Device is not connected or port is down \index{Connecting@{Connecting}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!Connecting@{Connecting}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa89e805c9c75c39ecc8371d5f38131227}{
Connecting}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa89e805c9c75c39ecc8371d5f38131227}
}]Trying to connect to device \index{Busy@{Busy}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!Busy@{Busy}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa5da3fa5dd98a264ecb4a37a1983ea0ff}{
Busy}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa5da3fa5dd98a264ecb4a37a1983ea0ff}
}]Port is up and device is connected but cannot accept requests for the moment \index{Warning@{Warning}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!Warning@{Warning}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa8ca72085e29c5c6745294e58684e5d3c}{
Warning}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa8ca72085e29c5c6745294e58684e5d3c}
}]Device or port communication handled error occured \index{Error@{Error}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!Error@{Error}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa687598301ad573e51cafaa209da72718}{
Error}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa687598301ad573e51cafaa209da72718}
}]Device or port communication unhandled error occured \end{description}
\end{Desc}



Definition at line 203 of file mdtPortManager.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_port_manager_a5ec36523089b7528d973e29cdbc64d01}{
\index{mdtPortManager@{mdtPortManager}!mdtPortManager@{mdtPortManager}}
\index{mdtPortManager@{mdtPortManager}!mdtPortManager@{mdtPortManager}}
\subsubsection[{mdtPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtPortManager::mdtPortManager (
\begin{DoxyParamCaption}
\item[{QObject $\ast$}]{parent = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a5ec36523089b7528d973e29cdbc64d01}


Contruct a port manager. 

keepTransactionsDone flag will be unset (set false). 

Definition at line 31 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_adf797f8fd7a3ffdc000890a224e4c1b6}{
\index{mdtPortManager@{mdtPortManager}!$\sim$mdtPortManager@{$\sim$mdtPortManager}}
\index{$\sim$mdtPortManager@{$\sim$mdtPortManager}!mdtPortManager@{mdtPortManager}}
\subsubsection[{$\sim$mdtPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtPortManager::$\sim$mdtPortManager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_adf797f8fd7a3ffdc000890a224e4c1b6}


Destructor. 

If a port was set, the manager will stop (if running), and port will be closed (if open).

Note that port set by \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} and threads are not deleted. 

Definition at line 47 of file mdtPortManager.cpp.



\subsection{Member Function Documentation}
\hypertarget{classmdt_port_manager_a1d185e9bb610aee16ccd9499ae7bff0d}{
\index{mdtPortManager@{mdtPortManager}!abort@{abort}}
\index{abort@{abort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{abort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::abort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual, slot\mbox{]}}}}
\label{classmdt_port_manager_a1d185e9bb610aee16ccd9499ae7bff0d}


Cancel read and write operations. 

Default implementation calls \hyperlink{classmdt_abstract_port_abde440c49b95833f821e1333c40a7398}{mdtAbstractPort::flush()}. 

Definition at line 640 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}{
\index{mdtPortManager@{mdtPortManager}!addThread@{addThread}}
\index{addThread@{addThread}!mdtPortManager@{mdtPortManager}}
\subsubsection[{addThread}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::addThread (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortThread} $\ast$}]{thread}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}


Add a thread and assign it to port. 

\begin{DoxyPrecond}{Precondition}
Port must be set with setPort before using this method 

Manager must no running 

thread must be a valid pointer 
\end{DoxyPrecond}


Definition at line 99 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a4b584d9005316be9991e6026e4c5e5a4}{
\index{mdtPortManager@{mdtPortManager}!addTransactionDone@{addTransactionDone}}
\index{addTransactionDone@{addTransactionDone}!mdtPortManager@{mdtPortManager}}
\subsubsection[{addTransactionDone}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::addTransactionDone (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a4b584d9005316be9991e6026e4c5e5a4}


Add a transaction to the DONE queue. 

\begin{DoxyPrecond}{Precondition}
transaction must be a valid pointer. 
\end{DoxyPrecond}


Definition at line 704 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ac58ed84e0e9230d1931557bc4bbe8a50}{
\index{mdtPortManager@{mdtPortManager}!addTransactionPending@{addTransactionPending}}
\index{addTransactionPending@{addTransactionPending}!mdtPortManager@{mdtPortManager}}
\subsubsection[{addTransactionPending}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::addTransactionPending (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_ac58ed84e0e9230d1931557bc4bbe8a50}


Add a transaction to pending queue. 

Add a existing transaction to the pending queue. A transaction can be requested with \hyperlink{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}{getNewTransaction()}.

\begin{DoxyPrecond}{Precondition}
transaction must be a valid pointer. 

transaction ID must not allready exist in queue. 
\end{DoxyPrecond}


Definition at line 668 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a7cb3155940e23db0122d14f21fca858d}{
\index{mdtPortManager@{mdtPortManager}!adjustedReadTimeout@{adjustedReadTimeout}}
\index{adjustedReadTimeout@{adjustedReadTimeout}!mdtPortManager@{mdtPortManager}}
\subsubsection[{adjustedReadTimeout}]{\setlength{\rightskip}{0pt plus 5cm}int mdtPortManager::adjustedReadTimeout (
\begin{DoxyParamCaption}
\item[{int}]{requestedTimeout, }
\item[{bool}]{warn = {\ttfamily true}}
\end{DoxyParamCaption}
) const}}
\label{classmdt_port_manager_a7cb3155940e23db0122d14f21fca858d}


Adjust a requested timeout to minimal timeout. 

We have 2 different timeouts:
\begin{DoxyItemize}
\item Port timeout: If data are expected on the port, and nothing comes in, a port timeout occurs.
\item Response (or complete frame) timeout: Timeout to receive a complete frame
\end{DoxyItemize}

For example, we expect a complete frame of, say, 200 Bytes. The device will send , f.ex. , 20 x 10 Bytes. During the read process, a port timeout can occur (device busy, or something else). If read process works fine, all data can be readen in a time less than port timeout.


\begin{DoxyParams}{Parameters}
{\em requestedTimeout} & Requested timeout \mbox{[}ms\mbox{]} \\
\hline
{\em warn} & If true, a warning will be logged if requested timeout is to small. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Requested timeout or port's timeout + offset (offset is currently hardcoded: 1000 \mbox{[}ms\mbox{]}) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} and contain a valid configuration. 
\end{DoxyPrecond}


Definition at line 514 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a9d6782be514745a1b1392216d17d41df}{
\index{mdtPortManager@{mdtPortManager}!adjustedWriteTimeout@{adjustedWriteTimeout}}
\index{adjustedWriteTimeout@{adjustedWriteTimeout}!mdtPortManager@{mdtPortManager}}
\subsubsection[{adjustedWriteTimeout}]{\setlength{\rightskip}{0pt plus 5cm}int mdtPortManager::adjustedWriteTimeout (
\begin{DoxyParamCaption}
\item[{int}]{requestedTimeout, }
\item[{bool}]{warn = {\ttfamily true}}
\end{DoxyParamCaption}
) const}}
\label{classmdt_port_manager_a9d6782be514745a1b1392216d17d41df}


Adjust a requested timeout to minimal timeout. 

See \hyperlink{classmdt_port_manager_a7cb3155940e23db0122d14f21fca858d}{adjustedReadTimeout()} for details.


\begin{DoxyParams}{Parameters}
{\em requestedTimeout} & Requested timeout \mbox{[}ms\mbox{]} \\
\hline
{\em warn} & If true, a warning will be logged if requested timeout is to small. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Requested timeout or port's timeout + offset (offset is currently hardcoded: 1000 \mbox{[}ms\mbox{]}) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} and contain a valid configuration. 
\end{DoxyPrecond}


Definition at line 543 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a0936c65454409ffcf64ecb0632f6dbe3}{
\index{mdtPortManager@{mdtPortManager}!busy@{busy}}
\index{busy@{busy}!mdtPortManager@{mdtPortManager}}
\subsubsection[{busy}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::busy (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a0936c65454409ffcf64ecb0632f6dbe3}


Device busy event event. 

Used by internal state machine \hypertarget{classmdt_port_manager_a016996e823cc729eb1f595307f3dd1cf}{
\index{mdtPortManager@{mdtPortManager}!cancelReadWait@{cancelReadWait}}
\index{cancelReadWait@{cancelReadWait}!mdtPortManager@{mdtPortManager}}
\subsubsection[{cancelReadWait}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::cancelReadWait (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a016996e823cc729eb1f595307f3dd1cf}


Set the wait cancel flag. 

If flag is set, waitOnFrame(), waitReadenFrame() will return.

Note: this will not cancel anything in port or port threads. 

Definition at line 770 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ace8065f1f5083041ee7f65c2892bc77d}{
\index{mdtPortManager@{mdtPortManager}!closePort@{closePort}}
\index{closePort@{closePort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{closePort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::closePort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_ace8065f1f5083041ee7f65c2892bc77d}


Close the port. 

This stops the threads (if exists) and close the port.

If port was never set (with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} ), this method does nothing. 

\begin{Desc}
\item[\hyperlink{todo__todo000020}{Todo}]check about flush I/O \end{Desc}




Definition at line 256 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a84d37b380080eb26e56c68424dedd958}{
\index{mdtPortManager@{mdtPortManager}!commitFrames@{commitFrames}}
\index{commitFrames@{commitFrames}!mdtPortManager@{mdtPortManager}}
\subsubsection[{commitFrames}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::commitFrames (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a84d37b380080eb26e56c68424dedd958}


Emit signals for each done transactions. 

Will emit \hyperlink{classmdt_port_manager_a416a24db1048e9f66aef27ea810954d2}{newTransactionDone(mdtPortTransaction$\ast$)} for each transaction found in done queue.

If queryReplyMode and keepTransactionsDone are not set, the transaction is restored back to pool, else it will be restored only after a call of \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} or \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()}. 

Definition at line 754 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a735b7dc766fc2f45fb2cf9772c4201b0}{
\index{mdtPortManager@{mdtPortManager}!config@{config}}
\index{config@{config}!mdtPortManager@{mdtPortManager}}
\subsubsection[{config}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortConfig} \& mdtPortManager::config (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_port_manager_a735b7dc766fc2f45fb2cf9772c4201b0}


Get the port's config object. 

Usefull to read internal port configuration

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Definition at line 235 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{
\index{mdtPortManager@{mdtPortManager}!config@{config}}
\index{config@{config}!mdtPortManager@{mdtPortManager}}
\subsubsection[{config}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortConfig} \& mdtPortManager::config (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}


Get the port's config object. 

Usefull to alter internal port configuration

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_serial_port_manager_a4b8ab7b9d53966a1887d9ce8557b8416}{mdtSerialPortManager}.



Definition at line 228 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a6095719fbd3967428d48e7f57f23c56e}{
\index{mdtPortManager@{mdtPortManager}!connecting@{connecting}}
\index{connecting@{connecting}!mdtPortManager@{mdtPortManager}}
\subsubsection[{connecting}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::connecting (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a6095719fbd3967428d48e7f57f23c56e}


Connecting event. 

Used by internal state machine \hypertarget{classmdt_port_manager_a39cb4af4aedc0b6b7c4d4f53002c3fd1}{
\index{mdtPortManager@{mdtPortManager}!detachPort@{detachPort}}
\index{detachPort@{detachPort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{detachPort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::detachPort (
\begin{DoxyParamCaption}
\item[{bool}]{deletePort, }
\item[{bool}]{deleteThreads}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a39cb4af4aedc0b6b7c4d4f53002c3fd1}


Detach port. 

Will detach port from each thread and from port manager. If port was not set, this method does nothing. If manager is running, it will be stopped. If port is open, it will be closed.


\begin{DoxyParams}{Parameters}
{\em deletePort} & If true, the port object that was set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} will be deleted. \\
\hline
{\em deleteThreads} & If true, each thread added with \hyperlink{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}{addThread()} will be deleted. \\
\hline
\end{DoxyParams}


Definition at line 76 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ac6cfb9054c3b77689132dcf3a906eeb6}{
\index{mdtPortManager@{mdtPortManager}!disconnected@{disconnected}}
\index{disconnected@{disconnected}!mdtPortManager@{mdtPortManager}}
\subsubsection[{disconnected}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::disconnected (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_ac6cfb9054c3b77689132dcf3a906eeb6}


Disconnected event. 

Used by internal state machine \hypertarget{classmdt_port_manager_a7f9437d084e136d8d265dace7431395f}{
\index{mdtPortManager@{mdtPortManager}!errorStateChanged@{errorStateChanged}}
\index{errorStateChanged@{errorStateChanged}!mdtPortManager@{mdtPortManager}}
\subsubsection[{errorStateChanged}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::errorStateChanged (
\begin{DoxyParamCaption}
\item[{int}]{error, }
\item[{const QString \&}]{message = {\ttfamily QString()}, }
\item[{const QString \&}]{details = {\ttfamily QString()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a7f9437d084e136d8d265dace7431395f}


Emitted when error number has changed. 

The error is one of the \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t}. \hypertarget{classmdt_port_manager_a97b91e7c1641836eb6afb47fd244a18e}{
\index{mdtPortManager@{mdtPortManager}!flush@{flush}}
\index{flush@{flush}!mdtPortManager@{mdtPortManager}}
\subsubsection[{flush}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::flush (
\begin{DoxyParamCaption}
\item[{bool}]{flushPortManagerBuffers, }
\item[{bool}]{flushPortBuffers}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a97b91e7c1641836eb6afb47fd244a18e}


Flush I/O buffers. 


\begin{DoxyParams}{Parameters}
{\em flushPortManagerBuffers} & If true, port manager buffers will be cleared. (Has no effect in this implementation, but some subclass can have output buffers). \\
\hline
{\em flushPortBuffers} & If true, port's buffers will be cleared. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before calling this method. 
\end{DoxyPrecond}


Definition at line 619 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a3eab774008d7530ae341ce9c38265d65}{
\index{mdtPortManager@{mdtPortManager}!flush@{flush}}
\index{flush@{flush}!mdtPortManager@{mdtPortManager}}
\subsubsection[{flush}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::flush (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a3eab774008d7530ae341ce9c38265d65}


Flush I/O buffers. 

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before calling this method. 
\end{DoxyPrecond}


Definition at line 630 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ac0844a5cd4043a95a479d458ac7ce590}{
\index{mdtPortManager@{mdtPortManager}!flushIn@{flushIn}}
\index{flushIn@{flushIn}!mdtPortManager@{mdtPortManager}}
\subsubsection[{flushIn}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::flushIn (
\begin{DoxyParamCaption}
\item[{bool}]{flushPortManagerBuffers, }
\item[{bool}]{flushPortBuffers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_ac0844a5cd4043a95a479d458ac7ce590}


Flush input buffers. 


\begin{DoxyParams}{Parameters}
{\em flushPortManagerBuffers} & If true, port manager buffers will be cleared. \\
\hline
{\em flushPortBuffers} & If true, port's buffers will be cleared. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before calling this method. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_usb_port_manager_a982256ed17db155e1c95d544683a6dba}{mdtUsbPortManager}.



Definition at line 585 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a4c44ce6ec40c4afc6be441c10d7ee827}{
\index{mdtPortManager@{mdtPortManager}!flushIn@{flushIn}}
\index{flushIn@{flushIn}!mdtPortManager@{mdtPortManager}}
\subsubsection[{flushIn}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::flushIn (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a4c44ce6ec40c4afc6be441c10d7ee827}


Flush input buffers. 

Will flush portmanger and port's buffers.

Internally, \hyperlink{classmdt_port_manager_ac0844a5cd4043a95a479d458ac7ce590}{flushIn(bool, bool)} is called. 

Definition at line 602 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a3f0c2722a41c49de2bea9013bccd049c}{
\index{mdtPortManager@{mdtPortManager}!flushOut@{flushOut}}
\index{flushOut@{flushOut}!mdtPortManager@{mdtPortManager}}
\subsubsection[{flushOut}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::flushOut (
\begin{DoxyParamCaption}
\item[{bool}]{flushPortManagerBuffers, }
\item[{bool}]{flushPortBuffers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_a3f0c2722a41c49de2bea9013bccd049c}


Flush output buffers. 


\begin{DoxyParams}{Parameters}
{\em flushPortManagerBuffers} & If true, port manager buffers will be cleared. (Has no effect in this implementation, but some subclass can have output buffers). \\
\hline
{\em flushPortBuffers} & If true, port's buffers will be cleared. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before calling this method. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_usb_port_manager_ab723086376175c40635df44adf358985}{mdtUsbPortManager}.



Definition at line 607 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ab34018a9653a5af784fa7da06a9e50d3}{
\index{mdtPortManager@{mdtPortManager}!flushOut@{flushOut}}
\index{flushOut@{flushOut}!mdtPortManager@{mdtPortManager}}
\subsubsection[{flushOut}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::flushOut (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_ab34018a9653a5af784fa7da06a9e50d3}


Flush output buffers. 

Will flush portmanger and port's buffers.

Internally, \hyperlink{classmdt_port_manager_a3f0c2722a41c49de2bea9013bccd049c}{flushOut(bool, bool)} is called. 

Definition at line 614 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{
\index{mdtPortManager@{mdtPortManager}!fromThreadNewFrameReaden@{fromThreadNewFrameReaden}}
\index{fromThreadNewFrameReaden@{fromThreadNewFrameReaden}!mdtPortManager@{mdtPortManager}}
\subsubsection[{fromThreadNewFrameReaden}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::fromThreadNewFrameReaden (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual, slot\mbox{]}}}}
\label{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}


Called by the read thread whenn a complete frame was readen. 

This variant will add data to transactions done queue. If pending transactions queue contains \hyperlink{classmdt_port_manager_a19abf29c8948cde0337d67c9722c25aa}{currentTransactionId()}, it will be removed.

For subclass that handle frames with IDs, this method must be reimplemented. The normal way is to get the frame in pending queue with \hyperlink{classmdt_port_manager_a18478707a9be7638b06cde48ced48297}{transactionPending()}. For frames with ID that not exists in pending queue, it must be choosen to discard them, or adopt another behaviour.

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_thread}{mdtPortThread} 
\end{DoxySeeAlso}


\begin{Desc}
\item[\hyperlink{todo__todo000021}{Todo}]Error on incomplete frame \end{Desc}




Reimplemented in \hyperlink{classmdt_modbus_tcp_port_manager_ad941ea607f00db54aa6deb2866a539e9}{mdtModbusTcpPortManager}, and \hyperlink{classmdt_usbtmc_port_manager_aca42b343ae1f6a324e6e45968f03bbea}{mdtUsbtmcPortManager}.



Definition at line 784 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}{
\index{mdtPortManager@{mdtPortManager}!getNewTransaction@{getNewTransaction}}
\index{getNewTransaction@{getNewTransaction}!mdtPortManager@{mdtPortManager}}
\subsubsection[{getNewTransaction}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortTransaction} $\ast$ mdtPortManager::getNewTransaction (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}


Get a new transaction. 

If transactions pool is empty, a new transaction is created. Note that each transaction should be put back in pool with \hyperlink{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}{restoreTransaction()}. In most cases, if a method that uses transactions fails, the transaction must be restored with \hyperlink{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}{restoreTransaction()}. See \hyperlink{classmdt_port_manager_a328abc7f5f2677c19ea11567df6597da}{writeData(mdtPortTransaction$\ast$)}, writeData(const QByteArray\&), \hyperlink{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}{flushTransactionsPending()}, \hyperlink{classmdt_port_manager_aad801de5f93a3619d98b7ea3cae6b999}{flushTransactionsDone()}, \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} and \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()} for details about restoration of transaction.

\begin{DoxyReturn}{Returns}
A empty transaction (\hyperlink{classmdt_port_transaction_a5f7b04df58291d52e61c5bd1b7f7bb7f}{mdtPortTransaction::clear()} is called internally).
\end{DoxyReturn}
\begin{DoxyPostcond}{Postcondition}
Returned transaction is valid (never Null). 
\end{DoxyPostcond}


Definition at line 281 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a30fac00920ab8d760df777f917183add}{
\index{mdtPortManager@{mdtPortManager}!handledError@{handledError}}
\index{handledError@{handledError}!mdtPortManager@{mdtPortManager}}
\subsubsection[{handledError}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::handledError (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a30fac00920ab8d760df777f917183add}


Handled error event. 

Used by internal state machine \hypertarget{classmdt_port_manager_af460167e604b8b6e2e933a98b2b6b5a2}{
\index{mdtPortManager@{mdtPortManager}!isRunning@{isRunning}}
\index{isRunning@{isRunning}!mdtPortManager@{mdtPortManager}}
\subsubsection[{isRunning}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::isRunning (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_af460167e604b8b6e2e933a98b2b6b5a2}


Get the running state. 

If one of the threads is running, true is returned.

If port was not set, it returns false. 

Definition at line 169 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a416a24db1048e9f66aef27ea810954d2}{
\index{mdtPortManager@{mdtPortManager}!newTransactionDone@{newTransactionDone}}
\index{newTransactionDone@{newTransactionDone}!mdtPortManager@{mdtPortManager}}
\subsubsection[{newTransactionDone}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::newTransactionDone (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a416a24db1048e9f66aef27ea810954d2}


Try to. 

Emitted each time a transaction is done.

Note: the transaction pointer is only valid for one call, do not store it for later usage. Connect this signal to a slot that runs in GUI thread only.

This signal is emited by \hyperlink{classmdt_port_manager_a84d37b380080eb26e56c68424dedd958}{commitFrames()}. \hypertarget{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}{
\index{mdtPortManager@{mdtPortManager}!onThreadsErrorOccured@{onThreadsErrorOccured}}
\index{onThreadsErrorOccured@{onThreadsErrorOccured}!mdtPortManager@{mdtPortManager}}
\subsubsection[{onThreadsErrorOccured}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::onThreadsErrorOccured (
\begin{DoxyParamCaption}
\item[{int}]{error}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual, slot\mbox{]}}}}
\label{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}


Manage errors comming from port threads. 

This implementation simply change the current state emiting transistions signal. Subclass can reimplement this method to handle port specific error. Dont forget to emit transistion signals.

\begin{Desc}
\item[\hyperlink{todo__todo000022}{Todo}]On disconnect, should flush I/O ? \end{Desc}


emit(errorStateChanged(error)); 



Definition at line 827 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{
\index{mdtPortManager@{mdtPortManager}!openPort@{openPort}}
\index{openPort@{openPort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{openPort}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::openPort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}


Open the port. 

Will try to open port defined with \hyperlink{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}{setPortName()}.

\begin{DoxyReturn}{Returns}
True on success, false else. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}
\begin{Desc}
\item[\hyperlink{todo__todo000024}{Todo}]Should return \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \end{Desc}


Reimplemented in \hyperlink{classmdt_usb_port_manager_a7e7e6a29c2cf8d1d6bee23dd3f69d829}{mdtUsbPortManager}.



Definition at line 242 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{
\index{mdtPortManager@{mdtPortManager}!readenFrame@{readenFrame}}
\index{readenFrame@{readenFrame}!mdtPortManager@{mdtPortManager}}
\subsubsection[{readenFrame}]{\setlength{\rightskip}{0pt plus 5cm}QByteArray mdtPortManager::readenFrame (
\begin{DoxyParamCaption}
\item[{int}]{id}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}


Get data by frame ID. 

The frame ID is a protocol specific identification. F.ex. in MODBUS/TCP, the transaction ID is used, or bTag for USBTMC.

If found, the frame is removed from done queue. (A second call with same ID will return a empty QByteArray).

If ID was not found, a empty QByteArray is returned. 

Definition at line 484 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{
\index{mdtPortManager@{mdtPortManager}!readenFrames@{readenFrames}}
\index{readenFrames@{readenFrames}!mdtPortManager@{mdtPortManager}}
\subsubsection[{readenFrames}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ QByteArray $>$ mdtPortManager::readenFrames (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}


Get all readen data. 

Note that calling this methode will clear the internal queue. (A second call will return a empty list). 

Definition at line 497 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ad9233b5156a45f2684783317d75fdf9b}{
\index{mdtPortManager@{mdtPortManager}!readThread@{readThread}}
\index{readThread@{readThread}!mdtPortManager@{mdtPortManager}}
\subsubsection[{readThread}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortThread} $\ast$ mdtPortManager::readThread (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_ad9233b5156a45f2684783317d75fdf9b}


Returns instance of reader thread. 

Note that a Null pointer can be returned 

Definition at line 119 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a83ade128d6e70f7216355e9df840c2a6}{
\index{mdtPortManager@{mdtPortManager}!readWaitCanceled@{readWaitCanceled}}
\index{readWaitCanceled@{readWaitCanceled}!mdtPortManager@{mdtPortManager}}
\subsubsection[{readWaitCanceled}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::readWaitCanceled (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a83ade128d6e70f7216355e9df840c2a6}


Get the wait cancel flag. 

After a call, the flag will be reset. 

Definition at line 775 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_afc4e88b2ade86ac13469bc0732c95f59}{
\index{mdtPortManager@{mdtPortManager}!ready@{ready}}
\index{ready@{ready}!mdtPortManager@{mdtPortManager}}
\subsubsection[{ready}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::ready (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_afc4e88b2ade86ac13469bc0732c95f59}


Device ready event event. 

Used by internal state machine \hypertarget{classmdt_port_manager_aaa0a474183bcae0fff4fb9ef43023c25}{
\index{mdtPortManager@{mdtPortManager}!removeThreads@{removeThreads}}
\index{removeThreads@{removeThreads}!mdtPortManager@{mdtPortManager}}
\subsubsection[{removeThreads}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::removeThreads (
\begin{DoxyParamCaption}
\item[{bool}]{releaseMemory}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_aaa0a474183bcae0fff4fb9ef43023c25}


Detach threads from port and remove threads. 


\begin{DoxyParams}{Parameters}
{\em releaseMemory} & If true, all threads are deleted \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port manager must not running. 
\end{DoxyPrecond}


Definition at line 129 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}{
\index{mdtPortManager@{mdtPortManager}!restoreTransaction@{restoreTransaction}}
\index{restoreTransaction@{restoreTransaction}!mdtPortManager@{mdtPortManager}}
\subsubsection[{restoreTransaction}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::restoreTransaction (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}


Restore a transaction into pool. 

\begin{DoxyPrecond}{Precondition}
transaction must be a valid pointer (not Null) 

One transaction must be commited once (avoid corrupted double free) 
\end{DoxyPrecond}


Definition at line 304 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}{
\index{mdtPortManager@{mdtPortManager}!scan@{scan}}
\index{scan@{scan}!mdtPortManager@{mdtPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtPortManager::scan (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}


Scan for available ports. 

This method is implemented is port's specific subclass. Default implementation returns a empty list.

Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).

\begin{DoxyPrecond}{Precondition}
Manager must no running 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_usb_port_manager_a3a2370c3a2d0353a880bf9b777728c3b}{mdtUsbPortManager}, \hyperlink{classmdt_usbtmc_port_manager_a992d1227810186d3c7dc166452e2e3b6}{mdtUsbtmcPortManager}, and \hyperlink{classmdt_serial_port_manager_a791572f869d1d605d0c4658ca4187260}{mdtSerialPortManager}.



Definition at line 61 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a9adb5098766c9df588bc9978b00c5eb2}{
\index{mdtPortManager@{mdtPortManager}!setKeepTransactionsDone@{setKeepTransactionsDone}}
\index{setKeepTransactionsDone@{setKeepTransactionsDone}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setKeepTransactionsDone}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setKeepTransactionsDone (
\begin{DoxyParamCaption}
\item[{bool}]{keep}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a9adb5098766c9df588bc9978b00c5eb2}


Force transactions done to be keeped. 

If keep is true, \hyperlink{classmdt_port_manager_a84d37b380080eb26e56c68424dedd958}{commitFrames()} will ignore the \hyperlink{classmdt_port_transaction_a9da1cc7a191cd21a2e532d277aa3c628}{mdtPortTransaction::isQueryReplyMode()} and allways keep transactions in done queue until \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} or \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()} is called. 

Definition at line 271 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{
\index{mdtPortManager@{mdtPortManager}!setPort@{setPort}}
\index{setPort@{setPort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setPort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setPort (
\begin{DoxyParamCaption}
\item[{{\bf mdtAbstractPort} $\ast$}]{port}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}


Set port object. 

\begin{DoxyPrecond}{Precondition}
port must be a valid pointer to the expected class instance (for ex: \hyperlink{classmdt_serial_port}{mdtSerialPort}). 

Manager must no running 
\end{DoxyPrecond}


Definition at line 68 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a7e2ef93ec2731e66aa2b2d5f7ce9bc1c}{
\index{mdtPortManager@{mdtPortManager}!setPortInfo@{setPortInfo}}
\index{setPortInfo@{setPortInfo}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setPortInfo}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setPortInfo (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortInfo}}]{info}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a7e2ef93ec2731e66aa2b2d5f7ce9bc1c}


Set port info. 

Store given port info, and call \hyperlink{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}{setPortName()} with port info's stored port name (see \hyperlink{classmdt_port_info_ad456aac33dccc9b0583ed8aa4796cdf0}{mdtPortInfo::portName()} ).

Setting a port info can be usefull if other informations are needed later in application (f.ex. \hyperlink{classmdt_port_info_a38bcac67372782228a91d8e7dbf49211}{mdtPortInfo::displayText()} ). You can get port informations later with \hyperlink{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}{portInfo()}. 

Definition at line 211 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}{
\index{mdtPortManager@{mdtPortManager}!setPortName@{setPortName}}
\index{setPortName@{setPortName}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setPortName}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setPortName (
\begin{DoxyParamCaption}
\item[{const QString \&}]{portName}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}


Set port name. 

Set the port name to internally port object. Does nothing else. To open the port, use \hyperlink{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{openPort()}.

\begin{DoxyPrecond}{Precondition}
Port must be set before with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} 
\end{DoxyPrecond}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_abstract_port}{mdtAbstractPort} 
\end{DoxySeeAlso}


Definition at line 204 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{
\index{mdtPortManager@{mdtPortManager}!start@{start}}
\index{start@{start}!mdtPortManager@{mdtPortManager}}
\subsubsection[{start}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::start (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}


Start threads. 

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 

Port must be open with \hyperlink{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{openPort()} before using this method 
\end{DoxyPrecond}


Definition at line 151 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a6f6c6f8a8430d8631a08c765565db9ab}{
\index{mdtPortManager@{mdtPortManager}!statusMessageChanged@{statusMessageChanged}}
\index{statusMessageChanged@{statusMessageChanged}!mdtPortManager@{mdtPortManager}}
\subsubsection[{statusMessageChanged}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::statusMessageChanged (
\begin{DoxyParamCaption}
\item[{const QString \&}]{message, }
\item[{const QString \&}]{details, }
\item[{int}]{timeout}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a6f6c6f8a8430d8631a08c765565db9ab}


Emitted when a new status message is to display. 

Typically used with mdtDeviceStatusWidget. \hypertarget{classmdt_port_manager_aacbf87cc3d9c37c87e21696f8a6514bd}{
\index{mdtPortManager@{mdtPortManager}!stop@{stop}}
\index{stop@{stop}!mdtPortManager@{mdtPortManager}}
\subsubsection[{stop}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::stop (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_aacbf87cc3d9c37c87e21696f8a6514bd}


Stop threads. 

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Definition at line 186 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a5869bcf6774a86fb9d3b00a0d4211bb5}{
\index{mdtPortManager@{mdtPortManager}!transactionDone@{transactionDone}}
\index{transactionDone@{transactionDone}!mdtPortManager@{mdtPortManager}}
\subsubsection[{transactionDone}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortTransaction} $\ast$ mdtPortManager::transactionDone (
\begin{DoxyParamCaption}
\item[{int}]{id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a5869bcf6774a86fb9d3b00a0d4211bb5}


Take transaction from DONE queue matching id. 

\begin{DoxyReturn}{Returns}
A valid transaction if exists, else a Null pointer. 
\end{DoxyReturn}


Definition at line 726 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a18478707a9be7638b06cde48ced48297}{
\index{mdtPortManager@{mdtPortManager}!transactionPending@{transactionPending}}
\index{transactionPending@{transactionPending}!mdtPortManager@{mdtPortManager}}
\subsubsection[{transactionPending}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortTransaction} $\ast$ mdtPortManager::transactionPending (
\begin{DoxyParamCaption}
\item[{int}]{id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a18478707a9be7638b06cde48ced48297}


Take pending transaction matching id. 

\begin{DoxyReturn}{Returns}
A valid transaction if exists, else a Null pointer. 
\end{DoxyReturn}


Definition at line 684 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a75111efb0c8956ddc98a87a9aedec695}{
\index{mdtPortManager@{mdtPortManager}!unhandledError@{unhandledError}}
\index{unhandledError@{unhandledError}!mdtPortManager@{mdtPortManager}}
\subsubsection[{unhandledError}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::unhandledError (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a75111efb0c8956ddc98a87a9aedec695}


Unhandled error event. 

Used by internal state machine \hypertarget{classmdt_port_manager_acc5c63ad33fdd3cc153fc23e00c6e69c}{
\index{mdtPortManager@{mdtPortManager}!wait@{wait}}
\index{wait@{wait}!mdtPortManager@{mdtPortManager}}
\subsubsection[{wait}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::wait (
\begin{DoxyParamCaption}
\item[{int}]{msecs, }
\item[{int}]{granularity = {\ttfamily 50}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classmdt_port_manager_acc5c63ad33fdd3cc153fc23e00c6e69c}


Wait some time without break the GUI's event loop. 

This is a helper method that provide a blocking wait. Internally, a couple of sleep and event processing is done, avoiding freesing the GUI.

This wait method is not precise.


\begin{DoxyParams}{Parameters}
{\em msecs} & Time to wait \mbox{[}ms\mbox{]} \\
\hline
{\em granularity} & Sleep time between each call of event processing \mbox{[}ms\mbox{]}\par
 A little value needs more CPU and big value can freese the GUI. Should be between 50 and 100, and must be $>$ 0. Note that msecs must be a multiple of granularity. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
granularity must be $>$ 0. 
\end{DoxyPrecond}


Definition at line 572 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_aeb8a98c8bf4ce8279bd897dece6d731a}{
\index{mdtPortManager@{mdtPortManager}!waitOneTransactionDone@{waitOneTransactionDone}}
\index{waitOneTransactionDone@{waitOneTransactionDone}!mdtPortManager@{mdtPortManager}}
\subsubsection[{waitOneTransactionDone}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::waitOneTransactionDone (
\begin{DoxyParamCaption}
\item[{int}]{timeout = {\ttfamily 0}, }
\item[{int}]{granularity = {\ttfamily 50}}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_aeb8a98c8bf4ce8279bd897dece6d731a}


Wait until current transaction is done. 

Use this method if protocol does not support frame ID.

Internally, it will wait until one transaction is available in done queue.


\begin{DoxyParams}{Parameters}
{\em timeout} & Maximum wait time \mbox{[}ms\mbox{]}. Must be a multiple of granularity \mbox{[}ms\mbox{]} Will be adjusted to a minimal timeout regarding configuration (see \hyperlink{classmdt_port_manager_a7cb3155940e23db0122d14f21fca858d}{adjustedReadTimeout()} ). If 0, the configuration's read timeout will be used. \\
\hline
{\em granularity} & Sleep time between each call of event processing \mbox{[}ms\mbox{]}\par
 A little value needs more CPU and big value can freese the GUI. Should be between 50 and 100, and must be $>$ 0. Note that timeout must be a multiple of granularity. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if Ok, false on timeout or other error. 
\end{DoxyReturn}


Definition at line 454 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a1ca92c5ac120d87e5b10bff54ed1aa5c}{
\index{mdtPortManager@{mdtPortManager}!waitOnWriteReady@{waitOnWriteReady}}
\index{waitOnWriteReady@{waitOnWriteReady}!mdtPortManager@{mdtPortManager}}
\subsubsection[{waitOnWriteReady}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::waitOnWriteReady (
\begin{DoxyParamCaption}
\item[{int}]{timeout = {\ttfamily 0}, }
\item[{int}]{granularity = {\ttfamily 50}}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a1ca92c5ac120d87e5b10bff54ed1aa5c}


Wait until data can be written. 

Wait until a frame is available in write frames pool. The wait will not breack Qt's event loop, so this method can be called from GUI Thread. (See \hyperlink{classmdt_port_manager_acc5c63ad33fdd3cc153fc23e00c6e69c}{wait()} for details).


\begin{DoxyParams}{Parameters}
{\em timeout} & Timeout \mbox{[}ms\mbox{]}. If $<$ 0, a infinite timeout is considered, else timeout will be used, adjusted to the minimal timeout (see \hyperlink{classmdt_port_manager_a9d6782be514745a1b1392216d17d41df}{adjustedWriteTimeout()} ). Note: if a timeout $>$ 0 is given, and it's lesser than defined in port configuration, a warning will be logged. To avoid this, use a timeout $>$ than in configuration, or 0. \\
\hline
{\em granularity} & Sleep time between each call of event processing \mbox{[}ms\mbox{]}. A little value needs more CPU and big value can freese the GUI. Should be between 50 and 100, and must be $>$ 0. Note that timeout must be a multiple of granularity. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if a frame is available before timeout, false else. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Granularity must be $>$ 0. 

Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before calling this method. 
\end{DoxyPrecond}


Definition at line 312 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_aaa8845faa91904dba625fe7f1d23bc51}{
\index{mdtPortManager@{mdtPortManager}!waitTransactionDone@{waitTransactionDone}}
\index{waitTransactionDone@{waitTransactionDone}!mdtPortManager@{mdtPortManager}}
\subsubsection[{waitTransactionDone}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::waitTransactionDone (
\begin{DoxyParamCaption}
\item[{int}]{id, }
\item[{int}]{timeout = {\ttfamily 0}, }
\item[{int}]{granularity = {\ttfamily 50}}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_aaa8845faa91904dba625fe7f1d23bc51}


Wait until a transaction is done. 

Will return when transaction with given id is done or after timeout.

Internally, a couple of sleep and process event are called, so Qt's event loop will not be broken.

This method can return if timeout occurs, or for other reason depending on specific port (port timeout, read cancelled, ...).


\begin{DoxyParams}{Parameters}
{\em id} & Frame ID. Depending on protocol, this can be a transaction ID or what else. \\
\hline
{\em timeout} & Maximum wait time \mbox{[}ms\mbox{]}. Must be a multiple of granularity \mbox{[}ms\mbox{]} Will be adjusted to a minimal timeout regarding configuration (see \hyperlink{classmdt_port_manager_a7cb3155940e23db0122d14f21fca858d}{adjustedReadTimeout()} ). If 0, the configuration's read timeout will be used. \\
\hline
{\em granularity} & Sleep time between each call of event processing \mbox{[}ms\mbox{]}\par
 A little value needs more CPU and big value can freese the GUI. Should be between 50 and 100, and must be $>$ 0. Note that timeout must be a multiple of granularity. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if Ok, false on timeout or other error. If id was not found in transactions pending lists, a warning will be generated in \hyperlink{classmdt_error}{mdtError} system, and false will be returned. On failure, transaction is restored to pool. 
\end{DoxyReturn}


Definition at line 406 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a9b902a60c8b21585904bcb1d6e604369}{
\index{mdtPortManager@{mdtPortManager}!writeData@{writeData}}
\index{writeData@{writeData}!mdtPortManager@{mdtPortManager}}
\subsubsection[{writeData}]{\setlength{\rightskip}{0pt plus 5cm}int mdtPortManager::writeData (
\begin{DoxyParamCaption}
\item[{const QByteArray \&}]{data, }
\item[{bool}]{queryReplyMode = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_a9b902a60c8b21585904bcb1d6e604369}


Write data to port. 

Will increment the current transaction ID, get a new transaction, setup it and finally send it with \hyperlink{classmdt_port_manager_a328abc7f5f2677c19ea11567df6597da}{writeData(mdtPortTransaction$\ast$)}.


\begin{DoxyParams}{Parameters}
{\em data} & Data to write. \\
\hline
{\em queryReplyMode} & If true, reply will be keeped in transactions done queue until \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} or \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()} is called. If false, behaviour depends on keepTransactionsDone flag.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_a328abc7f5f2677c19ea11567df6597da}{writeData(mdtPortTransaction$\ast$)} 
\end{DoxySeeAlso}


Reimplemented in \hyperlink{classmdt_modbus_tcp_port_manager_a5e687204475d788170b9b61a1f06eecf}{mdtModbusTcpPortManager}.



Definition at line 390 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a328abc7f5f2677c19ea11567df6597da}{
\index{mdtPortManager@{mdtPortManager}!writeData@{writeData}}
\index{writeData@{writeData}!mdtPortManager@{mdtPortManager}}
\subsubsection[{writeData}]{\setlength{\rightskip}{0pt plus 5cm}int mdtPortManager::writeData (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_a328abc7f5f2677c19ea11567df6597da}


Write data to port. 

Data contained in transaction will be passed to the mdtPort's write queue by copy. This method returns immediatly after enqueue, and don't wait until data was written.


\begin{DoxyParams}{Parameters}
{\em transaction} & Transaction used to send data. Following members are used by this method:
\begin{DoxyItemize}
\item id : transaction will be added to pending transactions with this id, and currentTransactionId will be set with it.
\item data : will be sent to port.
\item isQueryReplyMode : if true, the transaction will be keeped in transactions done queue until \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} or \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()} is called. Note: it's possible to force keeping all incomming data (wich also owerwrite this flag) by setting the global keepTransactionsDone flag. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transaction ID on success or value $<$ 0 on error. In this implementation, the only possible error is mdtAbstractPort::WriteQueueEmpty . Some subclass can return a frame ID on success, or a other error. See subclass documentation for details. Note: on failure, the transaction is restored to pool. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 

transaction must be a valid pointer, and not allready exists in transactions pending or transactions done queue.
\end{DoxyPrecond}
Subclass notes:\par
 This method can be reimplemented in subclass if needed. Typically usefull if some encoding is needed before the frame is submitted to port. A frame must be taken from port's write frames pool with \hyperlink{classmdt_abstract_port_abf093b67fddebffa4f3c52277b9a8cf7}{mdtAbstractPort::writeFramesPool()} dequeue() method (see Qt's QQueue documentation for more details on dequeue() ), then added to port's write queue with \hyperlink{classmdt_abstract_port_a9a69eb2fc07d551ab37c011487fa319d}{mdtAbstractPort::addFrameToWrite()} . If protocol supports frame identification (like MODBUS's transaction ID or USBTMC's bTag), it should be returned here and incremented using \hyperlink{classmdt_port_manager_a4d009936a0a5130f3bfecb69fee4ce42}{incrementCurrentTransactionId()}. 

Reimplemented in \hyperlink{classmdt_modbus_tcp_port_manager_afdee5f0444f7f6b258a23733cc134684}{mdtModbusTcpPortManager}.



Definition at line 357 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_af44b6e9876e6687b1d4fe7e05ffd5a91}{
\index{mdtPortManager@{mdtPortManager}!writeThread@{writeThread}}
\index{writeThread@{writeThread}!mdtPortManager@{mdtPortManager}}
\subsubsection[{writeThread}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortThread} $\ast$ mdtPortManager::writeThread (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_af44b6e9876e6687b1d4fe7e05ffd5a91}


Returns instance of writer thread. 

Note that a Null pointer can be returned 

Definition at line 124 of file mdtPortManager.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtPortManager.h\item 
src/mdtport/mdtPortManager.cpp\end{DoxyCompactItemize}
