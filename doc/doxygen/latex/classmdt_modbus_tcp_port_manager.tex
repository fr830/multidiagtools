\hypertarget{classmdt_modbus_tcp_port_manager}{
\section{mdtModbusTcpPortManager Class Reference}
\label{classmdt_modbus_tcp_port_manager}\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
}


MODBUS/TCP port manager.  




{\ttfamily \#include $<$mdtModbusTcpPortManager.h$>$}



Inheritance diagram for mdtModbusTcpPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=220pt]{classmdt_modbus_tcp_port_manager__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtModbusTcpPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{classmdt_modbus_tcp_port_manager__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Slots}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_modbus_tcp_port_manager_ab6cc6b2a57c1c126be0a9c3142a6f0e5}{
void \hyperlink{classmdt_modbus_tcp_port_manager_ab6cc6b2a57c1c126be0a9c3142a6f0e5}{abortScan} ()}
\label{classmdt_modbus_tcp_port_manager_ab6cc6b2a57c1c126be0a9c3142a6f0e5}

\begin{DoxyCompactList}\small\item\em Abort the scan process. \end{DoxyCompactList}\item 
\hypertarget{classmdt_modbus_tcp_port_manager_a4d16b312f74974d4147d631b425771e4}{
void \hyperlink{classmdt_modbus_tcp_port_manager_a4d16b312f74974d4147d631b425771e4}{abortTryToConnect} ()}
\label{classmdt_modbus_tcp_port_manager_a4d16b312f74974d4147d631b425771e4}

\begin{DoxyCompactList}\small\item\em Called by connect timeout timer. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_modbus_tcp_port_manager_ad941ea607f00db54aa6deb2866a539e9}{fromThreadNewFrameReaden} ()
\begin{DoxyCompactList}\small\item\em Called by the thread whenn a complete frame was readen. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_modbus_tcp_port_manager_a2f65f779bbad19d9d3f85ef35220ffb8}{mdtModbusTcpPortManager} (QObject $\ast$parent=0)
\begin{DoxyCompactList}\small\item\em Construct a MODBUS/TCP port manager. \end{DoxyCompactList}\item 
\hyperlink{classmdt_modbus_tcp_port_manager_aabe51a50a53c6b23884cc4862730b731}{$\sim$mdtModbusTcpPortManager} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_modbus_tcp_port_manager_a41d366dbf944346b6b0466d4618b9625}{scan} (const QStringList \&hosts, int timeout=500, const QList$<$ int $>$ \&expectedHwNodeAddresses=QList$<$ int $>$(), int bitsCount=8, int bitsCountStartFrom=0)
\begin{DoxyCompactList}\small\item\em Scan for available hosts with a MODBUS/TCP compatible device attached. \end{DoxyCompactList}\item 
QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_modbus_tcp_port_manager_a5537ba29f5d54980a8c10bbd3e41bea5}{scan} (const QNetworkInterface \&iface, quint16 port=502, int timeout=500, const QList$<$ int $>$ \&expectedHwNodeAddresses=QList$<$ int $>$(), int bitsCount=8, int bitsCountStartFrom=0)
\begin{DoxyCompactList}\small\item\em Scan for available hosts with a MODBUS/TCP compatible device attached. \end{DoxyCompactList}\item 
QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_modbus_tcp_port_manager_a88b57abd1ce0b8017619c13fce4c695d}{scan} (const QList$<$ QNetworkInterface $>$ \&ifaces, quint16 port=502, int timeout=500, bool ignoreLoopback=true, const QList$<$ int $>$ \&expectedHwNodeAddresses=QList$<$ int $>$(), int bitsCount=8, int bitsCountStartFrom=0)
\begin{DoxyCompactList}\small\item\em Scan for available hosts with a MODBUS/TCP compatible device attached. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_modbus_tcp_port_manager_ab04f69b660487a7c59d309df7a8f5baa}{tryToConnect} (const QString \&hostName, quint16 port, int timeout)
\begin{DoxyCompactList}\small\item\em Try to connect to a host. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_modbus_tcp_port_manager_a3a1f5a54c93fa90ba83dea8785407da3}{saveScanResult} (const QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ scanResult)
\begin{DoxyCompactList}\small\item\em Save a scan result into the known hosts file. \end{DoxyCompactList}\item 
QStringList \hyperlink{classmdt_modbus_tcp_port_manager_ab4d0a994973af6008faf489ca9ddb03d}{readScanResult} ()
\begin{DoxyCompactList}\small\item\em Read scan result stored in cache file. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_modbus_tcp_port_manager_a5477eb7e8d57c5a42004046b426e39b6}{isReady} () const 
\begin{DoxyCompactList}\small\item\em Check if port manager is ready. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{getHardwareNodeAddress} (int bitsCount, int startFrom=0)
\begin{DoxyCompactList}\small\item\em Get the hardware node ID. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_modbus_tcp_port_manager_ab5e780409492b5f56326a870bc4262ec}{getRegisterValues} (int address, int n)
\begin{DoxyCompactList}\small\item\em Helper method for register service. \end{DoxyCompactList}\item 
const QList$<$ int $>$ \& \hyperlink{classmdt_modbus_tcp_port_manager_a99a13b5250a8523aa63869991581e56a}{registerValues} () const 
\begin{DoxyCompactList}\small\item\em Helper method for register service. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_modbus_tcp_port_manager_a746211413dfafb987a93145c9fa4876f}{setRegisterValues} (int startAddress, QList$<$ int $>$ \&values)
\begin{DoxyCompactList}\small\item\em Helper method for register service. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_modbus_tcp_port_manager_a208a3b2522795974836fd8aef406725a}{sendData} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Send PDU on TCP port. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_modbus_tcp_port_manager_ac6ffcccbba23b1bda5cba2ae347793ba}{sendData} (const QByteArray \&pdu, bool queryReplyMode=false)
\begin{DoxyCompactList}\small\item\em Send PDU by copy. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
MODBUS/TCP port manager. 

This is the simplest way to use the MODBUS/TCP API.

All needed object are created by constructor. To alter configuration, use \hyperlink{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{config()}. To access the tcp port object, use port().

Use \hyperlink{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{start()} to begin read/write and stop to end.

References:
\begin{DoxyItemize}
\item MODBUS Application Protocol Specification V1.1b
\item \href{http://www.Modbus-IDA.org}{\tt http://www.Modbus-\/IDA.org} 
\end{DoxyItemize}

Definition at line 46 of file mdtModbusTcpPortManager.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_modbus_tcp_port_manager_a2f65f779bbad19d9d3f85ef35220ffb8}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{mdtModbusTcpPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtModbusTcpPortManager::mdtModbusTcpPortManager (
\begin{DoxyParamCaption}
\item[{QObject $\ast$}]{parent = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_a2f65f779bbad19d9d3f85ef35220ffb8}


Construct a MODBUS/TCP port manager. 

Creates a \hyperlink{classmdt_port_config}{mdtPortConfig}, a \hyperlink{classmdt_tcp_socket}{mdtTcpSocket}, and thread object. 

Definition at line 41 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_aabe51a50a53c6b23884cc4862730b731}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!$\sim$mdtModbusTcpPortManager@{$\sim$mdtModbusTcpPortManager}}
\index{$\sim$mdtModbusTcpPortManager@{$\sim$mdtModbusTcpPortManager}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{$\sim$mdtModbusTcpPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtModbusTcpPortManager::$\sim$mdtModbusTcpPortManager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_aabe51a50a53c6b23884cc4862730b731}


Destructor. 

Stop the manager (if running), and close the port (if open). All internal objects (port, config and threads) are deleted here. 

Definition at line 66 of file mdtModbusTcpPortManager.cpp.



\subsection{Member Function Documentation}
\hypertarget{classmdt_modbus_tcp_port_manager_ad941ea607f00db54aa6deb2866a539e9}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!fromThreadNewFrameReaden@{fromThreadNewFrameReaden}}
\index{fromThreadNewFrameReaden@{fromThreadNewFrameReaden}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{fromThreadNewFrameReaden}]{\setlength{\rightskip}{0pt plus 5cm}void mdtModbusTcpPortManager::fromThreadNewFrameReaden (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual, slot\mbox{]}}}}
\label{classmdt_modbus_tcp_port_manager_ad941ea607f00db54aa6deb2866a539e9}


Called by the thread whenn a complete frame was readen. 



\begin{Desc}
\item[\hyperlink{todo__todo000035}{Todo}]Error on incomplete frame \end{Desc}


\begin{Desc}
\item[\hyperlink{todo__todo000036}{Todo}]check about transaction ID ? Should be a assertion ? \end{Desc}




Reimplemented from \hyperlink{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{mdtPortManager}.



Definition at line 593 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!getHardwareNodeAddress@{getHardwareNodeAddress}}
\index{getHardwareNodeAddress@{getHardwareNodeAddress}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{getHardwareNodeAddress}]{\setlength{\rightskip}{0pt plus 5cm}int mdtModbusTcpPortManager::getHardwareNodeAddress (
\begin{DoxyParamCaption}
\item[{int}]{bitsCount, }
\item[{int}]{startFrom = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}


Get the hardware node ID. 

The concept of node ID is specific to MultiDiagTools. It was introduced to solve the problem of network IP configurations.

Take a example: We have a application that needs several MODBUS/TCP nodes. Each node has several I/O's. Say that digital output 1 of node 1 is used to activate a lamp and output 1 of node 2 must activate heating register. We could choose to have static IP addresses in the network and configure the application to activate the correct output of correct node. But, this can be a problem when a node must be replaced. More cumbersome case is a modular application that could manage several nodes, and change his I/Os layout in a dynamic way regarding a context.

A easy way to solve such problems is to have a DHCP server in the network and all nodes configured as DHCP clients (static addressing can still be a solution, but we not depend on it). Then, for a given application, we can fix a number of digital inputs to play the role of node address. Then, instead of using IP address as identification (as in the example), we use node address.


\begin{DoxyParams}{Parameters}
{\em bitsCount} & Number of digital inputs that represents the hardware node address. \\
\hline
{\em startFrom} & First digital input that represents the hardware node address (is the LSB). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Node address or value $<$ 0 corresponding on mdtAbstractPor::error\_\-t . 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port manager must be connected and thread running before calling this method. 

bitsCount must be $>$ 0 

startFrom must be $>$= 0 
\end{DoxyPrecond}


Definition at line 369 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_ab5e780409492b5f56326a870bc4262ec}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!getRegisterValues@{getRegisterValues}}
\index{getRegisterValues@{getRegisterValues}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{getRegisterValues}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtModbusTcpPortManager::getRegisterValues (
\begin{DoxyParamCaption}
\item[{int}]{address, }
\item[{int}]{n}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_ab5e780409492b5f56326a870bc4262ec}


Helper method for register service. 

Usefull to get resgister values (f.ex. configurations regsisters, ...).

Note: to get analog I/O values, the \hyperlink{classmdt_device}{mdtDevice} API should be used.

\begin{DoxyReturn}{Returns}
True on success. Values are the available with \hyperlink{classmdt_modbus_tcp_port_manager_a99a13b5250a8523aa63869991581e56a}{registerValues()} 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
address must be $>$= 0 

n must be $>$ 0 
\end{DoxyPrecond}


Definition at line 421 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a5477eb7e8d57c5a42004046b426e39b6}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!isReady@{isReady}}
\index{isReady@{isReady}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{isReady}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtModbusTcpPortManager::isReady (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_modbus_tcp_port_manager_a5477eb7e8d57c5a42004046b426e39b6}


Check if port manager is ready. 

Internally, the currentState is used to check if port manager is ready. This implementation returns true if currentState is Ready (= connected to device). 

Reimplemented from \hyperlink{classmdt_port_manager_a6dc2798324521d177fb8f79d4f6c5f0f}{mdtPortManager}.



Definition at line 364 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_ab4d0a994973af6008faf489ca9ddb03d}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!readScanResult@{readScanResult}}
\index{readScanResult@{readScanResult}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{readScanResult}]{\setlength{\rightskip}{0pt plus 5cm}QStringList mdtModbusTcpPortManager::readScanResult (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_ab4d0a994973af6008faf489ca9ddb03d}


Read scan result stored in cache file. 

The file stored by \hyperlink{classmdt_modbus_tcp_port_manager_a3a1f5a54c93fa90ba83dea8785407da3}{saveScanResult()} is readen (if exists) and content returned.

\begin{DoxyReturn}{Returns}
List of lines or empty list if file not exists or on error. 
\end{DoxyReturn}


Definition at line 345 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a99a13b5250a8523aa63869991581e56a}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!registerValues@{registerValues}}
\index{registerValues@{registerValues}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{registerValues}]{\setlength{\rightskip}{0pt plus 5cm}const QList$<$ int $>$ \& mdtModbusTcpPortManager::registerValues (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_modbus_tcp_port_manager_a99a13b5250a8523aa63869991581e56a}


Helper method for register service. 

Return result set by \hyperlink{classmdt_modbus_tcp_port_manager_ab5e780409492b5f56326a870bc4262ec}{getRegisterValues()}. Note that values are keeped until next call of \hyperlink{classmdt_modbus_tcp_port_manager_ab5e780409492b5f56326a870bc4262ec}{getRegisterValues()}. 

Definition at line 473 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a3a1f5a54c93fa90ba83dea8785407da3}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!saveScanResult@{saveScanResult}}
\index{saveScanResult@{saveScanResult}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{saveScanResult}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtModbusTcpPortManager::saveScanResult (
\begin{DoxyParamCaption}
\item[{const QList$<$ {\bf mdtPortInfo} $\ast$ $>$}]{scanResult}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_a3a1f5a54c93fa90ba83dea8785407da3}


Save a scan result into the known hosts file. 

The file will be written to the \$HOME/.mdt/cache directory, and contains lines with format host:port.


\begin{DoxyParams}{Parameters}
{\em scanResult} & List of port informations returned by a \hyperlink{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}{scan()} method. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True on successfull write. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Manager must no running 
\end{DoxyPrecond}


Definition at line 313 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a41d366dbf944346b6b0466d4618b9625}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!scan@{scan}}
\index{scan@{scan}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtModbusTcpPortManager::scan (
\begin{DoxyParamCaption}
\item[{const QStringList \&}]{hosts, }
\item[{int}]{timeout = {\ttfamily 500}, }
\item[{const QList$<$ int $>$ \&}]{expectedHwNodeAddresses = {\ttfamily QList$<$int$>$()}, }
\item[{int}]{bitsCount = {\ttfamily 8}, }
\item[{int}]{bitsCountStartFrom = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_a41d366dbf944346b6b0466d4618b9625}


Scan for available hosts with a MODBUS/TCP compatible device attached. 


\begin{DoxyParams}{Parameters}
{\em hosts} & A list of hosts to scan. Each host must be set with format hostname:port, or ip:port. Note that MODBUS/TCP default port is 502. \\
\hline
{\em timeout} & Maximum wait time \mbox{[}ms\mbox{]}. Must be a multiple of 50 \mbox{[}ms\mbox{]} \\
\hline
{\em expectedHwNodeAddresses} & If this list contains HW node addresses, scan will break when each one was found. See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{getHardwareNodeAddress()} for details about HW node address. \\
\hline
{\em bitsCount} & See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{getHardwareNodeAddress()} \\
\hline
{\em bitsCountStartFrom} & See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{getHardwareNodeAddress()}\\
\hline
\end{DoxyParams}
Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).

\begin{DoxyPrecond}{Precondition}
Port manager must be stopped 
\end{DoxyPrecond}


Definition at line 74 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a5537ba29f5d54980a8c10bbd3e41bea5}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!scan@{scan}}
\index{scan@{scan}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtModbusTcpPortManager::scan (
\begin{DoxyParamCaption}
\item[{const QNetworkInterface \&}]{iface, }
\item[{quint16}]{port = {\ttfamily 502}, }
\item[{int}]{timeout = {\ttfamily 500}, }
\item[{const QList$<$ int $>$ \&}]{expectedHwNodeAddresses = {\ttfamily QList$<$int$>$()}, }
\item[{int}]{bitsCount = {\ttfamily 8}, }
\item[{int}]{bitsCountStartFrom = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_a5537ba29f5d54980a8c10bbd3e41bea5}


Scan for available hosts with a MODBUS/TCP compatible device attached. 


\begin{DoxyParams}{Parameters}
{\em iface} & Scan will be done for all IP addresses available for given intarface. Note that only IPv4 is implemented. \\
\hline
{\em port} & Port. Note that MODBUS/TCP default port is 502. \\
\hline
{\em timeout} & Maximum wait time \mbox{[}ms\mbox{]}. Must be a multiple of 50 \mbox{[}ms\mbox{]} \\
\hline
{\em expectedHwNodeAddresses} & If this list contains HW node addresses, scan will break when each one was found. See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{getHardwareNodeAddress()} for details about HW node address. \\
\hline
{\em bitsCount} & See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{getHardwareNodeAddress()} \\
\hline
{\em bitsCountStartFrom} & See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{getHardwareNodeAddress()}\\
\hline
\end{DoxyParams}
Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).

\begin{DoxyPrecond}{Precondition}
Port manager must be stopped 
\end{DoxyPrecond}


Definition at line 147 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a88b57abd1ce0b8017619c13fce4c695d}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!scan@{scan}}
\index{scan@{scan}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtModbusTcpPortManager::scan (
\begin{DoxyParamCaption}
\item[{const QList$<$ QNetworkInterface $>$ \&}]{ifaces, }
\item[{quint16}]{port = {\ttfamily 502}, }
\item[{int}]{timeout = {\ttfamily 500}, }
\item[{bool}]{ignoreLoopback = {\ttfamily true}, }
\item[{const QList$<$ int $>$ \&}]{expectedHwNodeAddresses = {\ttfamily QList$<$int$>$()}, }
\item[{int}]{bitsCount = {\ttfamily 8}, }
\item[{int}]{bitsCountStartFrom = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_a88b57abd1ce0b8017619c13fce4c695d}


Scan for available hosts with a MODBUS/TCP compatible device attached. 


\begin{DoxyParams}{Parameters}
{\em ifaces} & Scan will be done for all IP addresses available for all given intarfaces. Note that only IPv4 is implemented. \\
\hline
{\em port} & Port. Note that MODBUS/TCP default port is 502. \\
\hline
{\em timeout} & Maximum wait time \mbox{[}ms\mbox{]}. Must be a multiple of 50 \mbox{[}ms\mbox{]} \\
\hline
{\em ignoreLoopback} & If true, loopback interface will be ignored. \\
\hline
{\em expectedHwNodeAddresses} & If this list contains HW node addresses, scan will break when each one was found. See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{getHardwareNodeAddress()} for details about HW node address. \\
\hline
{\em bitsCount} & See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{getHardwareNodeAddress()} \\
\hline
{\em bitsCountStartFrom} & See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{getHardwareNodeAddress()}\\
\hline
\end{DoxyParams}
Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).

\begin{DoxyPrecond}{Precondition}
Port manager must be stopped 
\end{DoxyPrecond}


Definition at line 247 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a208a3b2522795974836fd8aef406725a}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!sendData@{sendData}}
\index{sendData@{sendData}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{sendData}]{\setlength{\rightskip}{0pt plus 5cm}int mdtModbusTcpPortManager::sendData (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_modbus_tcp_port_manager_a208a3b2522795974836fd8aef406725a}


Send PDU on TCP port. 

At first, this method waits until the ready state is set calling \hyperlink{classmdt_modbus_tcp_port_manager_a5477eb7e8d57c5a42004046b426e39b6}{isReady()} , a frame is available in port's write frames pool, and until a transaction is possible (see \hyperlink{classmdt_port_manager_ac04a12f8aa20ba04695083afce45a6cc}{waitTransactionPossible()} ). This wait will not break event loop, so no GUI freeze occurs. If port manager is stopped during this wait (unhandled error, stop request), this method returns.

Then, data will be encoded regarding MODBUS/TCP standard and passed to the \hyperlink{classmdt_tcp_socket}{mdtTcpSocket} write queue. This method returns immediatly after enqueue, and don't wait until data was written.


\begin{DoxyParams}{Parameters}
{\em transaction} & Transaction used to send data. Following members are used by this method:
\begin{DoxyItemize}
\item id : MODBUS/TCP transaction ID (will be set internally).
\item data : PDU to send.
\item isQueryReplyMode : if true, the transaction will be keeped in transactions done queue until \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame(int)} is called. For all cases, signal newReadenFrame(mdtPortTransaction$\ast$) is emitted when data comes in.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transaction ID on success or value $<$ 0 on error. Possible error is \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eae50ff4a9393507ad39005ddc7d5be42f}{mdtAbstractPort::WriteCanceled}, witch typically occurs when port manager stops. Note: on failure, the transaction is restored to pool. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 

transaction must be a valid pointer, and not allready exists in transactions pending or transactions done queue. 
\end{DoxyPrecond}


\begin{Desc}
\item[\hyperlink{todo__todo000034}{Todo}]Handle this ? \end{Desc}




Reimplemented from \hyperlink{classmdt_port_manager_ad98399edba146af5cf32a9002094385c}{mdtPortManager}.



Definition at line 517 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_ac6ffcccbba23b1bda5cba2ae347793ba}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!sendData@{sendData}}
\index{sendData@{sendData}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{sendData}]{\setlength{\rightskip}{0pt plus 5cm}int mdtModbusTcpPortManager::sendData (
\begin{DoxyParamCaption}
\item[{const QByteArray \&}]{pdu, }
\item[{bool}]{queryReplyMode = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_modbus_tcp_port_manager_ac6ffcccbba23b1bda5cba2ae347793ba}


Send PDU by copy. 

Will get a new transaction, setup it with pdu as data and queryReplyMode flag, then send it with \hyperlink{classmdt_modbus_tcp_port_manager_a208a3b2522795974836fd8aef406725a}{sendData(mdtPortTransaction$\ast$)}.


\begin{DoxyParams}{Parameters}
{\em pdu} & MODBUS PDU (see the MODBUS Application Protocol Specification for details) \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classmdt_port_manager_a445b27f0819158f67f1bd548cdd2fedf}{mdtPortManager}.



Definition at line 569 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a746211413dfafb987a93145c9fa4876f}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!setRegisterValues@{setRegisterValues}}
\index{setRegisterValues@{setRegisterValues}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{setRegisterValues}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtModbusTcpPortManager::setRegisterValues (
\begin{DoxyParamCaption}
\item[{int}]{startAddress, }
\item[{QList$<$ int $>$ \&}]{values}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_a746211413dfafb987a93145c9fa4876f}


Helper method for register service. 

Usefull to set register values (f.ex. configurations regsisters, ...).

Note: to set analog I/O values, the \hyperlink{classmdt_device}{mdtDevice} API should be used.

\begin{DoxyReturn}{Returns}
True on success. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
startAddress must be $>$= 0 
\end{DoxyPrecond}


Definition at line 478 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_ab04f69b660487a7c59d309df7a8f5baa}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!tryToConnect@{tryToConnect}}
\index{tryToConnect@{tryToConnect}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{tryToConnect}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtModbusTcpPortManager::tryToConnect (
\begin{DoxyParamCaption}
\item[{const QString \&}]{hostName, }
\item[{quint16}]{port, }
\item[{int}]{timeout}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_ab04f69b660487a7c59d309df7a8f5baa}


Try to connect to a host. 


\begin{DoxyParams}{Parameters}
{\em hostName} & Host name or a IP address \\
\hline
{\em port} & Port. Note that MODBUS/TCP default port is 502. \\
\hline
{\em timeout} & Maximum wait time \mbox{[}ms\mbox{]}. Must be a multiple of 50 \mbox{[}ms\mbox{]} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True on successfull connection. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port manager must be stopped 
\end{DoxyPrecond}


Definition at line 272 of file mdtModbusTcpPortManager.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtModbusTcpPortManager.h\item 
src/mdtport/mdtModbusTcpPortManager.cpp\end{DoxyCompactItemize}
