\hypertarget{classmdt_port_manager}{
\section{mdtPortManager Class Reference}
\label{classmdt_port_manager}\index{mdtPortManager@{mdtPortManager}}
}


Port manager base class.  




{\ttfamily \#include $<$mdtPortManager.h$>$}



Inheritance diagram for mdtPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{classmdt_port_manager__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{classmdt_port_manager__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382da}{state\_\-t} \{ \par
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daabac9679c411402c9db01399ecb72b84d}{PortClosed} =  0, 
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daadbd7b0395c62e9ae38525c5dc5ba44a6}{Stopped}, 
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daaca288962f5cb3d352f44f4e4c15f14d2}{Starting}, 
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa1c68525fc2c4d94e39a73d1a4bea0476}{Stopping}, 
\par
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daaa7af1c561e17e65982c027de942d4a75}{Running}, 
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa2440f5bfc7ae5c78db1598ef6d3d394c}{PortError}, 
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa3a3b42b9d783381f3c7447086503fde6}{PortReady}, 
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa4004253e25d51b1e628bb5006dbbd153}{Disconnected}, 
\par
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa89e805c9c75c39ecc8371d5f38131227}{Connecting}, 
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa3c3620c8eb4ddb126568053e3d49195f}{Connected}, 
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daaf2ba40e19587c3a98235ee96a4acf20e}{Ready}, 
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa5da3fa5dd98a264ecb4a37a1983ea0ff}{Busy}
 \}
\begin{DoxyCompactList}\small\item\em State of device. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Slots}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classmdt_port_manager_a1d185e9bb610aee16ccd9499ae7bff0d}{abort} ()
\begin{DoxyCompactList}\small\item\em Cancel read and write operations. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Signals}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_port_manager_a416a24db1048e9f66aef27ea810954d2}{newTransactionDone} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Emitted each time a transaction is done. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a6f6c6f8a8430d8631a08c765565db9ab}{statusMessageChanged} (const QString \&message, const QString \&details, int timeout)
\begin{DoxyCompactList}\small\item\em Emitted when a new status message is to display. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a01da0634bc52a71c0df0d83fc166eeda}{
void \hyperlink{classmdt_port_manager_a01da0634bc52a71c0df0d83fc166eeda}{stateChanged} (int stateId)}
\label{classmdt_port_manager_a01da0634bc52a71c0df0d83fc166eeda}

\begin{DoxyCompactList}\small\item\em Emitted each time the state changed. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ae00d513ed335fbd203852dcb7180005c}{stateChangedForUi} (int stateId, const QString \&stateText, int ledColorId, bool ledIsOn)
\begin{DoxyCompactList}\small\item\em Emitted only if a state that must be notified is entered. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ae77c1b24291797704488beda0009c57a}{pmPortClosedEvent} ()
\begin{DoxyCompactList}\small\item\em Sent when port was closed. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_aa12ccb053b3ce050a2482a957b28222e}{pmStartThreadsEvent} ()
\begin{DoxyCompactList}\small\item\em Sent when threads must be started. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a7b81ee6491167fa17574d840720d9b33}{pmStopThreadsEvent} ()
\begin{DoxyCompactList}\small\item\em Sent when threads must be stopped. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a6dd5529e6de23897fe5082ee4a33fa3d}{pmAllThreadsReadyEvent} ()
\begin{DoxyCompactList}\small\item\em Sent when all threads are ready. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a1bfd4d20867ecae2cad1b95b52860b12}{pmAllThreadsStoppedEvent} ()
\begin{DoxyCompactList}\small\item\em Sent when all threads are stopped. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a94d3fa4a26f8686449313a54003f0b4d}{pmUnhandledErrorEvent} ()
\begin{DoxyCompactList}\small\item\em Sent when a unhandled error occured. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a04fb1d09af226677cacd6f0e485d9810}{pmConnectingEvent} ()
\begin{DoxyCompactList}\small\item\em Sent when connection with device beginns. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a871ec7f9676a12c84196404285cf2161}{pmConnectedEvent} ()
\begin{DoxyCompactList}\small\item\em Sent when connection with device is established. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ab4667ac04a31166eeb7b5f92893b16db}{pmDisconnectedEvent} ()
\begin{DoxyCompactList}\small\item\em Sent when connection with device was lost/closed. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a57fc083d7db52279ec6b990b75705552}{pmConnectionFailedEvent} ()
\begin{DoxyCompactList}\small\item\em Sent when connection failed on startup or after max try. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a5959d4025f4903eef0ea65c350f6f9b3}{pmBusyEvent} ()
\begin{DoxyCompactList}\small\item\em Sent when device is busy (or other slow down reason..) \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_aa23c17048773e345778e7d6393f630db}{pmReadyEvent} ()
\begin{DoxyCompactList}\small\item\em Sent when device and communication becomes ready again. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a0be3429f901fc9bf4adee196035d2cee}{pmTransactionTimeoutEvent} ()
\begin{DoxyCompactList}\small\item\em Sent when a transaction timeout occured. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_port_manager_a5ec36523089b7528d973e29cdbc64d01}{mdtPortManager} (QObject $\ast$parent=0)
\begin{DoxyCompactList}\small\item\em Contruct a port manager. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_port_manager_adf797f8fd7a3ffdc000890a224e4c1b6}{$\sim$mdtPortManager} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
virtual QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}{scan} ()
\begin{DoxyCompactList}\small\item\em Scan for available ports. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort} (\hyperlink{classmdt_abstract_port}{mdtAbstractPort} $\ast$port)
\begin{DoxyCompactList}\small\item\em Set port object. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a3107b7121dfe5b9686d9b3b3a48a0af0}{lockPortMutex} ()
\begin{DoxyCompactList}\small\item\em Lock the port's mutex. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a882e6bf95dac9cd4ab8cc93ecc524874}{unlockPortMutex} ()
\begin{DoxyCompactList}\small\item\em Unlock port's mutex. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a39cb4af4aedc0b6b7c4d4f53002c3fd1}{detachPort} (bool deletePort, bool deleteThreads)
\begin{DoxyCompactList}\small\item\em Detach port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}{addThread} (\hyperlink{classmdt_port_thread}{mdtPortThread} $\ast$thread)
\begin{DoxyCompactList}\small\item\em Add a thread and assign it to port. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_thread}{mdtPortThread} $\ast$ \hyperlink{classmdt_port_manager_ad9233b5156a45f2684783317d75fdf9b}{readThread} ()
\begin{DoxyCompactList}\small\item\em Returns instance of reader thread. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_thread}{mdtPortThread} $\ast$ \hyperlink{classmdt_port_manager_af44b6e9876e6687b1d4fe7e05ffd5a91}{writeThread} ()
\begin{DoxyCompactList}\small\item\em Returns instance of writer thread. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_aaa0a474183bcae0fff4fb9ef43023c25}{removeThreads} (bool releaseMemory)
\begin{DoxyCompactList}\small\item\em Detach threads from port and remove threads. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{start} ()
\begin{DoxyCompactList}\small\item\em Start port manager. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_aacbf87cc3d9c37c87e21696f8a6514bd}{stop} ()
\begin{DoxyCompactList}\small\item\em Stop port manager. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}{setPortName} (const QString \&portName)
\begin{DoxyCompactList}\small\item\em Set port name. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a7e2ef93ec2731e66aa2b2d5f7ce9bc1c}{setPortInfo} (\hyperlink{classmdt_port_info}{mdtPortInfo} info)
\begin{DoxyCompactList}\small\item\em Set port info. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}{
\hyperlink{classmdt_port_info}{mdtPortInfo} \hyperlink{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}{portInfo} ()}
\label{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}

\begin{DoxyCompactList}\small\item\em Get current port info. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_af4fcab6aaad98d74aeabfc972da1d406}{
QString \hyperlink{classmdt_port_manager_af4fcab6aaad98d74aeabfc972da1d406}{portName} () const }
\label{classmdt_port_manager_af4fcab6aaad98d74aeabfc972da1d406}

\begin{DoxyCompactList}\small\item\em Get current port name. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_port_config}{mdtPortConfig} \& \hyperlink{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{config} ()
\begin{DoxyCompactList}\small\item\em Get the port's config object. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_config}{mdtPortConfig} \& \hyperlink{classmdt_port_manager_a735b7dc766fc2f45fb2cf9772c4201b0}{config} () const 
\begin{DoxyCompactList}\small\item\em Get the port's config object. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a9adb5098766c9df588bc9978b00c5eb2}{setKeepTransactionsDone} (bool keep)
\begin{DoxyCompactList}\small\item\em Force transactions done to be keeped. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a798ce0939234870ae3b9995108e54380}{
bool \hyperlink{classmdt_port_manager_a798ce0939234870ae3b9995108e54380}{keepTransactionsDone} () const }
\label{classmdt_port_manager_a798ce0939234870ae3b9995108e54380}

\begin{DoxyCompactList}\small\item\em Get the keepTransactionsDone flag. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$ \hyperlink{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}{getNewTransaction} ()
\begin{DoxyCompactList}\small\item\em Get a new transaction. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}{restoreTransaction} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Restore a transaction into pool. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_port_manager_ad98399edba146af5cf32a9002094385c}{sendData} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Send data on port. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_port_manager_a445b27f0819158f67f1bd548cdd2fedf}{sendData} (const QByteArray \&data, bool queryReplyMode=false)
\begin{DoxyCompactList}\small\item\em Send data to port. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_a5551802de2c08632078f2cc0e2607913}{waitTransactionDone} (int id)
\begin{DoxyCompactList}\small\item\em Wait until a transaction is done. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_af60f089baded850018cbb90645c8e547}{waitOneTransactionDone} ()
\begin{DoxyCompactList}\small\item\em Wait until current transaction is done. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_aaa85e0200aba0e0f4392dfe01abae2cf}{wait} (int ms)
\begin{DoxyCompactList}\small\item\em Wait for some time. \end{DoxyCompactList}\item 
QByteArray \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame} (int id)
\begin{DoxyCompactList}\small\item\em Get data by frame ID. \end{DoxyCompactList}\item 
QList$<$ QByteArray $>$ \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames} ()
\begin{DoxyCompactList}\small\item\em Get all readen data. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_port_manager_ac0844a5cd4043a95a479d458ac7ce590}{flushIn} (bool flushPortManagerBuffers, bool flushPortBuffers)
\begin{DoxyCompactList}\small\item\em Flush input buffers. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a4c44ce6ec40c4afc6be441c10d7ee827}{flushIn} ()
\begin{DoxyCompactList}\small\item\em Flush input buffers. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_port_manager_a3f0c2722a41c49de2bea9013bccd049c}{flushOut} (bool flushPortManagerBuffers, bool flushPortBuffers)
\begin{DoxyCompactList}\small\item\em Flush output buffers. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ab34018a9653a5af784fa7da06a9e50d3}{flushOut} ()
\begin{DoxyCompactList}\small\item\em Flush output buffers. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a97b91e7c1641836eb6afb47fd244a18e}{flush} (bool flushPortManagerBuffers, bool flushPortBuffers)
\begin{DoxyCompactList}\small\item\em Flush I/O buffers. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a3eab774008d7530ae341ce9c38265d65}{flush} ()
\begin{DoxyCompactList}\small\item\em Flush I/O buffers. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a59241d9e6b6ee71e6c1aeb3e6c0ca81a}{
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382da}{state\_\-t} \hyperlink{classmdt_port_manager_a59241d9e6b6ee71e6c1aeb3e6c0ca81a}{currentState} () const }
\label{classmdt_port_manager_a59241d9e6b6ee71e6c1aeb3e6c0ca81a}

\begin{DoxyCompactList}\small\item\em Get current state. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a0c460b47b12e38e708321be79f6343d8}{notifyCurrentState} ()
\begin{DoxyCompactList}\small\item\em Notify the current state. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classmdt_port_manager_a6dc2798324521d177fb8f79d4f6c5f0f}{isReady} () const 
\begin{DoxyCompactList}\small\item\em Check if port manager is ready. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_aeecbec49376838ab3547729636166d97}{isClosed} () const 
\begin{DoxyCompactList}\small\item\em Check if port is closed. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Slots}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{fromThreadNewFrameReaden} ()
\begin{DoxyCompactList}\small\item\em Called by the read thread whenn a complete frame was readen. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}{onThreadsErrorOccured} (int error)
\begin{DoxyCompactList}\small\item\em Manage errors comming from port threads. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual bool \hyperlink{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{openPort} ()
\begin{DoxyCompactList}\small\item\em Open the port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ace8065f1f5083041ee7f65c2892bc77d}{closePort} ()
\begin{DoxyCompactList}\small\item\em Close the port. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a3f1d25b2441c467c0de9908c73422a93}{
void \hyperlink{classmdt_port_manager_a3f1d25b2441c467c0de9908c73422a93}{setCurrentTransactionId} (int id)}
\label{classmdt_port_manager_a3f1d25b2441c467c0de9908c73422a93}

\begin{DoxyCompactList}\small\item\em Set the current transaction ID. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a19abf29c8948cde0337d67c9722c25aa}{
int \hyperlink{classmdt_port_manager_a19abf29c8948cde0337d67c9722c25aa}{currentTransactionId} () const }
\label{classmdt_port_manager_a19abf29c8948cde0337d67c9722c25aa}

\begin{DoxyCompactList}\small\item\em Get the current transaction ID. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a4d009936a0a5130f3bfecb69fee4ce42}{
void \hyperlink{classmdt_port_manager_a4d009936a0a5130f3bfecb69fee4ce42}{incrementCurrentTransactionId} (int min=0, int max=INT\_\-MAX)}
\label{classmdt_port_manager_a4d009936a0a5130f3bfecb69fee4ce42}

\begin{DoxyCompactList}\small\item\em Increment current transaction ID. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_ac04a12f8aa20ba04695083afce45a6cc}{waitTransactionPossible} ()
\begin{DoxyCompactList}\small\item\em Wait until transaction pending queue has less than maximum possible items. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ac58ed84e0e9230d1931557bc4bbe8a50}{addTransactionPending} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Add a transaction to pending queue. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$ \hyperlink{classmdt_port_manager_a18478707a9be7638b06cde48ced48297}{transactionPending} (int id)
\begin{DoxyCompactList}\small\item\em Take pending transaction matching id. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}{
void \hyperlink{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}{flushTransactionsPending} ()}
\label{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}

\begin{DoxyCompactList}\small\item\em Restore all transactions pending to pool. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a4b584d9005316be9991e6026e4c5e5a4}{addTransactionDone} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Add a transaction to the DONE queue. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a3293066f4c3ed2e4b116f28dca8c5d64}{
bool \hyperlink{classmdt_port_manager_a3293066f4c3ed2e4b116f28dca8c5d64}{transactionsDoneContains} (int id) const }
\label{classmdt_port_manager_a3293066f4c3ed2e4b116f28dca8c5d64}

\begin{DoxyCompactList}\small\item\em Check if a transaction with given ID exists in done queue. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$ \hyperlink{classmdt_port_manager_a5869bcf6774a86fb9d3b00a0d4211bb5}{transactionDone} (int id)
\begin{DoxyCompactList}\small\item\em Take transaction from DONE queue matching id. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_aad801de5f93a3619d98b7ea3cae6b999}{
void \hyperlink{classmdt_port_manager_aad801de5f93a3619d98b7ea3cae6b999}{flushTransactionsDone} ()}
\label{classmdt_port_manager_aad801de5f93a3619d98b7ea3cae6b999}

\begin{DoxyCompactList}\small\item\em Restore all transactions done to pool. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_adeeba5a216174fcc1d01446a9537f40e}{startTransactionTimer} (int timeout)
\begin{DoxyCompactList}\small\item\em Start transaction timer. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a1467c0bd28612ae3116f5daba08c0b84}{stopTransactionTimer} ()
\begin{DoxyCompactList}\small\item\em Stop transaction timer. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_a04fc12f0dc02e981cac8dc56539e63d2}{transactionTimeoutOccured} () const 
\begin{DoxyCompactList}\small\item\em Check if a transaction timeout occured. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a84d37b380080eb26e56c68424dedd958}{commitFrames} ()
\begin{DoxyCompactList}\small\item\em Emit signals for each done transactions. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_port_manager_af856162aab4f1c5202c1dfb330fae538}{
\hyperlink{classmdt_abstract_port}{mdtAbstractPort} $\ast$ {\bfseries pvPort}}
\label{classmdt_port_manager_af856162aab4f1c5202c1dfb330fae538}

\item 
\hypertarget{classmdt_port_manager_a8e0d49b789f8b01d469e84b487799573}{
QList$<$ \hyperlink{classmdt_port_thread}{mdtPortThread} $\ast$ $>$ {\bfseries pvThreads}}
\label{classmdt_port_manager_a8e0d49b789f8b01d469e84b487799573}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Port manager base class. 

\begin{Desc}
\item[\hyperlink{todo__todo000040}{Todo}]Port manager has no raison to inherit QThread -\/$>$ make it inherit QObject \end{Desc}


Manages a port based on \hyperlink{classmdt_abstract_port}{mdtAbstractPort} an several threads based on \hyperlink{classmdt_port_thread}{mdtPortThread}. The goal is to hide the complexity of the port API.

Example: 
\begin{DoxyCode}
 mdtPortManager m;
 mdtPort *port;
 mdtPortConfig *config;
 QList<QByteArray> responses;

 // Setup
 config = new mdtPortConfig;
 config->setFrameType(mdtFrame::FT_ASCII);
 config->setEndOfFrameSeq("$");

 // Init port
 port = new mdtPort;
 port->setConfig(config);

 // Init port manager - We wand blocking mode
 m.setTransactionsDisabled(true);
 m.setPort(port);
 m.addThread(mew mdtPortWriteThread);
 m.addThread(mew mdtPortReadThread);
 m.setPortName("/dev/xyz"));

 // Start port manager - Will open port, start threads and return once port manag
      er is ready
 if(!m.start()){
  // Handle error
 }

 // Send some data
 if(!m.writeData("Test$")){
  // Handle error
 }

 // Wait on answer - Timout: 1500 [ms]
 if(!m.waitReadenFrame(1500)){
  // Timout , handle error
 }

 // Do something with received data
 responses = m.readenFrames();
 for(int i=0; i<responses.size(); i++){
  qDebug() << responses.at(i);
 }

 // Stop port manager
 m.stop();

 // Cleanup - detachPort() will delete port and threads objects
 m.detachPort(true, true);
 delete config;
\end{DoxyCode}


A (recommended) alternative is to disable frames enqueuing and use the newReadenFrame(QByteArray) signal.
\begin{DoxyItemize}
\item Disable enqueuing with setTransactionsDisabled(false)
\item Connect newReadenFrame(QByteArray) to a slot
\end{DoxyItemize}

-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/

Manage a port based on \hyperlink{classmdt_abstract_port}{mdtAbstractPort} and related threads. Goal is to hide complexity of \hyperlink{classmdt_abstract_port}{mdtAbstractPort} API.

Depending on application, it's possible to use a event approach, or also a blocking approach with wait methods.

Some protocols support frame identifier (like MODBUS/TCP, USBTMC, or others), and other don't (for example raw bytes transfert on a serial port). For this reason, the concept of transactions is aodpted here. A transaction is based on \hyperlink{classmdt_port_transaction}{mdtPortTransaction} class. It was introduced for protocols that support identification, and can store some other meta data, usefull to decode a reply.

This base class can be used directly for ports that supports raw transfers. For specific protocol, it can be subclassed.

\begin{Desc}
\item[\hyperlink{todo__todo000041}{Todo}]Document init, open, close, ...\end{Desc}


Now, we can see the data transfer workflow:
\begin{DoxyItemize}
\item 1) Wait until it's possible to send some data with waitOnWriteReady()
\item 2) Get a new transaction with \hyperlink{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}{getNewTransaction()} , and setup it as needed (see remarks below).
\item 3) Send data using writeData(mdtPortTransaction$\ast$). This will set the currentTransactionId to the ID given in transaction.
\item 4a) If you choosed a blocking approach, use \hyperlink{classmdt_port_manager_a5551802de2c08632078f2cc0e2607913}{waitTransactionDone()}.
\item 4b) If you choosed a event approach, connect the \hyperlink{classmdt_port_manager_a5869bcf6774a86fb9d3b00a0d4211bb5}{transactionDone()} signal to a slot. Each time a transaction is done, you will receive a transaction.
\item 5) Get the transaction with \hyperlink{classmdt_port_manager_a5869bcf6774a86fb9d3b00a0d4211bb5}{transactionDone()}.
\item 6) Restore transaction with \hyperlink{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}{restoreTransaction()}.
\end{DoxyItemize}

Steps 2) and 3) can be done once by using writeData(const QByteArray\&, bool). Steps 5) and 6) can be done once by using getReadenData(int).

Here is a little example of the simple approach: 
\begin{DoxyCode}
 mdtPortManager m;
 int transactionId;
 // Setup...

 // Wait until we can write
 if(!waitOnWriteReady()){
   // Handle error
 }

 // Send data to port
 transactionId = writeData("SomeData", true);
 if(transactionId < 0){
   // Handle error
 }

 // Wait until data come in
 if(waitTransactionDone(transactionId)){
   // Handle error
 }

 // Get only data for a specific transaction (should be used only for protocols t
      hat support transaction)
 qDebug() << readenFrame(transactionId);
 // Get all received data
 qDebug() << readenFrames();
\end{DoxyCode}


Internally, once data was send to port's write queue, the transaction is stored in the pending transactions queue.

Dealing with incomming data: In above example, 2 methods are shown to get incomming data:
\begin{DoxyItemize}
\item \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame(int)} : will work with protocols that support frame ID. See specific port manager subclass for details.
\item \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()} : see below.
\end{DoxyItemize}

If we are using a protocol that not support frame ID, it's possible that we receive data each time, also without sending any request. This must be handled in \hyperlink{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{fromThreadNewFrameReaden()} slot. In this \hyperlink{classmdt_port_manager}{mdtPortManager} class, the following will happen:
\begin{DoxyItemize}
\item When sending data with writeData(const QByteArray\&, bool), current transaction ID will be incremented with \hyperlink{classmdt_port_manager_a4d009936a0a5130f3bfecb69fee4ce42}{incrementCurrentTransactionId()}.
\item In \hyperlink{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{fromThreadNewFrameReaden()} slot, \hyperlink{classmdt_port_manager_a19abf29c8948cde0337d67c9722c25aa}{currentTransactionId()} is used to get pending transaction with \hyperlink{classmdt_port_manager_a18478707a9be7638b06cde48ced48297}{transactionPending()}. If it was found, frame's data is copied, and transaction is moved to done queue. If not found, a new transaction is taken with \hyperlink{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}{getNewTransaction()}, frame's data is copied, and transaction is enqueued to done queue with \hyperlink{classmdt_port_manager_a4b584d9005316be9991e6026e4c5e5a4}{addTransactionDone()}.
\item \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()} will return a list of data that comes from transactions Done list. Current transaction ID will be restet to 0.
\end{DoxyItemize}

The Query/Reply mode: port manager is able to handle event or blocking mode in same time. This cause a problem for done transactions handling. For example, when we choosed the event based aproach for a transaction, port manager will emit the \hyperlink{classmdt_port_manager_a416a24db1048e9f66aef27ea810954d2}{newTransactionDone(mdtPortTransaction$\ast$)} signal, then restore transaction back to pool. When we choosed blocking approach, port manager will also emit \hyperlink{classmdt_port_manager_a416a24db1048e9f66aef27ea810954d2}{newTransactionDone(mdtPortTransaction$\ast$)} signal, wich can be usefull to keep, for example, a GUI coherent in each mode. But here, the transaction must not be restored directly, but only once data was readen with \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} or \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()}. To handle this, \hyperlink{classmdt_port_manager_a84d37b380080eb26e56c68424dedd958}{commitFrames()} will use \hyperlink{classmdt_port_transaction_a9da1cc7a191cd21a2e532d277aa3c628}{mdtPortTransaction::isQueryReplyMode()}. 

Definition at line 197 of file mdtPortManager.h.



\subsection{Member Enumeration Documentation}
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382da}{
\index{mdtPortManager@{mdtPortManager}!state\_\-t@{state\_\-t}}
\index{state\_\-t@{state\_\-t}!mdtPortManager@{mdtPortManager}}
\subsubsection[{state\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf mdtPortManager::state\_\-t}}}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382da}


State of device. 

States are handled by \hyperlink{classmdt_port_manager_state_machine}{mdtPortManagerStateMachine} \begin{Desc}
\item[Enumerator: ]\par
\begin{description}
\index{PortClosed@{PortClosed}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!PortClosed@{PortClosed}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daabac9679c411402c9db01399ecb72b84d}{
PortClosed}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daabac9679c411402c9db01399ecb72b84d}
}]Port is closed \index{Stopped@{Stopped}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!Stopped@{Stopped}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daadbd7b0395c62e9ae38525c5dc5ba44a6}{
Stopped}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daadbd7b0395c62e9ae38525c5dc5ba44a6}
}]Threads are stopped and port is closing \index{Starting@{Starting}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!Starting@{Starting}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daaca288962f5cb3d352f44f4e4c15f14d2}{
Starting}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daaca288962f5cb3d352f44f4e4c15f14d2}
}]Threads are starting \index{Stopping@{Stopping}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!Stopping@{Stopping}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa1c68525fc2c4d94e39a73d1a4bea0476}{
Stopping}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa1c68525fc2c4d94e39a73d1a4bea0476}
}]Threads are stopping \index{Running@{Running}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!Running@{Running}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daaa7af1c561e17e65982c027de942d4a75}{
Running}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daaa7af1c561e17e65982c027de942d4a75}
}]Global state (sub machine) \index{PortError@{PortError}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!PortError@{PortError}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa2440f5bfc7ae5c78db1598ef6d3d394c}{
PortError}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa2440f5bfc7ae5c78db1598ef6d3d394c}
}]A unhandled error occured -\/ Threads will be stopped and port closed \index{PortReady@{PortReady}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!PortReady@{PortReady}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa3a3b42b9d783381f3c7447086503fde6}{
PortReady}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa3a3b42b9d783381f3c7447086503fde6}
}]Port is open and threads are running. At this point, communication is possible if not connection is required (f.ex. serial port terminal) \index{Disconnected@{Disconnected}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!Disconnected@{Disconnected}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa4004253e25d51b1e628bb5006dbbd153}{
Disconnected}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa4004253e25d51b1e628bb5006dbbd153}
}]Port is ready, but not connected to device \index{Connecting@{Connecting}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!Connecting@{Connecting}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa89e805c9c75c39ecc8371d5f38131227}{
Connecting}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa89e805c9c75c39ecc8371d5f38131227}
}]Trying to connect to device \index{Connected@{Connected}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!Connected@{Connected}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa3c3620c8eb4ddb126568053e3d49195f}{
Connected}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa3c3620c8eb4ddb126568053e3d49195f}
}]Global state (sub machine) \index{Ready@{Ready}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!Ready@{Ready}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daaf2ba40e19587c3a98235ee96a4acf20e}{
Ready}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daaf2ba40e19587c3a98235ee96a4acf20e}
}]Port is ready and connection to device was made. Communication is possible \index{Busy@{Busy}!mdtPortManager@{mdtPortManager}}\index{mdtPortManager@{mdtPortManager}!Busy@{Busy}}\item[{\em 
\hypertarget{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa5da3fa5dd98a264ecb4a37a1983ea0ff}{
Busy}
\label{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa5da3fa5dd98a264ecb4a37a1983ea0ff}
}]Port is up and device is connected but cannot accept requests for the moment \end{description}
\end{Desc}



Definition at line 207 of file mdtPortManager.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_port_manager_a5ec36523089b7528d973e29cdbc64d01}{
\index{mdtPortManager@{mdtPortManager}!mdtPortManager@{mdtPortManager}}
\index{mdtPortManager@{mdtPortManager}!mdtPortManager@{mdtPortManager}}
\subsubsection[{mdtPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtPortManager::mdtPortManager (
\begin{DoxyParamCaption}
\item[{QObject $\ast$}]{parent = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a5ec36523089b7528d973e29cdbc64d01}


Contruct a port manager. 

keepTransactionsDone flag will be unset (set false). 

Definition at line 32 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_adf797f8fd7a3ffdc000890a224e4c1b6}{
\index{mdtPortManager@{mdtPortManager}!$\sim$mdtPortManager@{$\sim$mdtPortManager}}
\index{$\sim$mdtPortManager@{$\sim$mdtPortManager}!mdtPortManager@{mdtPortManager}}
\subsubsection[{$\sim$mdtPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtPortManager::$\sim$mdtPortManager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_adf797f8fd7a3ffdc000890a224e4c1b6}


Destructor. 

If a port was set, the manager will stop (if running), and port will be closed (if open).

Note that port set by \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} and threads are not deleted. This is because port and threads are set by subclass, or from application. 

Definition at line 59 of file mdtPortManager.cpp.



\subsection{Member Function Documentation}
\hypertarget{classmdt_port_manager_a1d185e9bb610aee16ccd9499ae7bff0d}{
\index{mdtPortManager@{mdtPortManager}!abort@{abort}}
\index{abort@{abort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{abort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::abort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual, slot\mbox{]}}}}
\label{classmdt_port_manager_a1d185e9bb610aee16ccd9499ae7bff0d}


Cancel read and write operations. 

Default implementation calls \hyperlink{classmdt_abstract_port_abde440c49b95833f821e1333c40a7398}{mdtAbstractPort::flush()}. 

Definition at line 596 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}{
\index{mdtPortManager@{mdtPortManager}!addThread@{addThread}}
\index{addThread@{addThread}!mdtPortManager@{mdtPortManager}}
\subsubsection[{addThread}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::addThread (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortThread} $\ast$}]{thread}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}


Add a thread and assign it to port. 

\begin{DoxyPrecond}{Precondition}
Port must be set with setPort before using this method 

Manager must no running 

Port manager must be closed (see \hyperlink{classmdt_port_manager_aeecbec49376838ab3547729636166d97}{isClosed()} ). 
\end{DoxyPrecond}


Definition at line 122 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a4b584d9005316be9991e6026e4c5e5a4}{
\index{mdtPortManager@{mdtPortManager}!addTransactionDone@{addTransactionDone}}
\index{addTransactionDone@{addTransactionDone}!mdtPortManager@{mdtPortManager}}
\subsubsection[{addTransactionDone}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::addTransactionDone (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a4b584d9005316be9991e6026e4c5e5a4}


Add a transaction to the DONE queue. 

\begin{DoxyPrecond}{Precondition}
transaction must be a valid pointer. 
\end{DoxyPrecond}


Definition at line 720 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ac58ed84e0e9230d1931557bc4bbe8a50}{
\index{mdtPortManager@{mdtPortManager}!addTransactionPending@{addTransactionPending}}
\index{addTransactionPending@{addTransactionPending}!mdtPortManager@{mdtPortManager}}
\subsubsection[{addTransactionPending}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::addTransactionPending (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_ac58ed84e0e9230d1931557bc4bbe8a50}


Add a transaction to pending queue. 

Add a existing transaction to the pending queue. A transaction can be requested with \hyperlink{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}{getNewTransaction()}.

\begin{DoxyPrecond}{Precondition}
transaction must be a valid pointer. 

transaction ID must not allready exist in queue. 
\end{DoxyPrecond}


qDebug() $<$$<$ \char`\"{}Add transaction pending: \char`\"{} $<$$<$ transaction $<$$<$ \char`\"{} , ID: \char`\"{} $<$$<$ transaction-\/$>$id() $<$$<$ \char`\"{} data: \char`\"{} $<$$<$ transaction-\/$>$data(); 



Definition at line 675 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ace8065f1f5083041ee7f65c2892bc77d}{
\index{mdtPortManager@{mdtPortManager}!closePort@{closePort}}
\index{closePort@{closePort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{closePort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::closePort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_ace8065f1f5083041ee7f65c2892bc77d}


Close the port. 

If port was never set (with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} ), this method does nothing. 

Definition at line 618 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a84d37b380080eb26e56c68424dedd958}{
\index{mdtPortManager@{mdtPortManager}!commitFrames@{commitFrames}}
\index{commitFrames@{commitFrames}!mdtPortManager@{mdtPortManager}}
\subsubsection[{commitFrames}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::commitFrames (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a84d37b380080eb26e56c68424dedd958}


Emit signals for each done transactions. 

Will emit \hyperlink{classmdt_port_manager_a416a24db1048e9f66aef27ea810954d2}{newTransactionDone(mdtPortTransaction$\ast$)} for each transaction found in done queue.

If queryReplyMode and keepTransactionsDone are not set, the transaction is restored back to pool, else it will be restored only after a call of \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} or \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()}. 

Definition at line 791 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{
\index{mdtPortManager@{mdtPortManager}!config@{config}}
\index{config@{config}!mdtPortManager@{mdtPortManager}}
\subsubsection[{config}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortConfig} \& mdtPortManager::config (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}


Get the port's config object. 

Usefull to alter internal port configuration

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_serial_port_manager_a4b8ab7b9d53966a1887d9ce8557b8416}{mdtSerialPortManager}.



Definition at line 264 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a735b7dc766fc2f45fb2cf9772c4201b0}{
\index{mdtPortManager@{mdtPortManager}!config@{config}}
\index{config@{config}!mdtPortManager@{mdtPortManager}}
\subsubsection[{config}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortConfig} \& mdtPortManager::config (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_port_manager_a735b7dc766fc2f45fb2cf9772c4201b0}


Get the port's config object. 

Usefull to read internal port configuration

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Definition at line 271 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a39cb4af4aedc0b6b7c4d4f53002c3fd1}{
\index{mdtPortManager@{mdtPortManager}!detachPort@{detachPort}}
\index{detachPort@{detachPort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{detachPort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::detachPort (
\begin{DoxyParamCaption}
\item[{bool}]{deletePort, }
\item[{bool}]{deleteThreads}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a39cb4af4aedc0b6b7c4d4f53002c3fd1}


Detach port. 

Will detach port from each thread and from port manager. If port was not set, this method does nothing. If manager is running, it will be stopped. If port is open, it will be closed.


\begin{DoxyParams}{Parameters}
{\em deletePort} & If true, the port object that was set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} will be deleted. \\
\hline
{\em deleteThreads} & If true, each thread added with \hyperlink{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}{addThread()} will be deleted. \\
\hline
\end{DoxyParams}


Definition at line 102 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a97b91e7c1641836eb6afb47fd244a18e}{
\index{mdtPortManager@{mdtPortManager}!flush@{flush}}
\index{flush@{flush}!mdtPortManager@{mdtPortManager}}
\subsubsection[{flush}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::flush (
\begin{DoxyParamCaption}
\item[{bool}]{flushPortManagerBuffers, }
\item[{bool}]{flushPortBuffers}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a97b91e7c1641836eb6afb47fd244a18e}


Flush I/O buffers. 


\begin{DoxyParams}{Parameters}
{\em flushPortManagerBuffers} & If true, port manager buffers will be cleared. (Has no effect in this implementation, but some subclass can have output buffers). \\
\hline
{\em flushPortBuffers} & If true, port's buffers will be cleared. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before calling this method. 
\end{DoxyPrecond}


Definition at line 552 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a3eab774008d7530ae341ce9c38265d65}{
\index{mdtPortManager@{mdtPortManager}!flush@{flush}}
\index{flush@{flush}!mdtPortManager@{mdtPortManager}}
\subsubsection[{flush}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::flush (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a3eab774008d7530ae341ce9c38265d65}


Flush I/O buffers. 

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before calling this method. 
\end{DoxyPrecond}


Definition at line 563 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ac0844a5cd4043a95a479d458ac7ce590}{
\index{mdtPortManager@{mdtPortManager}!flushIn@{flushIn}}
\index{flushIn@{flushIn}!mdtPortManager@{mdtPortManager}}
\subsubsection[{flushIn}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::flushIn (
\begin{DoxyParamCaption}
\item[{bool}]{flushPortManagerBuffers, }
\item[{bool}]{flushPortBuffers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_ac0844a5cd4043a95a479d458ac7ce590}


Flush input buffers. 


\begin{DoxyParams}{Parameters}
{\em flushPortManagerBuffers} & If true, port manager buffers (transactions done and pending) will be cleared. \\
\hline
{\em flushPortBuffers} & If true, port's buffers will be cleared. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before calling this method. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_usb_port_manager_a982256ed17db155e1c95d544683a6dba}{mdtUsbPortManager}.



Definition at line 518 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a4c44ce6ec40c4afc6be441c10d7ee827}{
\index{mdtPortManager@{mdtPortManager}!flushIn@{flushIn}}
\index{flushIn@{flushIn}!mdtPortManager@{mdtPortManager}}
\subsubsection[{flushIn}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::flushIn (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a4c44ce6ec40c4afc6be441c10d7ee827}


Flush input buffers. 

Will flush portmanger and port's buffers.

Internally, \hyperlink{classmdt_port_manager_ac0844a5cd4043a95a479d458ac7ce590}{flushIn(bool, bool)} is called. 

Definition at line 535 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ab34018a9653a5af784fa7da06a9e50d3}{
\index{mdtPortManager@{mdtPortManager}!flushOut@{flushOut}}
\index{flushOut@{flushOut}!mdtPortManager@{mdtPortManager}}
\subsubsection[{flushOut}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::flushOut (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_ab34018a9653a5af784fa7da06a9e50d3}


Flush output buffers. 

Will flush portmanger and port's buffers.

Internally, \hyperlink{classmdt_port_manager_a3f0c2722a41c49de2bea9013bccd049c}{flushOut(bool, bool)} is called. 

Definition at line 547 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a3f0c2722a41c49de2bea9013bccd049c}{
\index{mdtPortManager@{mdtPortManager}!flushOut@{flushOut}}
\index{flushOut@{flushOut}!mdtPortManager@{mdtPortManager}}
\subsubsection[{flushOut}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::flushOut (
\begin{DoxyParamCaption}
\item[{bool}]{flushPortManagerBuffers, }
\item[{bool}]{flushPortBuffers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_a3f0c2722a41c49de2bea9013bccd049c}


Flush output buffers. 


\begin{DoxyParams}{Parameters}
{\em flushPortManagerBuffers} & If true, port manager buffers will be cleared. (Has no effect in this implementation, but some subclass can have output buffers). \\
\hline
{\em flushPortBuffers} & If true, port's buffers will be cleared. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before calling this method. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_usb_port_manager_ab723086376175c40635df44adf358985}{mdtUsbPortManager}.



Definition at line 540 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{
\index{mdtPortManager@{mdtPortManager}!fromThreadNewFrameReaden@{fromThreadNewFrameReaden}}
\index{fromThreadNewFrameReaden@{fromThreadNewFrameReaden}!mdtPortManager@{mdtPortManager}}
\subsubsection[{fromThreadNewFrameReaden}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::fromThreadNewFrameReaden (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual, slot\mbox{]}}}}
\label{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}


Called by the read thread whenn a complete frame was readen. 

This variant will add data to transactions done queue. If pending transactions queue contains \hyperlink{classmdt_port_manager_a19abf29c8948cde0337d67c9722c25aa}{currentTransactionId()}, it will be removed.

For subclass that handle frames with IDs, this method must be reimplemented. The normal way is to get the frame in pending queue with \hyperlink{classmdt_port_manager_a18478707a9be7638b06cde48ced48297}{transactionPending()}. For frames with ID that not exists in pending queue, it must be choosen to discard them, or adopt another behaviour.

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_thread}{mdtPortThread}
\end{DoxySeeAlso}
\begin{Desc}
\item[\hyperlink{todo__todo000039}{Todo}]A méditer: \end{Desc}
-\/ Lock le mutex
\begin{DoxyItemize}
\item Prendre les frames disponibles (-\/$>$ sdans une liste ...)
\item Libéréer le mutex
\item Effectier les traitements
\item Lock le mutex
\item Restituer les frames
\item Libéréer le mutex 
\end{DoxyItemize}

Reimplemented in \hyperlink{classmdt_modbus_tcp_port_manager_ad941ea607f00db54aa6deb2866a539e9}{mdtModbusTcpPortManager}, and \hyperlink{classmdt_usbtmc_port_manager_aca42b343ae1f6a324e6e45968f03bbea}{mdtUsbtmcPortManager}.



Definition at line 816 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}{
\index{mdtPortManager@{mdtPortManager}!getNewTransaction@{getNewTransaction}}
\index{getNewTransaction@{getNewTransaction}!mdtPortManager@{mdtPortManager}}
\subsubsection[{getNewTransaction}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortTransaction} $\ast$ mdtPortManager::getNewTransaction (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}


Get a new transaction. 

If transactions pool is empty, a new transaction is created. Note that each transaction should be put back in pool with \hyperlink{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}{restoreTransaction()}. In most cases, if a method that uses transactions fails, the transaction must be restored with \hyperlink{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}{restoreTransaction()}. See writeData(mdtPortTransaction$\ast$), writeData(const QByteArray\&), \hyperlink{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}{flushTransactionsPending()}, \hyperlink{classmdt_port_manager_aad801de5f93a3619d98b7ea3cae6b999}{flushTransactionsDone()}, \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} and \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()} for details about restoration of transaction.

\begin{DoxyReturn}{Returns}
A empty transaction (\hyperlink{classmdt_port_transaction_a5f7b04df58291d52e61c5bd1b7f7bb7f}{mdtPortTransaction::clear()} is called internally).
\end{DoxyReturn}
\begin{DoxyPostcond}{Postcondition}
Returned transaction is valid (never Null). 
\end{DoxyPostcond}


Definition at line 288 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_aeecbec49376838ab3547729636166d97}{
\index{mdtPortManager@{mdtPortManager}!isClosed@{isClosed}}
\index{isClosed@{isClosed}!mdtPortManager@{mdtPortManager}}
\subsubsection[{isClosed}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::isClosed (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_port_manager_aeecbec49376838ab3547729636166d97}


Check if port is closed. 

Returns true if threads are all stopped and port is closed 

Definition at line 591 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a6dc2798324521d177fb8f79d4f6c5f0f}{
\index{mdtPortManager@{mdtPortManager}!isReady@{isReady}}
\index{isReady@{isReady}!mdtPortManager@{mdtPortManager}}
\subsubsection[{isReady}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::isReady (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_a6dc2798324521d177fb8f79d4f6c5f0f}


Check if port manager is ready. 

Internally, the currentState is used to check if port manager is ready. This implementation returns true if currentState is PortReady or Ready.

For some port type, it can be mandatory to be connected to device before any data can be transferred. In such case, reimplement this method. 

Reimplemented in \hyperlink{classmdt_modbus_tcp_port_manager_a5477eb7e8d57c5a42004046b426e39b6}{mdtModbusTcpPortManager}, and \hyperlink{classmdt_usbtmc_port_manager_a0b90ceb0bbf424222ec878a355d206d7}{mdtUsbtmcPortManager}.



Definition at line 582 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a3107b7121dfe5b9686d9b3b3a48a0af0}{
\index{mdtPortManager@{mdtPortManager}!lockPortMutex@{lockPortMutex}}
\index{lockPortMutex@{lockPortMutex}!mdtPortManager@{mdtPortManager}}
\subsubsection[{lockPortMutex}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::lockPortMutex (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a3107b7121dfe5b9686d9b3b3a48a0af0}


Lock the port's mutex. 

This method will check a internal flag before locking port's mutex. If the flag syas that mutex is allready locked, a warning is logged with \hyperlink{classmdt_error}{mdtError} system. Then, this method reurns without locking the port mutex again.

\begin{DoxyPrecond}{Precondition}
Port must be set with setPort before using this method 
\end{DoxyPrecond}


Definition at line 80 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a416a24db1048e9f66aef27ea810954d2}{
\index{mdtPortManager@{mdtPortManager}!newTransactionDone@{newTransactionDone}}
\index{newTransactionDone@{newTransactionDone}!mdtPortManager@{mdtPortManager}}
\subsubsection[{newTransactionDone}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::newTransactionDone (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a416a24db1048e9f66aef27ea810954d2}


Emitted each time a transaction is done. 

Note: the transaction pointer is only valid for one call, do not store it for later usage. Connect this signal to a slot that runs in GUI thread only.

This signal is emited by \hyperlink{classmdt_port_manager_a84d37b380080eb26e56c68424dedd958}{commitFrames()}. \hypertarget{classmdt_port_manager_a0c460b47b12e38e708321be79f6343d8}{
\index{mdtPortManager@{mdtPortManager}!notifyCurrentState@{notifyCurrentState}}
\index{notifyCurrentState@{notifyCurrentState}!mdtPortManager@{mdtPortManager}}
\subsubsection[{notifyCurrentState}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::notifyCurrentState (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a0c460b47b12e38e708321be79f6343d8}


Notify the current state. 

Will force to emit \hyperlink{classmdt_port_manager_a01da0634bc52a71c0df0d83fc166eeda}{stateChanged()} and \hyperlink{classmdt_port_manager_ae00d513ed335fbd203852dcb7180005c}{stateChangedForUi()} .

Can be usefull during application setup, because some initial states (like PortClosed) are directly notified, probably before signals are connected to application slots. 

Definition at line 575 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}{
\index{mdtPortManager@{mdtPortManager}!onThreadsErrorOccured@{onThreadsErrorOccured}}
\index{onThreadsErrorOccured@{onThreadsErrorOccured}!mdtPortManager@{mdtPortManager}}
\subsubsection[{onThreadsErrorOccured}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::onThreadsErrorOccured (
\begin{DoxyParamCaption}
\item[{int}]{error}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual, slot\mbox{]}}}}
\label{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}


Manage errors comming from port threads. 

This implementation will handle some common errors, change the current state emiting transistion signal. If state has changed, \hyperlink{classmdt_port_manager_a01da0634bc52a71c0df0d83fc166eeda}{stateChanged()} signal is emited.

Handled errors are:
\begin{DoxyItemize}
\item NoError: go to ready state.
\item WriteCanceled: flush pending transaction with \hyperlink{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}{flushTransactionsPending()} and go to warning state.
\item WriteTimeout: flush pending transaction with \hyperlink{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}{flushTransactionsPending()} and go to busy state.
\item WritePoolEmpty: go to busy state.
\item ReadCanceled: flush pending transaction with \hyperlink{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}{flushTransactionsPending()}, done transactions with \hyperlink{classmdt_port_manager_aad801de5f93a3619d98b7ea3cae6b999}{flushTransactionsDone()} and go to warning state.
\item ReadTimeout: flush pending transaction with \hyperlink{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}{flushTransactionsPending()}, done transactions with \hyperlink{classmdt_port_manager_aad801de5f93a3619d98b7ea3cae6b999}{flushTransactionsDone()} and go to busy state.
\item ReadPoolEmpty: go to busy state.
\item Disconnected: flush pending transaction with \hyperlink{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}{flushTransactionsPending()}, done transactions with \hyperlink{classmdt_port_manager_aad801de5f93a3619d98b7ea3cae6b999}{flushTransactionsDone()} and go to disconnected state.
\item Connecting: go to connecting state.
\end{DoxyItemize}

For other errors, including UnhandledError, pending transactions are flushed with \hyperlink{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}{flushTransactionsPending()}, done transactions are flushed with \hyperlink{classmdt_port_manager_aad801de5f93a3619d98b7ea3cae6b999}{flushTransactionsDone()} and state will become error state.

For other cases, the subclass can reimplement this method. Dont forget to emit transistion signals. 

emit(handledError());

emit(handledError());

case \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea44eaa84d8f888f4f9d5c814291e54079}{mdtAbstractPort::ControlCanceled}: emit(handledError()); break;

\hyperlink{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}{flushTransactionsPending()}; \hyperlink{classmdt_port_manager_aad801de5f93a3619d98b7ea3cae6b999}{flushTransactionsDone()};

\hyperlink{classmdt_port_manager_a85b87522eb9ec9b80ff24e3ad2ef4a00}{flushTransactionsPending()};

case \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eabdb5a36cd2c7dd2dcf59e996fc4922c9}{mdtAbstractPort::ControlTimeout}: emit(busy()); break;

case \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea6e24e272af4da51c84eef5825c5cd712}{mdtAbstractPort::UnhandledError}: emit(unhandledError()); break;

emit(unhandledError()); 



Reimplemented in \hyperlink{classmdt_usb_port_manager_ad6cbef2c218efe73fdad6d5f598f743f}{mdtUsbPortManager}.



Definition at line 861 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{
\index{mdtPortManager@{mdtPortManager}!openPort@{openPort}}
\index{openPort@{openPort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{openPort}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::openPort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}


Open the port. 

Will try to open port defined with \hyperlink{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}{setPortName()} or \hyperlink{classmdt_port_manager_a7e2ef93ec2731e66aa2b2d5f7ce9bc1c}{setPortInfo()}

\begin{DoxyReturn}{Returns}
True on success, false else. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}
\begin{Desc}
\item[\hyperlink{todo__todo000042}{Todo}]Should return \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \end{Desc}


\begin{Desc}
\item[\hyperlink{todo__todo000038}{Todo}]Handle and/or display error $<$-\/ Note: no graphical dialog here ! Or.. yes ? \end{Desc}




Definition at line 603 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a6dd5529e6de23897fe5082ee4a33fa3d}{
\index{mdtPortManager@{mdtPortManager}!pmAllThreadsReadyEvent@{pmAllThreadsReadyEvent}}
\index{pmAllThreadsReadyEvent@{pmAllThreadsReadyEvent}!mdtPortManager@{mdtPortManager}}
\subsubsection[{pmAllThreadsReadyEvent}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::pmAllThreadsReadyEvent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a6dd5529e6de23897fe5082ee4a33fa3d}


Sent when all threads are ready. 

Used by state machine \hypertarget{classmdt_port_manager_a1bfd4d20867ecae2cad1b95b52860b12}{
\index{mdtPortManager@{mdtPortManager}!pmAllThreadsStoppedEvent@{pmAllThreadsStoppedEvent}}
\index{pmAllThreadsStoppedEvent@{pmAllThreadsStoppedEvent}!mdtPortManager@{mdtPortManager}}
\subsubsection[{pmAllThreadsStoppedEvent}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::pmAllThreadsStoppedEvent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a1bfd4d20867ecae2cad1b95b52860b12}


Sent when all threads are stopped. 

Used by state machine \hypertarget{classmdt_port_manager_a5959d4025f4903eef0ea65c350f6f9b3}{
\index{mdtPortManager@{mdtPortManager}!pmBusyEvent@{pmBusyEvent}}
\index{pmBusyEvent@{pmBusyEvent}!mdtPortManager@{mdtPortManager}}
\subsubsection[{pmBusyEvent}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::pmBusyEvent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a5959d4025f4903eef0ea65c350f6f9b3}


Sent when device is busy (or other slow down reason..) 

Used by state machine \hypertarget{classmdt_port_manager_a871ec7f9676a12c84196404285cf2161}{
\index{mdtPortManager@{mdtPortManager}!pmConnectedEvent@{pmConnectedEvent}}
\index{pmConnectedEvent@{pmConnectedEvent}!mdtPortManager@{mdtPortManager}}
\subsubsection[{pmConnectedEvent}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::pmConnectedEvent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a871ec7f9676a12c84196404285cf2161}


Sent when connection with device is established. 

Used by state machine \hypertarget{classmdt_port_manager_a04fb1d09af226677cacd6f0e485d9810}{
\index{mdtPortManager@{mdtPortManager}!pmConnectingEvent@{pmConnectingEvent}}
\index{pmConnectingEvent@{pmConnectingEvent}!mdtPortManager@{mdtPortManager}}
\subsubsection[{pmConnectingEvent}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::pmConnectingEvent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a04fb1d09af226677cacd6f0e485d9810}


Sent when connection with device beginns. 

Used by state machine \hypertarget{classmdt_port_manager_a57fc083d7db52279ec6b990b75705552}{
\index{mdtPortManager@{mdtPortManager}!pmConnectionFailedEvent@{pmConnectionFailedEvent}}
\index{pmConnectionFailedEvent@{pmConnectionFailedEvent}!mdtPortManager@{mdtPortManager}}
\subsubsection[{pmConnectionFailedEvent}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::pmConnectionFailedEvent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a57fc083d7db52279ec6b990b75705552}


Sent when connection failed on startup or after max try. 

Used by state machine \hypertarget{classmdt_port_manager_ab4667ac04a31166eeb7b5f92893b16db}{
\index{mdtPortManager@{mdtPortManager}!pmDisconnectedEvent@{pmDisconnectedEvent}}
\index{pmDisconnectedEvent@{pmDisconnectedEvent}!mdtPortManager@{mdtPortManager}}
\subsubsection[{pmDisconnectedEvent}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::pmDisconnectedEvent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_ab4667ac04a31166eeb7b5f92893b16db}


Sent when connection with device was lost/closed. 

Used by state machine \hypertarget{classmdt_port_manager_ae77c1b24291797704488beda0009c57a}{
\index{mdtPortManager@{mdtPortManager}!pmPortClosedEvent@{pmPortClosedEvent}}
\index{pmPortClosedEvent@{pmPortClosedEvent}!mdtPortManager@{mdtPortManager}}
\subsubsection[{pmPortClosedEvent}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::pmPortClosedEvent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_ae77c1b24291797704488beda0009c57a}


Sent when port was closed. 

Used by state machine \hypertarget{classmdt_port_manager_aa23c17048773e345778e7d6393f630db}{
\index{mdtPortManager@{mdtPortManager}!pmReadyEvent@{pmReadyEvent}}
\index{pmReadyEvent@{pmReadyEvent}!mdtPortManager@{mdtPortManager}}
\subsubsection[{pmReadyEvent}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::pmReadyEvent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_aa23c17048773e345778e7d6393f630db}


Sent when device and communication becomes ready again. 

Used by state machine \hypertarget{classmdt_port_manager_aa12ccb053b3ce050a2482a957b28222e}{
\index{mdtPortManager@{mdtPortManager}!pmStartThreadsEvent@{pmStartThreadsEvent}}
\index{pmStartThreadsEvent@{pmStartThreadsEvent}!mdtPortManager@{mdtPortManager}}
\subsubsection[{pmStartThreadsEvent}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::pmStartThreadsEvent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_aa12ccb053b3ce050a2482a957b28222e}


Sent when threads must be started. 

Used by state machine \hypertarget{classmdt_port_manager_a7b81ee6491167fa17574d840720d9b33}{
\index{mdtPortManager@{mdtPortManager}!pmStopThreadsEvent@{pmStopThreadsEvent}}
\index{pmStopThreadsEvent@{pmStopThreadsEvent}!mdtPortManager@{mdtPortManager}}
\subsubsection[{pmStopThreadsEvent}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::pmStopThreadsEvent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a7b81ee6491167fa17574d840720d9b33}


Sent when threads must be stopped. 

Used by state machine \hypertarget{classmdt_port_manager_a0be3429f901fc9bf4adee196035d2cee}{
\index{mdtPortManager@{mdtPortManager}!pmTransactionTimeoutEvent@{pmTransactionTimeoutEvent}}
\index{pmTransactionTimeoutEvent@{pmTransactionTimeoutEvent}!mdtPortManager@{mdtPortManager}}
\subsubsection[{pmTransactionTimeoutEvent}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::pmTransactionTimeoutEvent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a0be3429f901fc9bf4adee196035d2cee}


Sent when a transaction timeout occured. 

A transaction timeout can be notified by a port thread, or/and internall transaction timer.

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_a04fc12f0dc02e981cac8dc56539e63d2}{transactionTimeoutOccured()} 

onTransactionTimeoutOccured() 

\hyperlink{classmdt_port_manager_adeeba5a216174fcc1d01446a9537f40e}{startTransactionTimer()} 

\hyperlink{classmdt_port_manager_a1467c0bd28612ae3116f5daba08c0b84}{stopTransactionTimer()} 
\end{DoxySeeAlso}
\hypertarget{classmdt_port_manager_a94d3fa4a26f8686449313a54003f0b4d}{
\index{mdtPortManager@{mdtPortManager}!pmUnhandledErrorEvent@{pmUnhandledErrorEvent}}
\index{pmUnhandledErrorEvent@{pmUnhandledErrorEvent}!mdtPortManager@{mdtPortManager}}
\subsubsection[{pmUnhandledErrorEvent}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::pmUnhandledErrorEvent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a94d3fa4a26f8686449313a54003f0b4d}


Sent when a unhandled error occured. 

Used by state machine \hypertarget{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{
\index{mdtPortManager@{mdtPortManager}!readenFrame@{readenFrame}}
\index{readenFrame@{readenFrame}!mdtPortManager@{mdtPortManager}}
\subsubsection[{readenFrame}]{\setlength{\rightskip}{0pt plus 5cm}QByteArray mdtPortManager::readenFrame (
\begin{DoxyParamCaption}
\item[{int}]{id}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}


Get data by frame ID. 

The frame ID is a protocol specific identification. F.ex. in MODBUS/TCP, the transaction ID is used, or bTag for USBTMC.

If found, the frame is removed from done queue. (A second call with same ID will return a empty QByteArray).

If ID was not found, a empty QByteArray is returned. 

Definition at line 488 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{
\index{mdtPortManager@{mdtPortManager}!readenFrames@{readenFrames}}
\index{readenFrames@{readenFrames}!mdtPortManager@{mdtPortManager}}
\subsubsection[{readenFrames}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ QByteArray $>$ mdtPortManager::readenFrames (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}


Get all readen data. 

Note that calling this methode will clear the internal queue. (A second call will return a empty list). 

Definition at line 501 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ad9233b5156a45f2684783317d75fdf9b}{
\index{mdtPortManager@{mdtPortManager}!readThread@{readThread}}
\index{readThread@{readThread}!mdtPortManager@{mdtPortManager}}
\subsubsection[{readThread}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortThread} $\ast$ mdtPortManager::readThread (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_ad9233b5156a45f2684783317d75fdf9b}


Returns instance of reader thread. 

Note that a Null pointer can be returned 

Definition at line 146 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_aaa0a474183bcae0fff4fb9ef43023c25}{
\index{mdtPortManager@{mdtPortManager}!removeThreads@{removeThreads}}
\index{removeThreads@{removeThreads}!mdtPortManager@{mdtPortManager}}
\subsubsection[{removeThreads}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::removeThreads (
\begin{DoxyParamCaption}
\item[{bool}]{releaseMemory}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_aaa0a474183bcae0fff4fb9ef43023c25}


Detach threads from port and remove threads. 


\begin{DoxyParams}{Parameters}
{\em releaseMemory} & If true, all threads are deleted \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port manager must be closed (see \hyperlink{classmdt_port_manager_aeecbec49376838ab3547729636166d97}{isClosed()} ). 
\end{DoxyPrecond}


Definition at line 156 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}{
\index{mdtPortManager@{mdtPortManager}!restoreTransaction@{restoreTransaction}}
\index{restoreTransaction@{restoreTransaction}!mdtPortManager@{mdtPortManager}}
\subsubsection[{restoreTransaction}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::restoreTransaction (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}


Restore a transaction into pool. 

\begin{DoxyPrecond}{Precondition}
transaction must be a valid pointer (not Null) 

One transaction must be commited once (avoid corrupted double free) 
\end{DoxyPrecond}


qDebug() $<$$<$ \char`\"{}Restore transaction: \char`\"{} $<$$<$ transaction $<$$<$ \char`\"{} , ID: \char`\"{} $<$$<$ transaction-\/$>$id() $<$$<$ \char`\"{} data: \char`\"{} $<$$<$ transaction-\/$>$data(); 



Definition at line 310 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}{
\index{mdtPortManager@{mdtPortManager}!scan@{scan}}
\index{scan@{scan}!mdtPortManager@{mdtPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtPortManager::scan (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}


Scan for available ports. 

This method is implemented is port's specific subclass. Default implementation returns a empty list.

Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ). 

Reimplemented in \hyperlink{classmdt_usb_port_manager_a3a2370c3a2d0353a880bf9b777728c3b}{mdtUsbPortManager}, \hyperlink{classmdt_usbtmc_port_manager_a992d1227810186d3c7dc166452e2e3b6}{mdtUsbtmcPortManager}, and \hyperlink{classmdt_serial_port_manager_a791572f869d1d605d0c4658ca4187260}{mdtSerialPortManager}.



Definition at line 67 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ad98399edba146af5cf32a9002094385c}{
\index{mdtPortManager@{mdtPortManager}!sendData@{sendData}}
\index{sendData@{sendData}!mdtPortManager@{mdtPortManager}}
\subsubsection[{sendData}]{\setlength{\rightskip}{0pt plus 5cm}int mdtPortManager::sendData (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_ad98399edba146af5cf32a9002094385c}


Send data on port. 

At first, this method waits until the ready state is set calling \hyperlink{classmdt_port_manager_a6dc2798324521d177fb8f79d4f6c5f0f}{isReady()} , a frame is available in port's write frames pool, and until a transaction is possible (see \hyperlink{classmdt_port_manager_ac04a12f8aa20ba04695083afce45a6cc}{waitTransactionPossible()} ). This wait will not break event loop, so no GUI freeze occurs. If port manager is stopped during this wait (unhandled error, stop request), this method returns.

Then, data contained in transaction will be passed to the mdtPort's write queue by copy. This method returns immediatly after enqueue, and don't wait until data was written.


\begin{DoxyParams}{Parameters}
{\em transaction} & Transaction used to send data. Following members are used by this method:
\begin{DoxyItemize}
\item id : transaction will be added to pending transactions with this id, and currentTransactionId will be set with it.
\item data : will be sent to port.
\item isQueryReplyMode : if true, the transaction will be keeped in transactions done queue until \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} or \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()} is called. Note: it's possible to force keeping all incomming data (wich also owerwrite this flag) by setting the global keepTransactionsDone flag.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transaction ID on success or value $<$ 0 on error. In this implementation, the only possible error is \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eae50ff4a9393507ad39005ddc7d5be42f}{mdtAbstractPort::WriteCanceled}, witch typically occurs when port manager stops. Some subclass can return a frame ID on success, or a other error. See subclass documentation for details. Note: on failure, the transaction is restored to pool. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 

transaction must be a valid pointer, and not allready exists in transactions pending or transactions done queue.
\end{DoxyPrecond}
Subclass notes:\par
 This method can be reimplemented in subclass if needed. Typically usefull if some encoding is needed before the frame is submitted to port. A frame must be taken from port's write frames pool with \hyperlink{classmdt_abstract_port_abf093b67fddebffa4f3c52277b9a8cf7}{mdtAbstractPort::writeFramesPool()} dequeue() method (see Qt's QQueue documentation for more details on dequeue() ), then added to port's write queue with \hyperlink{classmdt_abstract_port_a9a69eb2fc07d551ab37c011487fa319d}{mdtAbstractPort::addFrameToWrite()} . If protocol supports frame identification (like MODBUS's transaction ID or USBTMC's bTag), it should be returned here and incremented using \hyperlink{classmdt_port_manager_a4d009936a0a5130f3bfecb69fee4ce42}{incrementCurrentTransactionId()}. 

Reimplemented in \hyperlink{classmdt_modbus_tcp_port_manager_a208a3b2522795974836fd8aef406725a}{mdtModbusTcpPortManager}, and \hyperlink{classmdt_usbtmc_port_manager_a205901666c797055bee1902bd1e1e09c}{mdtUsbtmcPortManager}.



Definition at line 319 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a445b27f0819158f67f1bd548cdd2fedf}{
\index{mdtPortManager@{mdtPortManager}!sendData@{sendData}}
\index{sendData@{sendData}!mdtPortManager@{mdtPortManager}}
\subsubsection[{sendData}]{\setlength{\rightskip}{0pt plus 5cm}int mdtPortManager::sendData (
\begin{DoxyParamCaption}
\item[{const QByteArray \&}]{data, }
\item[{bool}]{queryReplyMode = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_a445b27f0819158f67f1bd548cdd2fedf}


Send data to port. 

Will increment the current transaction ID, get a new transaction, setup it and finally send it with \hyperlink{classmdt_port_manager_ad98399edba146af5cf32a9002094385c}{sendData(mdtPortTransaction$\ast$)}.


\begin{DoxyParams}{Parameters}
{\em data} & Data to write. \\
\hline
{\em queryReplyMode} & If true, reply will be keeped in transactions done queue until \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} or \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()} is called. If false, behaviour depends on keepTransactionsDone flag.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_ad98399edba146af5cf32a9002094385c}{sendData(mdtPortTransaction$\ast$)} 
\end{DoxySeeAlso}


Reimplemented in \hyperlink{classmdt_modbus_tcp_port_manager_ac6ffcccbba23b1bda5cba2ae347793ba}{mdtModbusTcpPortManager}.



Definition at line 365 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a9adb5098766c9df588bc9978b00c5eb2}{
\index{mdtPortManager@{mdtPortManager}!setKeepTransactionsDone@{setKeepTransactionsDone}}
\index{setKeepTransactionsDone@{setKeepTransactionsDone}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setKeepTransactionsDone}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setKeepTransactionsDone (
\begin{DoxyParamCaption}
\item[{bool}]{keep}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a9adb5098766c9df588bc9978b00c5eb2}


Force transactions done to be keeped. 

If keep is true, \hyperlink{classmdt_port_manager_a84d37b380080eb26e56c68424dedd958}{commitFrames()} will ignore the \hyperlink{classmdt_port_transaction_a9da1cc7a191cd21a2e532d277aa3c628}{mdtPortTransaction::isQueryReplyMode()} and allways keep transactions in done queue until \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} or \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()} is called. 

Definition at line 278 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{
\index{mdtPortManager@{mdtPortManager}!setPort@{setPort}}
\index{setPort@{setPort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setPort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setPort (
\begin{DoxyParamCaption}
\item[{{\bf mdtAbstractPort} $\ast$}]{port}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}


Set port object. 

\begin{DoxyPrecond}{Precondition}
port must be a valid pointer to the expected class instance (for ex: \hyperlink{classmdt_serial_port}{mdtSerialPort}). 

Port manager must be closed (see \hyperlink{classmdt_port_manager_aeecbec49376838ab3547729636166d97}{isClosed()} ). 
\end{DoxyPrecond}


Definition at line 72 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a7e2ef93ec2731e66aa2b2d5f7ce9bc1c}{
\index{mdtPortManager@{mdtPortManager}!setPortInfo@{setPortInfo}}
\index{setPortInfo@{setPortInfo}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setPortInfo}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setPortInfo (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortInfo}}]{info}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a7e2ef93ec2731e66aa2b2d5f7ce9bc1c}


Set port info. 

Store given port info, and set port name to internall port object. (see \hyperlink{classmdt_port_info_ad456aac33dccc9b0583ed8aa4796cdf0}{mdtPortInfo::portName()} ).

Setting a port info can be usefull if other informations are needed later in application (f.ex. \hyperlink{classmdt_port_info_a38bcac67372782228a91d8e7dbf49211}{mdtPortInfo::displayText()} ). You can get port informations later with \hyperlink{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}{portInfo()}.

\begin{DoxyPrecond}{Precondition}
Port must be set before with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} 

Port manager must be closed (see \hyperlink{classmdt_port_manager_aeecbec49376838ab3547729636166d97}{isClosed()} ). 
\end{DoxyPrecond}


Definition at line 245 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}{
\index{mdtPortManager@{mdtPortManager}!setPortName@{setPortName}}
\index{setPortName@{setPortName}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setPortName}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setPortName (
\begin{DoxyParamCaption}
\item[{const QString \&}]{portName}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}


Set port name. 

Set the port name to internally port object. Does nothing else. To open the port, use \hyperlink{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{start()}.

\begin{DoxyPrecond}{Precondition}
Port must be set before with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} 

Port manager must be closed (see \hyperlink{classmdt_port_manager_aeecbec49376838ab3547729636166d97}{isClosed()} ). 
\end{DoxyPrecond}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_abstract_port}{mdtAbstractPort} 
\end{DoxySeeAlso}


Definition at line 236 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{
\index{mdtPortManager@{mdtPortManager}!start@{start}}
\index{start@{start}!mdtPortManager@{mdtPortManager}}
\subsubsection[{start}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::start (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}


Start port manager. 

Will open port and start threads. This method returns once port manager is ready (see \hyperlink{classmdt_port_manager_a6dc2798324521d177fb8f79d4f6c5f0f}{isReady()} ). Note: event loop continues to work during wait of ready state, GUI will also not freeze

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_usb_port_manager_ac656805c6de08c9c6a2487291cf3f347}{mdtUsbPortManager}.



Definition at line 182 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_adeeba5a216174fcc1d01446a9537f40e}{
\index{mdtPortManager@{mdtPortManager}!startTransactionTimer@{startTransactionTimer}}
\index{startTransactionTimer@{startTransactionTimer}!mdtPortManager@{mdtPortManager}}
\subsubsection[{startTransactionTimer}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::startTransactionTimer (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_adeeba5a216174fcc1d01446a9537f40e}


Start transaction timer. 


\begin{DoxyParams}{Parameters}
{\em timeout} & Timeout \mbox{[}ms\mbox{]}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_a04fc12f0dc02e981cac8dc56539e63d2}{transactionTimeoutOccured()} 

\hyperlink{classmdt_port_manager_a0be3429f901fc9bf4adee196035d2cee}{pmTransactionTimeoutEvent()} 

onTransactionTimeoutOccured() 

\hyperlink{classmdt_port_manager_a1467c0bd28612ae3116f5daba08c0b84}{stopTransactionTimer()} 
\end{DoxySeeAlso}


Definition at line 770 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ae00d513ed335fbd203852dcb7180005c}{
\index{mdtPortManager@{mdtPortManager}!stateChangedForUi@{stateChangedForUi}}
\index{stateChangedForUi@{stateChangedForUi}!mdtPortManager@{mdtPortManager}}
\subsubsection[{stateChangedForUi}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::stateChangedForUi (
\begin{DoxyParamCaption}
\item[{int}]{stateId, }
\item[{const QString \&}]{stateText, }
\item[{int}]{ledColorId, }
\item[{bool}]{ledIsOn}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_ae00d513ed335fbd203852dcb7180005c}


Emitted only if a state that must be notified is entered. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_state_machine}{mdtStateMachine} 
\end{DoxySeeAlso}
\hypertarget{classmdt_port_manager_a6f6c6f8a8430d8631a08c765565db9ab}{
\index{mdtPortManager@{mdtPortManager}!statusMessageChanged@{statusMessageChanged}}
\index{statusMessageChanged@{statusMessageChanged}!mdtPortManager@{mdtPortManager}}
\subsubsection[{statusMessageChanged}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::statusMessageChanged (
\begin{DoxyParamCaption}
\item[{const QString \&}]{message, }
\item[{const QString \&}]{details, }
\item[{int}]{timeout}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a6f6c6f8a8430d8631a08c765565db9ab}


Emitted when a new status message is to display. 

Typically used with mdtDeviceStatusWidget. \hypertarget{classmdt_port_manager_aacbf87cc3d9c37c87e21696f8a6514bd}{
\index{mdtPortManager@{mdtPortManager}!stop@{stop}}
\index{stop@{stop}!mdtPortManager@{mdtPortManager}}
\subsubsection[{stop}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::stop (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_aacbf87cc3d9c37c87e21696f8a6514bd}


Stop port manager. 

Will stop threads and close port. This method returns once port manager is closed ( see \hyperlink{classmdt_port_manager_aeecbec49376838ab3547729636166d97}{isClosed()} ). Note: event loop continues to work during wait of ready state, GUI will also not freeze

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Definition at line 213 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a1467c0bd28612ae3116f5daba08c0b84}{
\index{mdtPortManager@{mdtPortManager}!stopTransactionTimer@{stopTransactionTimer}}
\index{stopTransactionTimer@{stopTransactionTimer}!mdtPortManager@{mdtPortManager}}
\subsubsection[{stopTransactionTimer}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::stopTransactionTimer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a1467c0bd28612ae3116f5daba08c0b84}


Stop transaction timer. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_adeeba5a216174fcc1d01446a9537f40e}{startTransactionTimer()} 

\hyperlink{classmdt_port_manager_a04fc12f0dc02e981cac8dc56539e63d2}{transactionTimeoutOccured()} 

\hyperlink{classmdt_port_manager_a0be3429f901fc9bf4adee196035d2cee}{pmTransactionTimeoutEvent()} 

onTransactionTimeoutOccured() 
\end{DoxySeeAlso}


Definition at line 778 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a5869bcf6774a86fb9d3b00a0d4211bb5}{
\index{mdtPortManager@{mdtPortManager}!transactionDone@{transactionDone}}
\index{transactionDone@{transactionDone}!mdtPortManager@{mdtPortManager}}
\subsubsection[{transactionDone}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortTransaction} $\ast$ mdtPortManager::transactionDone (
\begin{DoxyParamCaption}
\item[{int}]{id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a5869bcf6774a86fb9d3b00a0d4211bb5}


Take transaction from DONE queue matching id. 

\begin{DoxyReturn}{Returns}
A valid transaction if exists, else a Null pointer. 
\end{DoxyReturn}


Definition at line 742 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a18478707a9be7638b06cde48ced48297}{
\index{mdtPortManager@{mdtPortManager}!transactionPending@{transactionPending}}
\index{transactionPending@{transactionPending}!mdtPortManager@{mdtPortManager}}
\subsubsection[{transactionPending}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortTransaction} $\ast$ mdtPortManager::transactionPending (
\begin{DoxyParamCaption}
\item[{int}]{id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a18478707a9be7638b06cde48ced48297}


Take pending transaction matching id. 

\begin{DoxyReturn}{Returns}
A valid transaction if exists, else a Null pointer. 
\end{DoxyReturn}


Definition at line 700 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a04fc12f0dc02e981cac8dc56539e63d2}{
\index{mdtPortManager@{mdtPortManager}!transactionTimeoutOccured@{transactionTimeoutOccured}}
\index{transactionTimeoutOccured@{transactionTimeoutOccured}!mdtPortManager@{mdtPortManager}}
\subsubsection[{transactionTimeoutOccured}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::transactionTimeoutOccured (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a04fc12f0dc02e981cac8dc56539e63d2}


Check if a transaction timeout occured. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_a0be3429f901fc9bf4adee196035d2cee}{pmTransactionTimeoutEvent()} 

onTransactionTimeoutOccured() 

\hyperlink{classmdt_port_manager_adeeba5a216174fcc1d01446a9537f40e}{startTransactionTimer()} 

\hyperlink{classmdt_port_manager_a1467c0bd28612ae3116f5daba08c0b84}{stopTransactionTimer()} 
\end{DoxySeeAlso}


Definition at line 786 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a882e6bf95dac9cd4ab8cc93ecc524874}{
\index{mdtPortManager@{mdtPortManager}!unlockPortMutex@{unlockPortMutex}}
\index{unlockPortMutex@{unlockPortMutex}!mdtPortManager@{mdtPortManager}}
\subsubsection[{unlockPortMutex}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::unlockPortMutex (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a882e6bf95dac9cd4ab8cc93ecc524874}


Unlock port's mutex. 

\begin{DoxyPrecond}{Precondition}
Port must be set with setPort before using this method 
\end{DoxyPrecond}


Definition at line 94 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_aaa85e0200aba0e0f4392dfe01abae2cf}{
\index{mdtPortManager@{mdtPortManager}!wait@{wait}}
\index{wait@{wait}!mdtPortManager@{mdtPortManager}}
\subsubsection[{wait}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::wait (
\begin{DoxyParamCaption}
\item[{int}]{ms}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_aaa85e0200aba0e0f4392dfe01abae2cf}


Wait for some time. 

This will block the caller until ms milliseconds elapsed. This will not block event loop, i.e. no GUI freeze occurs.

Such wait method can be usfull if, for example, a device needs some time between two requests.

Note: this method should not be used to wait on a specific event (frame received, ...). For such problem, please considere the transaction API (in this class) and \hyperlink{classmdt_device}{mdtDevice} witch give some helper methods and a API when developping new communication classes with devices.

Internally, a QTimer is used. Please considere Qt documentation about time precisions and limitations. Note: \hyperlink{classmdt_port_manager}{mdtPortManager} is not designed for real time applications, but in mind to communicate in a easy way with devices.

For the story, a example with a Wago 750 I/O system: In multidiagtools test suite we do set/get tests on outputs. We wait confirmation of device for each request (see \hyperlink{classmdt_device}{mdtDevice} for details). Some times test failed because the get didn't return the value set just before. By mesuring set and get times, we could see that it can take about 2\mbox{[}ms\mbox{]} -\/$>$ 40\mbox{[}ms\mbox{]}. This can be shorter than PLC needs to update its cache (read all I/O on bus, ...), and we had a old value in get reply. 

Definition at line 479 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_af60f089baded850018cbb90645c8e547}{
\index{mdtPortManager@{mdtPortManager}!waitOneTransactionDone@{waitOneTransactionDone}}
\index{waitOneTransactionDone@{waitOneTransactionDone}!mdtPortManager@{mdtPortManager}}
\subsubsection[{waitOneTransactionDone}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::waitOneTransactionDone (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_af60f089baded850018cbb90645c8e547}


Wait until current transaction is done. 

Use this method if protocol does not support frame ID.

Internally, it will wait until one transaction is available in done queue.

\begin{DoxyReturn}{Returns}
True if Ok, false on timeout or other error. 
\end{DoxyReturn}


Definition at line 436 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a5551802de2c08632078f2cc0e2607913}{
\index{mdtPortManager@{mdtPortManager}!waitTransactionDone@{waitTransactionDone}}
\index{waitTransactionDone@{waitTransactionDone}!mdtPortManager@{mdtPortManager}}
\subsubsection[{waitTransactionDone}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::waitTransactionDone (
\begin{DoxyParamCaption}
\item[{int}]{id}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a5551802de2c08632078f2cc0e2607913}


Wait until a transaction is done. 

Will return when transaction with given id is done or after timeout.

This wait method does not break Qt's event loop, no GUI freeze occurs.

This method can return if timeout occurs, or for other reason depending on specific port (port timeout, read cancelled, ...).


\begin{DoxyParams}{Parameters}
{\em id} & Frame ID. Depending on protocol, this can be a transaction ID or what else. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if Ok, false on timeout or other error. If id was not found in transactions pending lists, a warning will be generated in \hyperlink{classmdt_error}{mdtError} system, and false will be returned. On failure, transaction is restored to pool (see \hyperlink{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}{onThreadsErrorOccured()} for details). 
\end{DoxyReturn}


Definition at line 381 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ac04a12f8aa20ba04695083afce45a6cc}{
\index{mdtPortManager@{mdtPortManager}!waitTransactionPossible@{waitTransactionPossible}}
\index{waitTransactionPossible@{waitTransactionPossible}!mdtPortManager@{mdtPortManager}}
\subsubsection[{waitTransactionPossible}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::waitTransactionPossible (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_ac04a12f8aa20ba04695083afce45a6cc}


Wait until transaction pending queue has less than maximum possible items. 

\begin{DoxyReturn}{Returns}
True on success, false if wait was interrupted. 
\end{DoxyReturn}


qDebug() $<$$<$ \char`\"{}mdtPortManager::waitTransactionPossible() -\/ pending queue : \char`\"{} $<$$<$ pvTransactionsPending $<$$<$ \char`\"{} , max pending: \char`\"{} $<$$<$ pvMaxTransactionsPending;

qDebug() $<$$<$ \char`\"{}mdtPortManager::waitTransactionPossible() ...\char`\"{}; 



Definition at line 652 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_af44b6e9876e6687b1d4fe7e05ffd5a91}{
\index{mdtPortManager@{mdtPortManager}!writeThread@{writeThread}}
\index{writeThread@{writeThread}!mdtPortManager@{mdtPortManager}}
\subsubsection[{writeThread}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortThread} $\ast$ mdtPortManager::writeThread (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_af44b6e9876e6687b1d4fe7e05ffd5a91}


Returns instance of writer thread. 

Note that a Null pointer can be returned 

Definition at line 151 of file mdtPortManager.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtPortManager.h\item 
src/mdtport/mdtPortManager.cpp\end{DoxyCompactItemize}
