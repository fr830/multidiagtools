<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Multi diag tools: mdtBuffer&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Multi diag tools</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">mdtBuffer&lt; T &gt; Class Template Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="mdtBuffer" -->
<p>Stockage d'éléments basé sur le principe du tampon circulaire.  
 <a href="classmdt_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mdt_buffer_8h_source.html">mdtBuffer.h</a>&gt;</code></p>

<p><a href="classmdt_buffer-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a51bc78e5a9fc926c7b898160c6a2faa3">mdtBuffer</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur.  <a href="#a51bc78e5a9fc926c7b898160c6a2faa3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a4d6c140c02257fffb37016d019e412cf">mdtBuffer</a> (<a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt; &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur de copie.  <a href="#a4d6c140c02257fffb37016d019e412cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#aba9a31eb29a39a2721205f13f80c1d8d">operator=</a> (<a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt; &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opérateur de copie.  <a href="#aba9a31eb29a39a2721205f13f80c1d8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a54de4cebee3cab7b8c1b86bfc3bdad4f">~mdtBuffer</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructeur.  <a href="#a54de4cebee3cab7b8c1b86bfc3bdad4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a9d081b06f666fec3ff6e12ec94b2a4fd">init</a> (size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialisation du tampon.  <a href="#a9d081b06f666fec3ff6e12ec94b2a4fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a697920838a6c786209607c2b6ac0858a">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Efface le contenu du tampon.  <a href="#a697920838a6c786209607c2b6ac0858a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#abe03f0413ff7512d63d8df1408c66f63">put</a> (const T *data, size_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stockage d'un lot de données.  <a href="#abe03f0413ff7512d63d8df1408c66f63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a2b9fd3a6b593c2e874249aba5c305e34">putOne</a> (T data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stockage d'un élément par copie.  <a href="#a2b9fd3a6b593c2e874249aba5c305e34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a01d74092785c9442014ee34624ffa96f">putUntil</a> (const T *data, T token, size_t maxLen, bool IgnoreNullValues)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stockage d'un lot de données jusqu'à la rencontre d'un élément.  <a href="#a01d74092785c9442014ee34624ffa96f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a6ddc3c27c154fbfd077f83d5bfe82a19">tokenReached</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retourne true si l'élément de fin de copie à été atteint.  <a href="#a6ddc3c27c154fbfd077f83d5bfe82a19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#aa6eddf7ccc533da855ebd112202a656f">capacity</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Capacité totale.  <a href="#aa6eddf7ccc533da855ebd112202a656f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a78e8317b6ba09e9c4e26358e27f75fd6">remainCapacity</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Capacité restante.  <a href="#a78e8317b6ba09e9c4e26358e27f75fd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a63e2b6b5e7656a5285d0ea1d152ea499">full</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Déterminer si le tampon est plein.  <a href="#a63e2b6b5e7656a5285d0ea1d152ea499"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a24ca1a2d00ba1623416ec747ba440adf">available</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Nombre d'éléments disponibles en lecture.  <a href="#a24ca1a2d00ba1623416ec747ba440adf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a123a85c9cd59f80623aba5589709050e">get</a> (T *data, size_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lecture d'un lot de données.  <a href="#a123a85c9cd59f80623aba5589709050e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#ad4756dea3500741363092d5a85ef858e">take</a> (T *data, size_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrait d'un lot de données.  <a href="#ad4756dea3500741363092d5a85ef858e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_buffer.html#a690e3f41a62175de48bc73c19f69208d">takeOne</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrait d'un élément.  <a href="#a690e3f41a62175de48bc73c19f69208d"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class mdtBuffer&lt; T &gt;</h3>

<p>Stockage d'éléments basé sur le principe du tampon circulaire. </p>
<p>Stockage d'éléments basé sur le principe du tampon circulaire Idéal pour le stockage temporaire si une taille maximale est connue. Evite de nombreuses allocations/libération mémoire </p>

<p>Definition at line <a class="el" href="mdt_buffer_8h_source.html#l00037">37</a> of file <a class="el" href="mdt_buffer_8h_source.html">mdtBuffer.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a51bc78e5a9fc926c7b898160c6a2faa3"></a><!-- doxytag: member="mdtBuffer::mdtBuffer" ref="a51bc78e5a9fc926c7b898160c6a2faa3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::<a class="el" href="classmdt_buffer.html">mdtBuffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructeur. </p>
<p>Constructeur, utiliser <a class="el" href="classmdt_buffer.html#a9d081b06f666fec3ff6e12ec94b2a4fd" title="Initialisation du tampon.">init()</a> avant tout autre opération </p>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00006">6</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d6c140c02257fffb37016d019e412cf"></a><!-- doxytag: member="mdtBuffer::mdtBuffer" ref="a4d6c140c02257fffb37016d019e412cf" args="(mdtBuffer&lt; T &gt; &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::<a class="el" href="classmdt_buffer.html">mdtBuffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructeur de copie. </p>
<p>Constructeur de copie. Effectue une copie des données vers l'autre instance </p>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00015">15</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a54de4cebee3cab7b8c1b86bfc3bdad4f"></a><!-- doxytag: member="mdtBuffer::~mdtBuffer" ref="a54de4cebee3cab7b8c1b86bfc3bdad4f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::~<a class="el" href="classmdt_buffer.html">mdtBuffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructeur. </p>
<p>Destructeur </p>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00050">50</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a24ca1a2d00ba1623416ec747ba440adf"></a><!-- doxytag: member="mdtBuffer::available" ref="a24ca1a2d00ba1623416ec747ba440adf" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template size_t <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Nombre d'éléments disponibles en lecture. </p>
<p>Nombre d'éléments disponibles en lecture</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Le nombre d'éléments qu'il est possible de lire </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00227">227</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6eddf7ccc533da855ebd112202a656f"></a><!-- doxytag: member="mdtBuffer::capacity" ref="aa6eddf7ccc533da855ebd112202a656f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template size_t <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Capacité totale. </p>
<p>Capacité totale</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>La capacité totale du tampon </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00212">212</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a697920838a6c786209607c2b6ac0858a"></a><!-- doxytag: member="mdtBuffer::clear" ref="a697920838a6c786209607c2b6ac0858a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Efface le contenu du tampon. </p>
<p>Efface le contenu du tampon. La quantité disponible ainsi que la capacité restante sont aussi ré-initialisés </p>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00079">79</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a63e2b6b5e7656a5285d0ea1d152ea499"></a><!-- doxytag: member="mdtBuffer::full" ref="a63e2b6b5e7656a5285d0ea1d152ea499" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::full </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Déterminer si le tampon est plein. </p>
<p>Déterminer si le tampon est plein</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True si le tampon est plein </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00222">222</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a123a85c9cd59f80623aba5589709050e"></a><!-- doxytag: member="mdtBuffer::get" ref="a123a85c9cd59f80623aba5589709050e" args="(T *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template size_t <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lecture d'un lot de données. </p>
<p>La copie, basée sur memcpy, est performante Le cusreur de lecture interne, ainsi que le quantité disponible et la capacité restante ne sont pas altérés (plusieurs appels à cette méthode renverrait chaque fois les même données)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointeur vers les données de destination </td></tr>
    <tr><td class="paramname">len</td><td>Nombre d'éléments à lire</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Le nombre d'éléments effectivement lus </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00232">232</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9d081b06f666fec3ff6e12ec94b2a4fd"></a><!-- doxytag: member="mdtBuffer::init" ref="a9d081b06f666fec3ff6e12ec94b2a4fd" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialisation du tampon. </p>
<p>Initialisation du tampon. Alloue la mémoire, initialise les données à une valeur nulle. Il est possible de ré-appeler cette fonction plusieurs fois, la zone mémoire étant alors ré-alouée</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Capacité du tampon [nombre d'éléments]</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>false en cas de problème d'allocation mémoire (true si tout s'est bien passé) </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00057">57</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba9a31eb29a39a2721205f13f80c1d8d"></a><!-- doxytag: member="mdtBuffer::operator=" ref="aba9a31eb29a39a2721205f13f80c1d8d" args="(mdtBuffer&lt; T &gt; &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; char &gt; &amp; <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opérateur de copie. </p>
<p>Opérateur de copie. Effectue une copie des données vers l'autre instance </p>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00033">33</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe03f0413ff7512d63d8df1408c66f63"></a><!-- doxytag: member="mdtBuffer::put" ref="abe03f0413ff7512d63d8df1408c66f63" args="(const T *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template size_t <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stockage d'un lot de données. </p>
<p>Stockage d'un lot de données par copie. La copie, basée sur memcpy, est performante</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointeur vers les données sources </td></tr>
    <tr><td class="paramname">len</td><td>Nombre d'éléments à stocker</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Le nombre d'éléments effectivement stockés </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00098">98</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b9fd3a6b593c2e874249aba5c305e34"></a><!-- doxytag: member="mdtBuffer::putOne" ref="a2b9fd3a6b593c2e874249aba5c305e34" args="(T data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::putOne </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stockage d'un élément par copie. </p>
<p>Stockage d'un élément par copie.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Elément à stocker</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True si Ok, false en cas d'erreur </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00146">146</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a01d74092785c9442014ee34624ffa96f"></a><!-- doxytag: member="mdtBuffer::putUntil" ref="a01d74092785c9442014ee34624ffa96f" args="(const T *data, T token, size_t maxLen, bool IgnoreNullValues)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::putUntil </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>IgnoreNullValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stockage d'un lot de données jusqu'à la rencontre d'un élément. </p>
<p>Stockage d'un lot de données par copie jusqu'à la rencontre d'un élément, ou maxLen si l'élément recherché n'est pas trouvé. L'élément de recherche est aussi stocké La copie, basée sur une boucle, est relativement lente (comparé à memcpy) Il est possible de ne pas stocker les caractères null ('\0')</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointeur vers les données sources </td></tr>
    <tr><td class="paramname">token</td><td>Elément désignant la fin de la copie </td></tr>
    <tr><td class="paramname">Maxlen</td><td>Nombre d'éléments maximal à stocker </td></tr>
    <tr><td class="paramname">IgnoreNullValues</td><td>Si true, les éléments null (0) ne seront pas stockés</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Le nombre d'éléments effectivement stockés </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00166">166</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78e8317b6ba09e9c4e26358e27f75fd6"></a><!-- doxytag: member="mdtBuffer::remainCapacity" ref="a78e8317b6ba09e9c4e26358e27f75fd6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template size_t <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::remainCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Capacité restante. </p>
<p>Capacité restante</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Le nombre d'éléments qu'il est encore possible de stocker </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00217">217</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4756dea3500741363092d5a85ef858e"></a><!-- doxytag: member="mdtBuffer::take" ref="ad4756dea3500741363092d5a85ef858e" args="(T *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::take </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrait d'un lot de données. </p>
<p>Retrait d'un lot de données par copie. La copie, basée sur memcpy, et performante Le cusreur de lecture interne, ainsi que le quantité disponible et la capacité restante sont altérés</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointeur vers les données de destination </td></tr>
    <tr><td class="paramname">len</td><td>Nombre d'éléments à lire</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Le nombre d'éléments effectivement retirés </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00271">271</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a690e3f41a62175de48bc73c19f69208d"></a><!-- doxytag: member="mdtBuffer::takeOne" ref="a690e3f41a62175de48bc73c19f69208d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template std::string <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::takeOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrait d'un élément. </p>
<p>Retrait d'un élément Le cusreur de lecture interne, ainsi que le quantité disponible et la capacité restante sont altérés Test retour: 0 est retourné si aucun élément n'est disponible. Etant donnée que 0 peut très bien être un élément valide stocké dans le tampon, il faut utiliser une méthode de test avant le retrait. Voir <a class="el" href="classmdt_buffer.html#a24ca1a2d00ba1623416ec747ba440adf" title="Nombre d&#39;éléments disponibles en lecture.">available()</a></p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Un élément, ou 0 si aucune disponibilité </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00317">317</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ddc3c27c154fbfd077f83d5bfe82a19"></a><!-- doxytag: member="mdtBuffer::tokenReached" ref="a6ddc3c27c154fbfd077f83d5bfe82a19" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="classmdt_buffer.html">mdtBuffer</a>&lt; T &gt;::tokenReached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retourne true si l'élément de fin de copie à été atteint. </p>
<p>Retourne true si l'élément de fin de copie à été atteint Voir la méthode <a class="el" href="classmdt_buffer.html#a01d74092785c9442014ee34624ffa96f" title="Stockage d&#39;un lot de données jusqu&#39;à la rencontre d&#39;un élément.">putUntil()</a> Ce flag est effacé par un appel de la méthode <a class="el" href="classmdt_buffer.html#ad4756dea3500741363092d5a85ef858e" title="Retrait d&#39;un lot de données.">take()</a> , même si l'élément n'est pas "consommé" <a class="el" href="classmdt_buffer.html#a697920838a6c786209607c2b6ac0858a" title="Efface le contenu du tampon.">clear()</a> efface aussi ce flag</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True si l'élément de fin à été atteint </dd></dl>

<p>Definition at line <a class="el" href="mdt_buffer_8cpp_source.html#l00207">207</a> of file <a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/mdtutils/<a class="el" href="mdt_buffer_8h_source.html">mdtBuffer.h</a></li>
<li>src/mdtutils/<a class="el" href="mdt_buffer_8cpp_source.html">mdtBuffer.cpp</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sat Dec 15 2012 16:54:45 for Multi diag tools by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
