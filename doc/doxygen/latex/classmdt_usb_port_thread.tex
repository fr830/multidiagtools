\hypertarget{classmdt_usb_port_thread}{
\section{mdtUsbPortThread Class Reference}
\label{classmdt_usb_port_thread}\index{mdtUsbPortThread@{mdtUsbPortThread}}
}


Inheritance diagram for mdtUsbPortThread:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=196pt]{classmdt_usb_port_thread__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtUsbPortThread:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=326pt]{classmdt_usb_port_thread__coll__graph}
\end{center}
\end{figure}
\subsection*{Signals}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_usb_port_thread_ab8ac3a6e1b571215be86f9dfd8c48b2b}{
void \hyperlink{classmdt_usb_port_thread_ab8ac3a6e1b571215be86f9dfd8c48b2b}{controlResponseReaden} ()}
\label{classmdt_usb_port_thread_ab8ac3a6e1b571215be86f9dfd8c48b2b}

\begin{DoxyCompactList}\small\item\em Emited when a new control response was readen. \end{DoxyCompactList}\item 
\hypertarget{classmdt_usb_port_thread_a850204a909f0bbe41c5e995ebe3670d8}{
void \hyperlink{classmdt_usb_port_thread_a850204a909f0bbe41c5e995ebe3670d8}{messageInReaden} ()}
\label{classmdt_usb_port_thread_a850204a909f0bbe41c5e995ebe3670d8}

\begin{DoxyCompactList}\small\item\em Emited when a message IN was readen (from additionnal interrupt IN endpoint) \end{DoxyCompactList}\item 
\hypertarget{classmdt_usb_port_thread_a54e65bed60200cd2150b5a7b063c723e}{
void \hyperlink{classmdt_usb_port_thread_a54e65bed60200cd2150b5a7b063c723e}{readUntilShortPacketReceivedFinished} ()}
\label{classmdt_usb_port_thread_a54e65bed60200cd2150b5a7b063c723e}

\begin{DoxyCompactList}\small\item\em Emitted when the read until a short packet process is finished. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_usb_port_thread_aaf4e5883224f05d80132b31a921ac899}{
\hyperlink{classmdt_usb_port_thread_aaf4e5883224f05d80132b31a921ac899}{mdtUsbPortThread} (QObject $\ast$parent=0)}
\label{classmdt_usb_port_thread_aaf4e5883224f05d80132b31a921ac899}

\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_thread_a1661f362e2d772c1524f09daa6da3f15}{setPort} (\hyperlink{classmdt_usb_port}{mdtUsbPort} $\ast$port)
\begin{DoxyCompactList}\small\item\em Set the port instance. \end{DoxyCompactList}\item 
\hyperlink{classmdt_usb_port}{mdtUsbPort} $\ast$ \hyperlink{classmdt_usb_port_thread_aaa8e1ce181489dbae57c81b42dc6ad62}{usbPort} ()
\begin{DoxyCompactList}\small\item\em Get USB port instance. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_thread_a99070e7dba4bd7939b054cddbd66979f}{detachPort} (bool releaseMemory)
\begin{DoxyCompactList}\small\item\em Detach the port from thread. \end{DoxyCompactList}\item 
\hypertarget{classmdt_usb_port_thread_aed82b57c84745f1e2391750697db1022}{
bool \hyperlink{classmdt_usb_port_thread_aed82b57c84745f1e2391750697db1022}{isReader} () const }
\label{classmdt_usb_port_thread_aed82b57c84745f1e2391750697db1022}

\begin{DoxyCompactList}\small\item\em Returns true. \end{DoxyCompactList}\item 
\hypertarget{classmdt_usb_port_thread_a74258f300967b5dea1fbfa9a0ccab38a}{
bool \hyperlink{classmdt_usb_port_thread_a74258f300967b5dea1fbfa9a0ccab38a}{isWriter} () const }
\label{classmdt_usb_port_thread_a74258f300967b5dea1fbfa9a0ccab38a}

\begin{DoxyCompactList}\small\item\em Returns true. \end{DoxyCompactList}\item 
\hypertarget{classmdt_usb_port_thread_aeaa2dabc53e57f6b7cf7077d113c7f40}{
bool \hyperlink{classmdt_usb_port_thread_aeaa2dabc53e57f6b7cf7077d113c7f40}{handlesTimeout} () const }
\label{classmdt_usb_port_thread_aeaa2dabc53e57f6b7cf7077d113c7f40}

\begin{DoxyCompactList}\small\item\em Retunrs true. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \hyperlink{classmdt_usb_port_thread_a2d234f3900b502ecced6897facdcf029}{waitOnControlTransferPossible} (bool notifyOnControlTransferComplete)
\begin{DoxyCompactList}\small\item\em Wait until a new control transfer is possible (i.e. when control frames pool is not empty) \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \hyperlink{classmdt_usb_port_thread_ae154415b3f311b02934405cd58eb9aa5}{sendControlQuery} (\hyperlink{classmdt_frame_usb_control}{mdtFrameUsbControl} $\ast$ctlFrame)
\begin{DoxyCompactList}\small\item\em Send a control query and wait until response is available. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \hyperlink{classmdt_usb_port_thread_acca2af9704cc6894ec5b2058ca102af1}{readUntilShortPacketReceived} (int maxReadTransfers)
\begin{DoxyCompactList}\small\item\em Read until a short frame is received. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 35 of file mdtUsbPortThread.h.



\subsection{Member Function Documentation}
\hypertarget{classmdt_usb_port_thread_a99070e7dba4bd7939b054cddbd66979f}{
\index{mdtUsbPortThread@{mdtUsbPortThread}!detachPort@{detachPort}}
\index{detachPort@{detachPort}!mdtUsbPortThread@{mdtUsbPortThread}}
\subsubsection[{detachPort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPortThread::detachPort (
\begin{DoxyParamCaption}
\item[{bool}]{releaseMemory}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_thread_a99070e7dba4bd7939b054cddbd66979f}


Detach the port from thread. 


\begin{DoxyParams}{Parameters}
{\em releaseMemory} & If true, the port object that was set with \hyperlink{classmdt_usb_port_thread_a1661f362e2d772c1524f09daa6da3f15}{setPort()} will be deleted. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The thread must not running 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_port_thread_a29b434534a5564efbd9dfe570a61b143}{mdtPortThread}.



Definition at line 49 of file mdtUsbPortThread.cpp.

\hypertarget{classmdt_usb_port_thread_acca2af9704cc6894ec5b2058ca102af1}{
\index{mdtUsbPortThread@{mdtUsbPortThread}!readUntilShortPacketReceived@{readUntilShortPacketReceived}}
\index{readUntilShortPacketReceived@{readUntilShortPacketReceived}!mdtUsbPortThread@{mdtUsbPortThread}}
\subsubsection[{readUntilShortPacketReceived}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPortThread::readUntilShortPacketReceived (
\begin{DoxyParamCaption}
\item[{int}]{maxReadTransfers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_usb_port_thread_acca2af9704cc6894ec5b2058ca102af1}


Read until a short frame is received. 


\begin{DoxyParams}{Parameters}
{\em maxReadTransfers} & Maximum of read transfers before return (If device returns never a short frame, this method will return after maxReadTransfers). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
NoError or a error of type \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t}. If maxReadTransfers is reached, ReadTimeout is returned. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_usb_port_thread_a1661f362e2d772c1524f09daa6da3f15}{setPort()} before using this method. 
\end{DoxyPrecond}


\hyperlink{classmdt_usb_port}{mdtUsbPort} $\ast$port = dynamic\_\-cast$<$mdtUsbPort$\ast$$>$(pvPort); Q\_\-ASSERT(port != 0);

qDebug() $<$$<$ \char`\"{}mdtUsbPortThread::readUntilShortPacketReceived() , readen: \char`\"{} $<$$<$ readen;

qDebug() $<$$<$ \char`\"{}mdtUsbPortThread::readUntilShortPacketReceived() , END , Ok\char`\"{}; 



Definition at line 154 of file mdtUsbPortThread.cpp.

\hypertarget{classmdt_usb_port_thread_ae154415b3f311b02934405cd58eb9aa5}{
\index{mdtUsbPortThread@{mdtUsbPortThread}!sendControlQuery@{sendControlQuery}}
\index{sendControlQuery@{sendControlQuery}!mdtUsbPortThread@{mdtUsbPortThread}}
\subsubsection[{sendControlQuery}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPortThread::sendControlQuery (
\begin{DoxyParamCaption}
\item[{{\bf mdtFrameUsbControl} $\ast$}]{ctlFrame}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_usb_port_thread_ae154415b3f311b02934405cd58eb9aa5}


Send a control query and wait until response is available. 



\hyperlink{classmdt_usb_port}{mdtUsbPort} $\ast$port = dynamic\_\-cast$<$mdtUsbPort$\ast$$>$(pvPort); Q\_\-ASSERT(port != 0); 



Definition at line 119 of file mdtUsbPortThread.cpp.

\hypertarget{classmdt_usb_port_thread_a1661f362e2d772c1524f09daa6da3f15}{
\index{mdtUsbPortThread@{mdtUsbPortThread}!setPort@{setPort}}
\index{setPort@{setPort}!mdtUsbPortThread@{mdtUsbPortThread}}
\subsubsection[{setPort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPortThread::setPort (
\begin{DoxyParamCaption}
\item[{{\bf mdtUsbPort} $\ast$}]{port}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_thread_a1661f362e2d772c1524f09daa6da3f15}


Set the port instance. 

\begin{DoxyPrecond}{Precondition}
port must be a valid pointer 

The thread must not running 
\end{DoxyPrecond}


Definition at line 36 of file mdtUsbPortThread.cpp.

\hypertarget{classmdt_usb_port_thread_aaa8e1ce181489dbae57c81b42dc6ad62}{
\index{mdtUsbPortThread@{mdtUsbPortThread}!usbPort@{usbPort}}
\index{usbPort@{usbPort}!mdtUsbPortThread@{mdtUsbPortThread}}
\subsubsection[{usbPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtUsbPort} $\ast$ mdtUsbPortThread::usbPort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_thread_aaa8e1ce181489dbae57c81b42dc6ad62}


Get USB port instance. 

\begin{DoxyReturn}{Returns}
Port instance, or a null pointer if it was not set 
\end{DoxyReturn}


Definition at line 44 of file mdtUsbPortThread.cpp.

\hypertarget{classmdt_usb_port_thread_a2d234f3900b502ecced6897facdcf029}{
\index{mdtUsbPortThread@{mdtUsbPortThread}!waitOnControlTransferPossible@{waitOnControlTransferPossible}}
\index{waitOnControlTransferPossible@{waitOnControlTransferPossible}!mdtUsbPortThread@{mdtUsbPortThread}}
\subsubsection[{waitOnControlTransferPossible}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPortThread::waitOnControlTransferPossible (
\begin{DoxyParamCaption}
\item[{bool}]{notifyOnControlTransferComplete}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_usb_port_thread_a2d234f3900b502ecced6897facdcf029}


Wait until a new control transfer is possible (i.e. when control frames pool is not empty) 



\hyperlink{classmdt_usb_port}{mdtUsbPort} $\ast$port = dynamic\_\-cast$<$mdtUsbPort$\ast$$>$(pvPort); Q\_\-ASSERT(port != 0); 



Definition at line 70 of file mdtUsbPortThread.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtUsbPortThread.h\item 
src/mdtport/mdtUsbPortThread.cpp\end{DoxyCompactItemize}
