\hypertarget{classmdt_buffer}{
\section{mdtBuffer$<$ T $>$ Class Template Reference}
\label{classmdt_buffer}\index{mdtBuffer@{mdtBuffer}}
}


Stockage d'éléments basé sur le principe du tampon circulaire.  




{\ttfamily \#include $<$mdtBuffer.h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_buffer_a51bc78e5a9fc926c7b898160c6a2faa3}{mdtBuffer} ()
\begin{DoxyCompactList}\small\item\em Constructeur. \end{DoxyCompactList}\item 
\hyperlink{classmdt_buffer_a4d6c140c02257fffb37016d019e412cf}{mdtBuffer} (\hyperlink{classmdt_buffer}{mdtBuffer}$<$ T $>$ \&src)
\begin{DoxyCompactList}\small\item\em Constructeur de copie. \end{DoxyCompactList}\item 
\hyperlink{classmdt_buffer}{mdtBuffer}$<$ T $>$ \& \hyperlink{classmdt_buffer_aba9a31eb29a39a2721205f13f80c1d8d}{operator=} (\hyperlink{classmdt_buffer}{mdtBuffer}$<$ T $>$ \&src)
\begin{DoxyCompactList}\small\item\em Opérateur de copie. \end{DoxyCompactList}\item 
\hyperlink{classmdt_buffer_a54de4cebee3cab7b8c1b86bfc3bdad4f}{$\sim$mdtBuffer} ()
\begin{DoxyCompactList}\small\item\em Destructeur. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_buffer_a9d081b06f666fec3ff6e12ec94b2a4fd}{init} (size\_\-t size)
\begin{DoxyCompactList}\small\item\em Initialisation du tampon. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_buffer_a697920838a6c786209607c2b6ac0858a}{clear} ()
\begin{DoxyCompactList}\small\item\em Efface le contenu du tampon. \end{DoxyCompactList}\item 
size\_\-t \hyperlink{classmdt_buffer_abe03f0413ff7512d63d8df1408c66f63}{put} (const T $\ast$data, size\_\-t len)
\begin{DoxyCompactList}\small\item\em Stockage d'un lot de données. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_buffer_a2b9fd3a6b593c2e874249aba5c305e34}{putOne} (T data)
\begin{DoxyCompactList}\small\item\em Stockage d'un élément par copie. \end{DoxyCompactList}\item 
size\_\-t \hyperlink{classmdt_buffer_a01d74092785c9442014ee34624ffa96f}{putUntil} (const T $\ast$data, T token, size\_\-t maxLen, bool IgnoreNullValues)
\begin{DoxyCompactList}\small\item\em Stockage d'un lot de données jusqu'à la rencontre d'un élément. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_buffer_a6ddc3c27c154fbfd077f83d5bfe82a19}{tokenReached} ()
\begin{DoxyCompactList}\small\item\em Retourne true si l'élément de fin de copie à été atteint. \end{DoxyCompactList}\item 
size\_\-t \hyperlink{classmdt_buffer_aa6eddf7ccc533da855ebd112202a656f}{capacity} ()
\begin{DoxyCompactList}\small\item\em Capacité totale. \end{DoxyCompactList}\item 
size\_\-t \hyperlink{classmdt_buffer_a78e8317b6ba09e9c4e26358e27f75fd6}{remainCapacity} ()
\begin{DoxyCompactList}\small\item\em Capacité restante. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_buffer_a63e2b6b5e7656a5285d0ea1d152ea499}{full} ()
\begin{DoxyCompactList}\small\item\em Déterminer si le tampon est plein. \end{DoxyCompactList}\item 
size\_\-t \hyperlink{classmdt_buffer_a24ca1a2d00ba1623416ec747ba440adf}{available} ()
\begin{DoxyCompactList}\small\item\em Nombre d'éléments disponibles en lecture. \end{DoxyCompactList}\item 
size\_\-t \hyperlink{classmdt_buffer_a123a85c9cd59f80623aba5589709050e}{get} (T $\ast$data, size\_\-t len)
\begin{DoxyCompactList}\small\item\em Lecture d'un lot de données. \end{DoxyCompactList}\item 
size\_\-t \hyperlink{classmdt_buffer_ad4756dea3500741363092d5a85ef858e}{take} (T $\ast$data, size\_\-t len)
\begin{DoxyCompactList}\small\item\em Retrait d'un lot de données. \end{DoxyCompactList}\item 
T \hyperlink{classmdt_buffer_a690e3f41a62175de48bc73c19f69208d}{takeOne} ()
\begin{DoxyCompactList}\small\item\em Retrait d'un élément. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$class T$>$class mdtBuffer$<$ T $>$}

Stockage d'éléments basé sur le principe du tampon circulaire. 

Stockage d'éléments basé sur le principe du tampon circulaire Idéal pour le stockage temporaire si une taille maximale est connue. Evite de nombreuses allocations/libération mémoire 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_buffer_a51bc78e5a9fc926c7b898160c6a2faa3}{
\index{mdtBuffer@{mdtBuffer}!mdtBuffer@{mdtBuffer}}
\index{mdtBuffer@{mdtBuffer}!mdtBuffer@{mdtBuffer}}
\subsubsection[{mdtBuffer}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ template {\bf mdtBuffer}$<$ T $>$::{\bf mdtBuffer} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_a51bc78e5a9fc926c7b898160c6a2faa3}


Constructeur. 

Constructeur, utiliser \hyperlink{classmdt_buffer_a9d081b06f666fec3ff6e12ec94b2a4fd}{init()} avant tout autre opération \hypertarget{classmdt_buffer_a4d6c140c02257fffb37016d019e412cf}{
\index{mdtBuffer@{mdtBuffer}!mdtBuffer@{mdtBuffer}}
\index{mdtBuffer@{mdtBuffer}!mdtBuffer@{mdtBuffer}}
\subsubsection[{mdtBuffer}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ {\bf mdtBuffer}$<$ T $>$::{\bf mdtBuffer} (
\begin{DoxyParamCaption}
\item[{{\bf mdtBuffer}$<$ T $>$ \&}]{src}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_a4d6c140c02257fffb37016d019e412cf}


Constructeur de copie. 

Constructeur de copie. Effectue une copie des données vers l'autre instance \hypertarget{classmdt_buffer_a54de4cebee3cab7b8c1b86bfc3bdad4f}{
\index{mdtBuffer@{mdtBuffer}!$\sim$mdtBuffer@{$\sim$mdtBuffer}}
\index{$\sim$mdtBuffer@{$\sim$mdtBuffer}!mdtBuffer@{mdtBuffer}}
\subsubsection[{$\sim$mdtBuffer}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ template {\bf mdtBuffer}$<$ T $>$::$\sim${\bf mdtBuffer} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_a54de4cebee3cab7b8c1b86bfc3bdad4f}


Destructeur. 

Destructeur 

\subsection{Member Function Documentation}
\hypertarget{classmdt_buffer_a24ca1a2d00ba1623416ec747ba440adf}{
\index{mdtBuffer@{mdtBuffer}!available@{available}}
\index{available@{available}!mdtBuffer@{mdtBuffer}}
\subsubsection[{available}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ template size\_\-t {\bf mdtBuffer}$<$ T $>$::available (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_a24ca1a2d00ba1623416ec747ba440adf}


Nombre d'éléments disponibles en lecture. 

Nombre d'éléments disponibles en lecture

\begin{DoxyReturn}{Returns}
Le nombre d'éléments qu'il est possible de lire 
\end{DoxyReturn}
\hypertarget{classmdt_buffer_aa6eddf7ccc533da855ebd112202a656f}{
\index{mdtBuffer@{mdtBuffer}!capacity@{capacity}}
\index{capacity@{capacity}!mdtBuffer@{mdtBuffer}}
\subsubsection[{capacity}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ template size\_\-t {\bf mdtBuffer}$<$ T $>$::capacity (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_aa6eddf7ccc533da855ebd112202a656f}


Capacité totale. 

Capacité totale

\begin{DoxyReturn}{Returns}
La capacité totale du tampon 
\end{DoxyReturn}
\hypertarget{classmdt_buffer_a697920838a6c786209607c2b6ac0858a}{
\index{mdtBuffer@{mdtBuffer}!clear@{clear}}
\index{clear@{clear}!mdtBuffer@{mdtBuffer}}
\subsubsection[{clear}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ template void {\bf mdtBuffer}$<$ T $>$::clear (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_a697920838a6c786209607c2b6ac0858a}


Efface le contenu du tampon. 

Efface le contenu du tampon. La quantité disponible ainsi que la capacité restante sont aussi ré-\/initialisés \hypertarget{classmdt_buffer_a63e2b6b5e7656a5285d0ea1d152ea499}{
\index{mdtBuffer@{mdtBuffer}!full@{full}}
\index{full@{full}!mdtBuffer@{mdtBuffer}}
\subsubsection[{full}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ template bool {\bf mdtBuffer}$<$ T $>$::full (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_a63e2b6b5e7656a5285d0ea1d152ea499}


Déterminer si le tampon est plein. 

Déterminer si le tampon est plein

\begin{DoxyReturn}{Returns}
True si le tampon est plein 
\end{DoxyReturn}
\hypertarget{classmdt_buffer_a123a85c9cd59f80623aba5589709050e}{
\index{mdtBuffer@{mdtBuffer}!get@{get}}
\index{get@{get}!mdtBuffer@{mdtBuffer}}
\subsubsection[{get}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ template size\_\-t {\bf mdtBuffer}$<$ T $>$::get (
\begin{DoxyParamCaption}
\item[{T $\ast$}]{data, }
\item[{size\_\-t}]{len}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_a123a85c9cd59f80623aba5589709050e}


Lecture d'un lot de données. 

La copie, basée sur memcpy, est performante Le cusreur de lecture interne, ainsi que le quantité disponible et la capacité restante ne sont pas altérés (plusieurs appels à cette méthode renverrait chaque fois les même données)


\begin{DoxyParams}{Parameters}
{\em data} & Pointeur vers les données de destination \\
\hline
{\em len} & Nombre d'éléments à lire\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Le nombre d'éléments effectivement lus 
\end{DoxyReturn}
\hypertarget{classmdt_buffer_a9d081b06f666fec3ff6e12ec94b2a4fd}{
\index{mdtBuffer@{mdtBuffer}!init@{init}}
\index{init@{init}!mdtBuffer@{mdtBuffer}}
\subsubsection[{init}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ template bool {\bf mdtBuffer}$<$ T $>$::init (
\begin{DoxyParamCaption}
\item[{size\_\-t}]{size}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_a9d081b06f666fec3ff6e12ec94b2a4fd}


Initialisation du tampon. 

Initialisation du tampon. Alloue la mémoire, initialise les données à une valeur nulle. Il est possible de ré-\/appeler cette fonction plusieurs fois, la zone mémoire étant alors ré-\/alouée


\begin{DoxyParams}{Parameters}
{\em size} & Capacité du tampon \mbox{[}nombre d'éléments\mbox{]}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false en cas de problème d'allocation mémoire (true si tout s'est bien passé) 
\end{DoxyReturn}
\hypertarget{classmdt_buffer_aba9a31eb29a39a2721205f13f80c1d8d}{
\index{mdtBuffer@{mdtBuffer}!operator=@{operator=}}
\index{operator=@{operator=}!mdtBuffer@{mdtBuffer}}
\subsubsection[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ template {\bf mdtBuffer}$<$ char $>$ \& {\bf mdtBuffer}$<$ T $>$::operator= (
\begin{DoxyParamCaption}
\item[{{\bf mdtBuffer}$<$ T $>$ \&}]{src}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_aba9a31eb29a39a2721205f13f80c1d8d}


Opérateur de copie. 

Opérateur de copie. Effectue une copie des données vers l'autre instance \hypertarget{classmdt_buffer_abe03f0413ff7512d63d8df1408c66f63}{
\index{mdtBuffer@{mdtBuffer}!put@{put}}
\index{put@{put}!mdtBuffer@{mdtBuffer}}
\subsubsection[{put}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ template size\_\-t {\bf mdtBuffer}$<$ T $>$::put (
\begin{DoxyParamCaption}
\item[{const T $\ast$}]{data, }
\item[{size\_\-t}]{len}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_abe03f0413ff7512d63d8df1408c66f63}


Stockage d'un lot de données. 

Stockage d'un lot de données par copie. La copie, basée sur memcpy, est performante


\begin{DoxyParams}{Parameters}
{\em data} & Pointeur vers les données sources \\
\hline
{\em len} & Nombre d'éléments à stocker\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Le nombre d'éléments effectivement stockés 
\end{DoxyReturn}
\hypertarget{classmdt_buffer_a2b9fd3a6b593c2e874249aba5c305e34}{
\index{mdtBuffer@{mdtBuffer}!putOne@{putOne}}
\index{putOne@{putOne}!mdtBuffer@{mdtBuffer}}
\subsubsection[{putOne}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ template bool {\bf mdtBuffer}$<$ T $>$::putOne (
\begin{DoxyParamCaption}
\item[{T}]{data}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_a2b9fd3a6b593c2e874249aba5c305e34}


Stockage d'un élément par copie. 

Stockage d'un élément par copie.


\begin{DoxyParams}{Parameters}
{\em data} & Elément à stocker\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True si Ok, false en cas d'erreur 
\end{DoxyReturn}
\hypertarget{classmdt_buffer_a01d74092785c9442014ee34624ffa96f}{
\index{mdtBuffer@{mdtBuffer}!putUntil@{putUntil}}
\index{putUntil@{putUntil}!mdtBuffer@{mdtBuffer}}
\subsubsection[{putUntil}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ size\_\-t {\bf mdtBuffer}$<$ T $>$::putUntil (
\begin{DoxyParamCaption}
\item[{const T $\ast$}]{data, }
\item[{T}]{token, }
\item[{size\_\-t}]{maxLen, }
\item[{bool}]{IgnoreNullValues}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_a01d74092785c9442014ee34624ffa96f}


Stockage d'un lot de données jusqu'à la rencontre d'un élément. 

Stockage d'un lot de données par copie jusqu'à la rencontre d'un élément, ou maxLen si l'élément recherché n'est pas trouvé. L'élément de recherche est aussi stocké La copie, basée sur une boucle, est relativement lente (comparé à memcpy) Il est possible de ne pas stocker les caractères null ('$\backslash$0')


\begin{DoxyParams}{Parameters}
{\em data} & Pointeur vers les données sources \\
\hline
{\em token} & Elément désignant la fin de la copie \\
\hline
{\em Maxlen} & Nombre d'éléments maximal à stocker \\
\hline
{\em IgnoreNullValues} & Si true, les éléments null (0) ne seront pas stockés\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Le nombre d'éléments effectivement stockés 
\end{DoxyReturn}
\hypertarget{classmdt_buffer_a78e8317b6ba09e9c4e26358e27f75fd6}{
\index{mdtBuffer@{mdtBuffer}!remainCapacity@{remainCapacity}}
\index{remainCapacity@{remainCapacity}!mdtBuffer@{mdtBuffer}}
\subsubsection[{remainCapacity}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ template size\_\-t {\bf mdtBuffer}$<$ T $>$::remainCapacity (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_a78e8317b6ba09e9c4e26358e27f75fd6}


Capacité restante. 

Capacité restante

\begin{DoxyReturn}{Returns}
Le nombre d'éléments qu'il est encore possible de stocker 
\end{DoxyReturn}
\hypertarget{classmdt_buffer_ad4756dea3500741363092d5a85ef858e}{
\index{mdtBuffer@{mdtBuffer}!take@{take}}
\index{take@{take}!mdtBuffer@{mdtBuffer}}
\subsubsection[{take}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ size\_\-t {\bf mdtBuffer}$<$ T $>$::take (
\begin{DoxyParamCaption}
\item[{T $\ast$}]{data, }
\item[{size\_\-t}]{len}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_ad4756dea3500741363092d5a85ef858e}


Retrait d'un lot de données. 

Retrait d'un lot de données par copie. La copie, basée sur memcpy, et performante Le cusreur de lecture interne, ainsi que le quantité disponible et la capacité restante sont altérés


\begin{DoxyParams}{Parameters}
{\em data} & Pointeur vers les données de destination \\
\hline
{\em len} & Nombre d'éléments à lire\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Le nombre d'éléments effectivement retirés 
\end{DoxyReturn}
\hypertarget{classmdt_buffer_a690e3f41a62175de48bc73c19f69208d}{
\index{mdtBuffer@{mdtBuffer}!takeOne@{takeOne}}
\index{takeOne@{takeOne}!mdtBuffer@{mdtBuffer}}
\subsubsection[{takeOne}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ template std::string {\bf mdtBuffer}$<$ T $>$::takeOne (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_a690e3f41a62175de48bc73c19f69208d}


Retrait d'un élément. 

Retrait d'un élément Le cusreur de lecture interne, ainsi que le quantité disponible et la capacité restante sont altérés Test retour: 0 est retourné si aucun élément n'est disponible. Etant donnée que 0 peut très bien être un élément valide stocké dans le tampon, il faut utiliser une méthode de test avant le retrait. Voir \hyperlink{classmdt_buffer_a24ca1a2d00ba1623416ec747ba440adf}{available()}

\begin{DoxyReturn}{Returns}
Un élément, ou 0 si aucune disponibilité 
\end{DoxyReturn}
\hypertarget{classmdt_buffer_a6ddc3c27c154fbfd077f83d5bfe82a19}{
\index{mdtBuffer@{mdtBuffer}!tokenReached@{tokenReached}}
\index{tokenReached@{tokenReached}!mdtBuffer@{mdtBuffer}}
\subsubsection[{tokenReached}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ template bool {\bf mdtBuffer}$<$ T $>$::tokenReached (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_buffer_a6ddc3c27c154fbfd077f83d5bfe82a19}


Retourne true si l'élément de fin de copie à été atteint. 

Retourne true si l'élément de fin de copie à été atteint Voir la méthode \hyperlink{classmdt_buffer_a01d74092785c9442014ee34624ffa96f}{putUntil()} Ce flag est effacé par un appel de la méthode \hyperlink{classmdt_buffer_ad4756dea3500741363092d5a85ef858e}{take()} , même si l'élément n'est pas \char`\"{}consommé\char`\"{} \hyperlink{classmdt_buffer_a697920838a6c786209607c2b6ac0858a}{clear()} efface aussi ce flag

\begin{DoxyReturn}{Returns}
True si l'élément de fin à été atteint 
\end{DoxyReturn}


The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtutils/mdtBuffer.h\item 
src/mdtutils/mdtBuffer.cpp\end{DoxyCompactItemize}
