\hypertarget{classmdt_device}{
\section{mdtDevice Class Reference}
\label{classmdt_device}\index{mdtDevice@{mdtDevice}}
}


Base class for a device connected to a port.  




{\ttfamily \#include $<$mdtDevice.h$>$}



Inheritance diagram for mdtDevice:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{classmdt_device__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtDevice:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=228pt]{classmdt_device__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Slots}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_device_a83cdf442f4cec7261742ca5939e390a1}{setAnalogOutputValue} (\hyperlink{classmdt_analog_io}{mdtAnalogIo} $\ast$analogOutput)
\begin{DoxyCompactList}\small\item\em Set value on a analog output on physical device. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_a93abbc706a1e6601ce947eee5e50fba6}{setDigitalOutputValue} (\hyperlink{classmdt_digital_io}{mdtDigitalIo} $\ast$digitalOutput)
\begin{DoxyCompactList}\small\item\em Set value on a digital output on physical device. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_a14634fec6cd6bae810562b3bd88a5c05}{runQueries} ()
\begin{DoxyCompactList}\small\item\em Queries to send periodically. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Signals}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_device_aecd2d9d2cc3665f2084d0fd20eb3db2d}{stateChanged} (int state)
\begin{DoxyCompactList}\small\item\em \hyperlink{classmdt_device_ios}{mdtDeviceIos} $\ast$pvIos; // I/O's container \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_a3fbc6e71241e2e9daa2d8557f870c03c}{statusMessageChanged} (const QString \&message, const QString \&details, int timeout)
\begin{DoxyCompactList}\small\item\em Emitted when a new status message is to display. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_device_a6d501791e7243358cc61b144254b80db}{mdtDevice} (QObject $\ast$parent=0)
\begin{DoxyCompactList}\small\item\em Construct a device object. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_device_ac2a9cfd6042f3f9d8da4e84f044d3f4a}{$\sim$mdtDevice} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
\hypertarget{classmdt_device_a80186f1aa6fbdc13f1652de978c35518}{
void \hyperlink{classmdt_device_a80186f1aa6fbdc13f1652de978c35518}{setName} (const QString \&name)}
\label{classmdt_device_a80186f1aa6fbdc13f1652de978c35518}

\begin{DoxyCompactList}\small\item\em Set the device name. \end{DoxyCompactList}\item 
\hypertarget{classmdt_device_a7ad893c6885dbaef5a6cb980bfe627e0}{
QString \hyperlink{classmdt_device_a7ad893c6885dbaef5a6cb980bfe627e0}{name} () const }
\label{classmdt_device_a7ad893c6885dbaef5a6cb980bfe627e0}

\begin{DoxyCompactList}\small\item\em Get device name. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \hyperlink{classmdt_device_abab1b6e45af527880ce469ae318474c0}{connectToDevice} (const \hyperlink{classmdt_device_info}{mdtDeviceInfo} \&devInfo)
\begin{DoxyCompactList}\small\item\em Search and connect to physical device. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos} (\hyperlink{classmdt_device_ios}{mdtDeviceIos} $\ast$ios, bool autoOutputUpdate=false)
\begin{DoxyCompactList}\small\item\em Set the I/O's container. \end{DoxyCompactList}\item 
\hyperlink{classmdt_device_ios}{mdtDeviceIos} $\ast$ \hyperlink{classmdt_device_adb7099877ad2080961fae5a40117e9e5}{ios} ()
\begin{DoxyCompactList}\small\item\em Get the I/Os container. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_aa241c40514683254990e742cf1bbb155}{setBackToReadyStateTimeout} (int timeout)
\begin{DoxyCompactList}\small\item\em Set back to ready state timeout. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_port_manager}{mdtPortManager} $\ast$ \hyperlink{classmdt_device_a06d9178b4133fd7b23084e712af20976}{portManager} ()
\begin{DoxyCompactList}\small\item\em Get internal port manager instance. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classmdt_device_a8887a1142d3d3be673c18cf3376e7af4}{isReady} ()
\begin{DoxyCompactList}\small\item\em Check if device is ready. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_a721c5bf2cfa0eef5304333f08da182f7}{start} (int queryInterval)
\begin{DoxyCompactList}\small\item\em Start periodic device querying. \end{DoxyCompactList}\item 
\hypertarget{classmdt_device_adc7ff8f01d68506283a3d0cc6bc25407}{
void \hyperlink{classmdt_device_adc7ff8f01d68506283a3d0cc6bc25407}{stop} ()}
\label{classmdt_device_adc7ff8f01d68506283a3d0cc6bc25407}

\begin{DoxyCompactList}\small\item\em Stop periodic device querying. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_a6def09a050cbf3521b615e8300c42f66}{wait} (int ms)
\begin{DoxyCompactList}\small\item\em Wait some time. \end{DoxyCompactList}\item 
\hyperlink{classmdt_error}{mdtError} \hyperlink{classmdt_device_a79ca328ff9e9f413a38c1cc9c9267cee}{lastError} () const 
\begin{DoxyCompactList}\small\item\em Get last error. \end{DoxyCompactList}\item 
\hyperlink{classmdt_value}{mdtValue} \hyperlink{classmdt_device_ab828764660ba53ffce1995901ddf5a0a}{getAnalogInputValue} (\hyperlink{classmdt_analog_io}{mdtAnalogIo} $\ast$analogInput, bool queryDevice, bool waitOnReply)
\begin{DoxyCompactList}\small\item\em Get analog input value. \end{DoxyCompactList}\item 
\hypertarget{classmdt_device_ad6a9d73cd51ce21f69dc8e4646d4fcfe}{
\hyperlink{classmdt_value}{mdtValue} {\bfseries getAnalogInputValue} (int address, bool queryDevice, bool waitOnReply)}
\label{classmdt_device_ad6a9d73cd51ce21f69dc8e4646d4fcfe}

\item 
\hypertarget{classmdt_device_a66a4c466dd6cb5c8235850f6dc23ae7b}{
\hyperlink{classmdt_value}{mdtValue} {\bfseries getAnalogInputValue} (const QString \&labelShort, bool queryDevice, bool waitOnReply)}
\label{classmdt_device_a66a4c466dd6cb5c8235850f6dc23ae7b}

\item 
int \hyperlink{classmdt_device_a98cba3132db15317daf54eb701388e91}{getAnalogInputs} (bool waitOnReply)
\begin{DoxyCompactList}\small\item\em Read all analog inputs on physical device and update (G)UI representation. \end{DoxyCompactList}\item 
\hyperlink{classmdt_value}{mdtValue} \hyperlink{classmdt_device_a163ee286d905feafe50b3e4351d4bf41}{getAnalogOutputValue} (\hyperlink{classmdt_analog_io}{mdtAnalogIo} $\ast$analogOutput, bool queryDevice, bool waitOnReply)
\begin{DoxyCompactList}\small\item\em Get analog output value. \end{DoxyCompactList}\item 
\hypertarget{classmdt_device_aa90eb1111d6778f4227224d3b1804ae7}{
\hyperlink{classmdt_value}{mdtValue} {\bfseries getAnalogOutputValue} (int addressRead, bool queryDevice, bool waitOnReply)}
\label{classmdt_device_aa90eb1111d6778f4227224d3b1804ae7}

\item 
\hypertarget{classmdt_device_ad6bfbab4c93bc0136068e773dd776010}{
\hyperlink{classmdt_value}{mdtValue} {\bfseries getAnalogOutputValue} (const QString \&labelShort, bool queryDevice, bool waitOnReply)}
\label{classmdt_device_ad6bfbab4c93bc0136068e773dd776010}

\item 
int \hyperlink{classmdt_device_a78a8968cf61c1cac518b0a8af471110c}{getAnalogOutputs} (bool waitOnReply)
\begin{DoxyCompactList}\small\item\em Read all analog outputs on physical device and update (G)UI representation. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_a766d9adcf8c2274f61f120a4a5c5c6d9}{setAnalogOutputValue} (\hyperlink{classmdt_analog_io}{mdtAnalogIo} $\ast$analogOutput, const \hyperlink{classmdt_value}{mdtValue} \&value, bool sendToDevice, bool waitOnReply)
\begin{DoxyCompactList}\small\item\em Set analog output value. \end{DoxyCompactList}\item 
\hypertarget{classmdt_device_ab605f81f28271f54570f151e94039807}{
int {\bfseries setAnalogOutputValue} (int addressWrite, const \hyperlink{classmdt_value}{mdtValue} \&value, bool sendToDevice, bool waitOnReply)}
\label{classmdt_device_ab605f81f28271f54570f151e94039807}

\item 
\hypertarget{classmdt_device_a40b49f882622c37f50a57132f954e732}{
int {\bfseries setAnalogOutputValue} (const QString \&labelShort, const \hyperlink{classmdt_value}{mdtValue} \&value, bool sendToDevice, bool waitOnReply)}
\label{classmdt_device_a40b49f882622c37f50a57132f954e732}

\item 
int \hyperlink{classmdt_device_a57e1cee7e670469035c57e3bd2ff4c9d}{setAnalogOutputs} (bool waitOnReply)
\begin{DoxyCompactList}\small\item\em Write all analog outputs on physical device and update (G)UI representation. \end{DoxyCompactList}\item 
\hyperlink{classmdt_value}{mdtValue} \hyperlink{classmdt_device_afe8bd7811ccc4a2ba8088edf073e0a8d}{getDigitalInputValue} (\hyperlink{classmdt_digital_io}{mdtDigitalIo} $\ast$digitalInput, bool queryDevice, bool waitOnReply)
\begin{DoxyCompactList}\small\item\em Get digital input value. \end{DoxyCompactList}\item 
\hypertarget{classmdt_device_a9915b677a307ffeab98a413d61b0f2e7}{
\hyperlink{classmdt_value}{mdtValue} {\bfseries getDigitalInputValue} (int address, bool queryDevice, bool waitOnReply)}
\label{classmdt_device_a9915b677a307ffeab98a413d61b0f2e7}

\item 
\hypertarget{classmdt_device_a295a2795695804cc291282d92a1c7641}{
\hyperlink{classmdt_value}{mdtValue} {\bfseries getDigitalInputValue} (const QString \&labelShort, bool queryDevice, bool waitOnReply)}
\label{classmdt_device_a295a2795695804cc291282d92a1c7641}

\item 
int \hyperlink{classmdt_device_a6e338b959c86591b6b3401f925c49050}{getDigitalInputs} (bool waitOnReply)
\begin{DoxyCompactList}\small\item\em Read all digital inputs on physical device and update (G)UI representation. \end{DoxyCompactList}\item 
\hyperlink{classmdt_value}{mdtValue} \hyperlink{classmdt_device_a978bde9f2b6177b6f3742163e7a712a9}{getDigitalOutputValue} (\hyperlink{classmdt_digital_io}{mdtDigitalIo} $\ast$digitalOutput, bool queryDevice, bool waitOnReply)
\begin{DoxyCompactList}\small\item\em Get digital output value. \end{DoxyCompactList}\item 
\hypertarget{classmdt_device_adf8160df55a9eb9ba6820e24bb7f1440}{
\hyperlink{classmdt_value}{mdtValue} {\bfseries getDigitalOutputValue} (int addressRead, bool queryDevice, bool waitOnReply)}
\label{classmdt_device_adf8160df55a9eb9ba6820e24bb7f1440}

\item 
\hypertarget{classmdt_device_a5e7b7de4243f45d8cfa42599d51555bf}{
\hyperlink{classmdt_value}{mdtValue} {\bfseries getDigitalOutputValue} (const QString \&labelShort, bool queryDevice, bool waitOnReply)}
\label{classmdt_device_a5e7b7de4243f45d8cfa42599d51555bf}

\item 
int \hyperlink{classmdt_device_ab35b81b8eb68e161ac06ae882be39a25}{getDigitalOutputs} (bool waitOnReply)
\begin{DoxyCompactList}\small\item\em Read all digital outputs on physical device and update (G)UI representation. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_a04564fd9be440c026e7c399f0e619485}{setDigitalOutputValue} (\hyperlink{classmdt_digital_io}{mdtDigitalIo} $\ast$digitalOutput, const \hyperlink{classmdt_value}{mdtValue} \&value, bool sendToDevice, bool waitOnReply)
\begin{DoxyCompactList}\small\item\em Set a digital output value. \end{DoxyCompactList}\item 
\hypertarget{classmdt_device_a5c2514c3c31a687a01a898c874d2c45e}{
int {\bfseries setDigitalOutputValue} (int addressWrite, const \hyperlink{classmdt_value}{mdtValue} \&value, bool sendToDevice, bool waitOnReply)}
\label{classmdt_device_a5c2514c3c31a687a01a898c874d2c45e}

\item 
\hypertarget{classmdt_device_a2377d24cc1e767a24dfc5e34454a8737}{
int {\bfseries setDigitalOutputValue} (const QString \&labelShort, const \hyperlink{classmdt_value}{mdtValue} \&value, bool sendToDevice, bool waitOnReply)}
\label{classmdt_device_a2377d24cc1e767a24dfc5e34454a8737}

\item 
int \hyperlink{classmdt_device_a7b86a816e55a91f0d62426e1741437c6}{setDigitalOutputs} (bool waitOnReply)
\begin{DoxyCompactList}\small\item\em Write all digital outputs to physical device and update (G)UI representation. \end{DoxyCompactList}\item 
\hypertarget{classmdt_device_a76ddf08ac78502b835b192a8f38f963f}{
\hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382da}{mdtPortManager::state\_\-t} \hyperlink{classmdt_device_a76ddf08ac78502b835b192a8f38f963f}{currentState} ()}
\label{classmdt_device_a76ddf08ac78502b835b192a8f38f963f}

\begin{DoxyCompactList}\small\item\em Get device state. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Slots}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classmdt_device_ad211ba3be781c3db0397d5bf91f796d1}{decodeReadenFrame} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Decode incoming frames. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_device_a6e7133e8665d9113d9423f4db44b1000}{
\hyperlink{classmdt_error}{mdtError} \& \hyperlink{classmdt_device_a6e7133e8665d9113d9423f4db44b1000}{lastErrorW} ()}
\label{classmdt_device_a6e7133e8665d9113d9423f4db44b1000}

\begin{DoxyCompactList}\small\item\em Get last error for write access. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_acecf7934ce29b3a957accb0f4c98c746}{readAnalogInput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read one analog input on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_a40674e7bf0c367bb3edb407d73a5bd8e}{readAnalogInputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all analog inputs on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_a7934063c3f41a742515f1232c9598c2a}{readAnalogOutput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read one analog output on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_ab0232ac83c38bc93d3bc2aa91d94c291}{readAnalogOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all analog outputs on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_ae764634bba2b321ac2b4731c0353e45f}{writeAnalogOutput} (int value, \hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write value on a analog output to physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_abc52b797df29945bf0a6358aab1b7245}{writeAnalogOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write all analog outputs to physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_af128b606050035abaf8d049bb2227015}{readDigitalInput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read one digital input on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_a150e3abae6db5bf1ad11017bf2b76c14}{readDigitalInputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all digital inputs on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_a1faee6ab31b094731211ea0943544501}{readDigitalOutput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read one digital output on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_aac038c24c3b91757584bdf0d09fb8b02}{readDigitalOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all digital outputs on physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_a0fbe57503d86554829e708b2b83d73f1}{writeDigitalOutput} (bool state, \hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write state on a digital output to physical device. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_device_aa9e8ae7b4ff2455b4105d280d8523fc1}{writeDigitalOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write all digital outputs to physical device. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classmdt_device_acba50968d201ad95c4eaa2ab2ed48b4f}{queriesSequence} ()
\begin{DoxyCompactList}\small\item\em Sequence of queries to send periodically. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$ \hyperlink{classmdt_device_a0e57cc8b749581cff447d514b9a1ff8e}{getNewTransaction} ()
\begin{DoxyCompactList}\small\item\em Get a new transaction. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_device_a4619d8be240cafe48865a89f7424de92}{restoreTransaction} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Restore a transaction into pool. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{waitTransactionDone} (int id)
\begin{DoxyCompactList}\small\item\em Wait until a transaction is done without break the GUI's event loop. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Base class for a device connected to a port. 

Querying a device can be done several ways. Some devices sends a confirmation after each query.

Some queries (f.ex. read a input value or state) give a result after query. In some applications, we need to display the reult priodically. In other application, we need to send the query and wait on result before we can continue. This base class gives a interface for these two cases.

At basis, all query methods are not blocking by default. The normal way is to connect \hyperlink{classmdt_port_manager_a416a24db1048e9f66aef27ea810954d2}{mdtPortManager::newTransactionDone()} to \hyperlink{classmdt_device_ad211ba3be781c3db0397d5bf91f796d1}{decodeReadenFrame()} slot (must be done in subclass). This way, a query will be sent to device and method returns. When device returns a result, \hyperlink{classmdt_port_manager}{mdtPortManager} will send the newTransactionDone() signal, and decoding will be processed in \hyperlink{classmdt_device_ad211ba3be781c3db0397d5bf91f796d1}{decodeReadenFrame()} and I/O's are updated.

Because the blocking behaviour is sometimes needed, the concept of transaction was implemented in \hyperlink{classmdt_port_manager}{mdtPortManager}. At first, we tell the query method (for example \hyperlink{classmdt_device_ab828764660ba53ffce1995901ddf5a0a}{getAnalogInputValue()} ) that we will wait on a reply by setting the waitOnReply flag. Then, the query is sent to device and a transaction ID is added to a list (see \hyperlink{classmdt_port_manager}{mdtPortManager} for details). At next, \hyperlink{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{waitTransactionDone()} is called, and finally result is returned. Note that \hyperlink{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{waitTransactionDone()} will not breack the Qt's event loop because it uses the \hyperlink{classmdt_port_manager_aaa85e0200aba0e0f4392dfe01abae2cf}{mdtPortManager::wait()} method (see documentation of \hyperlink{classmdt_port_manager}{mdtPortManager} for details).

If it is needed to continiusly update the representation of device's inputs (digital/analog I/O, voltage, temperature, ...), two things can happen:
\begin{DoxyItemize}
\item 1) Used port can receive data continiusly (f.ex. RS232) and device send data automatically
\item 2) Used port need that a request is sent for each read (TCP, USB, ...) or device need such request Continous update is typical usefull for a GUI representing a real device.
\end{DoxyItemize}

A other usage is automated sequence. In this case, the sequence will tell when it need to set a output and when a input value is reuqierd.

A device can accept one or many request before results must be read. This depends most case on used port and protocol.

It can be useful to find on witch port a device is attached (f.ex. setup of a automated test application). For this, \hyperlink{classmdt_device_abab1b6e45af527880ce469ae318474c0}{connectToDevice()} was introduced.

A device can have several states (ready, busy, disconnected, ...). To help the application programmer to keep consistency, this states are updated in this class using \hyperlink{classmdt_port_manager}{mdtPortManager} 's state machine. This state machine is based on QStateMachine. 

Definition at line 90 of file mdtDevice.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_device_a6d501791e7243358cc61b144254b80db}{
\index{mdtDevice@{mdtDevice}!mdtDevice@{mdtDevice}}
\index{mdtDevice@{mdtDevice}!mdtDevice@{mdtDevice}}
\subsubsection[{mdtDevice}]{\setlength{\rightskip}{0pt plus 5cm}mdtDevice::mdtDevice (
\begin{DoxyParamCaption}
\item[{QObject $\ast$}]{parent = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a6d501791e7243358cc61b144254b80db}


Construct a device object. 



\hyperlink{classmdt_device_a76ddf08ac78502b835b192a8f38f963f}{currentState()} = \hyperlink{classmdt_port_manager_a9448339d7f08ca5e18b904df25b382daa4004253e25d51b1e628bb5006dbbd153}{mdtPortManager::Disconnected}; setStateDisconnected(); connect(pvBackToReadyStateTimer, SIGNAL(timeout()), this, SLOT(setStateReady())); connect(pvBackToReadyStateTimer, SIGNAL(timeout()), this, SIGNAL(deviceReady())); 



Definition at line 30 of file mdtDevice.cpp.

\hypertarget{classmdt_device_ac2a9cfd6042f3f9d8da4e84f044d3f4a}{
\index{mdtDevice@{mdtDevice}!$\sim$mdtDevice@{$\sim$mdtDevice}}
\index{$\sim$mdtDevice@{$\sim$mdtDevice}!mdtDevice@{mdtDevice}}
\subsubsection[{$\sim$mdtDevice}]{\setlength{\rightskip}{0pt plus 5cm}mdtDevice::$\sim$mdtDevice (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_device_ac2a9cfd6042f3f9d8da4e84f044d3f4a}


Destructor. 

If queries sequence is running, it will be stopped (see \hyperlink{classmdt_device_adc7ff8f01d68506283a3d0cc6bc25407}{stop()} ). 

Definition at line 49 of file mdtDevice.cpp.



\subsection{Member Function Documentation}
\hypertarget{classmdt_device_abab1b6e45af527880ce469ae318474c0}{
\index{mdtDevice@{mdtDevice}!connectToDevice@{connectToDevice}}
\index{connectToDevice@{connectToDevice}!mdtDevice@{mdtDevice}}
\subsubsection[{connectToDevice}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtDevice::connectToDevice (
\begin{DoxyParamCaption}
\item[{const {\bf mdtDeviceInfo} \&}]{devInfo}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_device_abab1b6e45af527880ce469ae318474c0}


Search and connect to physical device. 

Will scan available ports and open the first port that has device attached matching request.


\begin{DoxyParams}{Parameters}
{\em devInfo} & Requested device's informations. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A error listed in \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} (NoError on success)
\end{DoxyReturn}
Note: default implementation does nothing and returns allways a UnhandledError. See subclass documentation for more details. 

Reimplemented in \hyperlink{classmdt_device_d_s_o1000_a_a84431cf929750a8a25d5218893736c72}{mdtDeviceDSO1000A}, \hyperlink{classmdt_device_modbus_wago_a025f0411a708a529054a0e3c0b6461cd}{mdtDeviceModbusWago}, \hyperlink{classmdt_device_scpi_ae8e886b362cbf9d1bf7064b48348b8e8}{mdtDeviceScpi}, and \hyperlink{classmdt_device_u3606_a_acf3b48b13bc179ad4f94b3011b7d607a}{mdtDeviceU3606A}.



Definition at line 65 of file mdtDevice.cpp.

\hypertarget{classmdt_device_ad211ba3be781c3db0397d5bf91f796d1}{
\index{mdtDevice@{mdtDevice}!decodeReadenFrame@{decodeReadenFrame}}
\index{decodeReadenFrame@{decodeReadenFrame}!mdtDevice@{mdtDevice}}
\subsubsection[{decodeReadenFrame}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::decodeReadenFrame (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual, slot\mbox{]}}}}
\label{classmdt_device_ad211ba3be781c3db0397d5bf91f796d1}


Decode incoming frames. 

Subclass notes:
\begin{DoxyItemize}
\item This default implementation does nothing.
\item This slot should be connected with \hyperlink{classmdt_port_manager_a416a24db1048e9f66aef27ea810954d2}{mdtPortManager::newTransactionDone(mdtPortTransaction$\ast$)} signal.
\item In this class, this connection is not made, it is the sublcass responsability to do this.
\item Once decoding was done, the concerned I/O(s) sould be updated with new value, or set to invalid value on error (see \hyperlink{classmdt_value}{mdtValue} class). Doing so will keep (G)UI consistency. 
\end{DoxyItemize}

Definition at line 969 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a98cba3132db15317daf54eb701388e91}{
\index{mdtDevice@{mdtDevice}!getAnalogInputs@{getAnalogInputs}}
\index{getAnalogInputs@{getAnalogInputs}!mdtDevice@{mdtDevice}}
\subsubsection[{getAnalogInputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::getAnalogInputs (
\begin{DoxyParamCaption}
\item[{bool}]{waitOnReply}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a98cba3132db15317daf54eb701388e91}


Read all analog inputs on physical device and update (G)UI representation. 

Will call \hyperlink{classmdt_device_a40674e7bf0c367bb3edb407d73a5bd8e}{readAnalogInputs()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_a40674e7bf0c367bb3edb407d73a5bd8e}{readAnalogInputs()} for details).

Once results are available or error occured, the internal analog inputs are updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em waitOnReply} & If true, this method will wait until reply comes in, or timeout (See \hyperlink{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{waitTransactionDone()} ), else it will return immediately after the query was sent. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout or other error, a value $<$ 0 is returned. 
\end{DoxyReturn}


Definition at line 242 of file mdtDevice.cpp.

\hypertarget{classmdt_device_ab828764660ba53ffce1995901ddf5a0a}{
\index{mdtDevice@{mdtDevice}!getAnalogInputValue@{getAnalogInputValue}}
\index{getAnalogInputValue@{getAnalogInputValue}!mdtDevice@{mdtDevice}}
\subsubsection[{getAnalogInputValue}]{\setlength{\rightskip}{0pt plus 5cm}mdtDevice::getAnalogInputValue (
\begin{DoxyParamCaption}
\item[{{\bf mdtAnalogIo} $\ast$}]{analogInput, }
\item[{bool}]{queryDevice, }
\item[{bool}]{waitOnReply}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_ab828764660ba53ffce1995901ddf5a0a}


Get analog input value. 

Get device or internal analog value. Internal value is updated if queryDevice is set.


\begin{DoxyParams}{Parameters}
{\em analogInput} & Pointer to a analog input object. \\
\hline
{\em queryDevice} & If true, value is readen from device by calling \hyperlink{classmdt_device_acecf7934ce29b3a957accb0f4c98c746}{readAnalogInput()}, else cached value is returned. Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_acecf7934ce29b3a957accb0f4c98c746}{readAnalogInput()} for details). \\
\hline
{\em waitOnReply} & If true, this method will wait until reply comes in, or timeout (See \hyperlink{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{waitTransactionDone()} ), else it will return immediately after the query was sent. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A \hyperlink{classmdt_value}{mdtValue} with valueDouble as real value and valueInt as device specific encoded fromat (if available). See \hyperlink{classmdt_value}{mdtValue} documentation for details about validity and other flags. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
analogInput must be valid.
\end{DoxyPrecond}
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.


\begin{DoxyParams}{Parameters}
{\em address} & Depending on device organisation and protocol, this can be a relative or absolute address (f.ex. MODBUS queries), a input number, etc...\\
\hline
\end{DoxyParams}
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.


\begin{DoxyParams}{Parameters}
{\em labelShort} & Short label set in I/O (see \hyperlink{classmdt_analog_io}{mdtAnalogIo} for details). \\
\hline
\end{DoxyParams}


Definition at line 161 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a78a8968cf61c1cac518b0a8af471110c}{
\index{mdtDevice@{mdtDevice}!getAnalogOutputs@{getAnalogOutputs}}
\index{getAnalogOutputs@{getAnalogOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{getAnalogOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::getAnalogOutputs (
\begin{DoxyParamCaption}
\item[{bool}]{waitOnReply}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a78a8968cf61c1cac518b0a8af471110c}


Read all analog outputs on physical device and update (G)UI representation. 

Will call \hyperlink{classmdt_device_ab0232ac83c38bc93d3bc2aa91d94c291}{readAnalogOutputs()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_ab0232ac83c38bc93d3bc2aa91d94c291}{readAnalogOutputs()} for details).

Once results are available or error occured, the internal analog outputs are updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em waitOnReply} & If true, this method will wait until reply comes in, or timeout (See \hyperlink{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{waitTransactionDone()} ), else it will return immediately after the query was sent. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout or other error, a value $<$ 0 is returned. 
\end{DoxyReturn}


Definition at line 368 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a163ee286d905feafe50b3e4351d4bf41}{
\index{mdtDevice@{mdtDevice}!getAnalogOutputValue@{getAnalogOutputValue}}
\index{getAnalogOutputValue@{getAnalogOutputValue}!mdtDevice@{mdtDevice}}
\subsubsection[{getAnalogOutputValue}]{\setlength{\rightskip}{0pt plus 5cm}mdtDevice::getAnalogOutputValue (
\begin{DoxyParamCaption}
\item[{{\bf mdtAnalogIo} $\ast$}]{analogOutput, }
\item[{bool}]{queryDevice, }
\item[{bool}]{waitOnReply}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a163ee286d905feafe50b3e4351d4bf41}


Get analog output value. 

Get device or internal analog value. Internal value is updated if queryDevice is set.


\begin{DoxyParams}{Parameters}
{\em analogOutput} & Pointer to a analog output object. \\
\hline
{\em queryDevice} & If true, value is readen from device by calling \hyperlink{classmdt_device_a7934063c3f41a742515f1232c9598c2a}{readAnalogOutput()}, else cached value is returned. Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_a7934063c3f41a742515f1232c9598c2a}{readAnalogOutput()} for details). \\
\hline
{\em waitOnReply} & If true, this method will wait until reply comes in, or timeout (See \hyperlink{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{waitTransactionDone()} ), else it will return immediately after the query was sent. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A \hyperlink{classmdt_value}{mdtValue} with valueDouble as real value and valueInt as device specific encoded fromat (if available). See \hyperlink{classmdt_value}{mdtValue} documentation for details about validity and other flags. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
analogOutput must be valid.
\end{DoxyPrecond}
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.


\begin{DoxyParams}{Parameters}
{\em addressRead} & Depending on device organisation and protocol, this can be a relative or absolute address (f.ex. MODBUS queries), a output number, etc...\\
\hline
\end{DoxyParams}
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.


\begin{DoxyParams}{Parameters}
{\em labelShort} & Short label set in I/O (see \hyperlink{classmdt_analog_io}{mdtAnalogIo} for details). \\
\hline
\end{DoxyParams}


Definition at line 288 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a6e338b959c86591b6b3401f925c49050}{
\index{mdtDevice@{mdtDevice}!getDigitalInputs@{getDigitalInputs}}
\index{getDigitalInputs@{getDigitalInputs}!mdtDevice@{mdtDevice}}
\subsubsection[{getDigitalInputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::getDigitalInputs (
\begin{DoxyParamCaption}
\item[{bool}]{waitOnReply}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a6e338b959c86591b6b3401f925c49050}


Read all digital inputs on physical device and update (G)UI representation. 

Will call \hyperlink{classmdt_device_a150e3abae6db5bf1ad11017bf2b76c14}{readDigitalInputs()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_a150e3abae6db5bf1ad11017bf2b76c14}{readDigitalInputs()} for details).

Once results are available, the internal digital inputs are updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em waitOnReply} & If true, this method will wait until reply comes in, or timeout (See \hyperlink{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{waitTransactionDone()} ), else it will return immediately after the query was sent. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout ar other error, a value $<$ 0 is returned. 
\end{DoxyReturn}


Definition at line 623 of file mdtDevice.cpp.

\hypertarget{classmdt_device_afe8bd7811ccc4a2ba8088edf073e0a8d}{
\index{mdtDevice@{mdtDevice}!getDigitalInputValue@{getDigitalInputValue}}
\index{getDigitalInputValue@{getDigitalInputValue}!mdtDevice@{mdtDevice}}
\subsubsection[{getDigitalInputValue}]{\setlength{\rightskip}{0pt plus 5cm}mdtDevice::getDigitalInputValue (
\begin{DoxyParamCaption}
\item[{{\bf mdtDigitalIo} $\ast$}]{digitalInput, }
\item[{bool}]{queryDevice, }
\item[{bool}]{waitOnReply}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_afe8bd7811ccc4a2ba8088edf073e0a8d}


Get digital input value. 

Get device or internal digital value. Internal value is updated if queryDevice is set.


\begin{DoxyParams}{Parameters}
{\em digitalInput} & Pointer to a digital input. \\
\hline
{\em queryDevice} & If true, value is readen from device by calling \hyperlink{classmdt_device_af128b606050035abaf8d049bb2227015}{readDigitalInput()}, else cached value is returned. Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_af128b606050035abaf8d049bb2227015}{readDigitalInput()} for details). \\
\hline
{\em waitOnReply} & If true, this method will wait until reply comes in, or timeout (See \hyperlink{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{waitTransactionDone()} ), else it will return immediately after the query was sent. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A \hyperlink{classmdt_value}{mdtValue} with valueBool. See \hyperlink{classmdt_value}{mdtValue} documentation for details about validity and other flags. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
digitalInput must be valid.
\end{DoxyPrecond}
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.


\begin{DoxyParams}{Parameters}
{\em address} & Depending on device organisation and protocol, this can be a relative or absolute address (f.ex. MODBUS queries), a input number, etc...\\
\hline
\end{DoxyParams}
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.


\begin{DoxyParams}{Parameters}
{\em labelShort} & Short label set in I/O (see \hyperlink{classmdt_digital_io}{mdtDigitalIo} for details). \\
\hline
\end{DoxyParams}


Definition at line 543 of file mdtDevice.cpp.

\hypertarget{classmdt_device_ab35b81b8eb68e161ac06ae882be39a25}{
\index{mdtDevice@{mdtDevice}!getDigitalOutputs@{getDigitalOutputs}}
\index{getDigitalOutputs@{getDigitalOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{getDigitalOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::getDigitalOutputs (
\begin{DoxyParamCaption}
\item[{bool}]{waitOnReply}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_ab35b81b8eb68e161ac06ae882be39a25}


Read all digital outputs on physical device and update (G)UI representation. 

Will call \hyperlink{classmdt_device_aac038c24c3b91757584bdf0d09fb8b02}{readDigitalOutputs()}, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_aac038c24c3b91757584bdf0d09fb8b02}{readDigitalOutputs()} for details).

Once results are available, the internal digital outputs are updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em waitOnReply} & If true, this method will wait until reply comes in, or timeout (See \hyperlink{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{waitTransactionDone()} ), else it will return immediately after the query was sent. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout ar other error, a value $<$ 0 is returned. 
\end{DoxyReturn}


Definition at line 750 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a978bde9f2b6177b6f3742163e7a712a9}{
\index{mdtDevice@{mdtDevice}!getDigitalOutputValue@{getDigitalOutputValue}}
\index{getDigitalOutputValue@{getDigitalOutputValue}!mdtDevice@{mdtDevice}}
\subsubsection[{getDigitalOutputValue}]{\setlength{\rightskip}{0pt plus 5cm}mdtDevice::getDigitalOutputValue (
\begin{DoxyParamCaption}
\item[{{\bf mdtDigitalIo} $\ast$}]{digitalOutput, }
\item[{bool}]{queryDevice, }
\item[{bool}]{waitOnReply}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a978bde9f2b6177b6f3742163e7a712a9}


Get digital output value. 


\begin{DoxyParams}{Parameters}
{\em digitalOutput} & Pointer to a digital output. \\
\hline
{\em queryDevice} & If true, value is readen from device by calling \hyperlink{classmdt_device_a1faee6ab31b094731211ea0943544501}{readDigitalOutput()}, else cached value is returned. Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_a1faee6ab31b094731211ea0943544501}{readDigitalOutput()} for details). \\
\hline
{\em waitOnReply} & If true, this method will wait until reply comes in, or timeout (See \hyperlink{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{waitTransactionDone()} ), else it will return immediately after the query was sent. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A \hyperlink{classmdt_value}{mdtValue} with valueBool. See \hyperlink{classmdt_value}{mdtValue} documentation for details about validity and other flags. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
digitalOutput must be valid.
\end{DoxyPrecond}
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.


\begin{DoxyParams}{Parameters}
{\em addressRead} & Depending on device organisation and protocol, this can be a relative or absolute address (f.ex. MODBUS queries), a output number, etc...\\
\hline
\end{DoxyParams}
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.


\begin{DoxyParams}{Parameters}
{\em labelShort} & Short label set in I/O (see \hyperlink{classmdt_digital_io}{mdtDigitalIo} for details). \\
\hline
\end{DoxyParams}


Definition at line 670 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a0e57cc8b749581cff447d514b9a1ff8e}{
\index{mdtDevice@{mdtDevice}!getNewTransaction@{getNewTransaction}}
\index{getNewTransaction@{getNewTransaction}!mdtDevice@{mdtDevice}}
\subsubsection[{getNewTransaction}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortTransaction} $\ast$ mdtDevice::getNewTransaction (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_device_a0e57cc8b749581cff447d514b9a1ff8e}


Get a new transaction. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}{mdtPortManager::getNewTransaction()}
\end{DoxySeeAlso}
\begin{DoxyPrecond}{Precondition}
portManager must be set before calling this method 
\end{DoxyPrecond}


Definition at line 1039 of file mdtDevice.cpp.

\hypertarget{classmdt_device_adb7099877ad2080961fae5a40117e9e5}{
\index{mdtDevice@{mdtDevice}!ios@{ios}}
\index{ios@{ios}!mdtDevice@{mdtDevice}}
\subsubsection[{ios}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtDeviceIos} $\ast$ mdtDevice::ios (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_adb7099877ad2080961fae5a40117e9e5}


Get the I/Os container. 

Will return a null pointer if I/Os was not set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()} .

Depending on subclass implementation, the I/Os container cann be set automatically, and can be deleted whenn device is destroyed.

In this base class, I/Os container is not deleted . 

Definition at line 111 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a8887a1142d3d3be673c18cf3376e7af4}{
\index{mdtDevice@{mdtDevice}!isReady@{isReady}}
\index{isReady@{isReady}!mdtDevice@{mdtDevice}}
\subsubsection[{isReady}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtDevice::isReady (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_device_a8887a1142d3d3be673c18cf3376e7af4}


Check if device is ready. 

This default implementation calls \hyperlink{classmdt_port_manager_a6dc2798324521d177fb8f79d4f6c5f0f}{mdtPortManager::isReady()} , or returns false if portManager was not set.

Note: \hyperlink{classmdt_device_a8887a1142d3d3be673c18cf3376e7af4}{isReady()} should return true only if device it ready for querying. 

Definition at line 126 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a79ca328ff9e9f413a38c1cc9c9267cee}{
\index{mdtDevice@{mdtDevice}!lastError@{lastError}}
\index{lastError@{lastError}!mdtDevice@{mdtDevice}}
\subsubsection[{lastError}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtError} mdtDevice::lastError (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_device_a79ca328ff9e9f413a38c1cc9c9267cee}


Get last error. 

\begin{Desc}
\item[\hyperlink{todo__todo000006}{Todo}]Not completly used currently, must be implemented in this class + subclasses . \end{Desc}


Definition at line 156 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a06d9178b4133fd7b23084e712af20976}{
\index{mdtDevice@{mdtDevice}!portManager@{portManager}}
\index{portManager@{portManager}!mdtDevice@{mdtDevice}}
\subsubsection[{portManager}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortManager} $\ast$ mdtDevice::portManager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_device_a06d9178b4133fd7b23084e712af20976}


Get internal port manager instance. 

Note that port manager is set by subclass, and that a Null pointer can be returned. (See subclass documentation for details) 

Reimplemented in \hyperlink{classmdt_device_modbus_aed892b501f8cbd372ccfda1a4fafa536}{mdtDeviceModbus}, and \hyperlink{classmdt_device_scpi_a7dc5ab8856a766a45bcc7e9cba0f54ca}{mdtDeviceScpi}.



Definition at line 121 of file mdtDevice.cpp.

\hypertarget{classmdt_device_acba50968d201ad95c4eaa2ab2ed48b4f}{
\index{mdtDevice@{mdtDevice}!queriesSequence@{queriesSequence}}
\index{queriesSequence@{queriesSequence}!mdtDevice@{mdtDevice}}
\subsubsection[{queriesSequence}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtDevice::queriesSequence (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_acba50968d201ad95c4eaa2ab2ed48b4f}


Sequence of queries to send periodically. 

This method is called from \hyperlink{classmdt_device_a14634fec6cd6bae810562b3bd88a5c05}{runQueries()}.

\begin{DoxyReturn}{Returns}
true if all queries are sent successfully.
\end{DoxyReturn}
Subclass notes:\par

\begin{DoxyItemize}
\item This default implementation does nothing and allways returns false.
\item This method can be reimplemented periodic queries must be sent to device. 
\end{DoxyItemize}

Reimplemented in \hyperlink{classmdt_device_modbus_a3b83b926ed1f9c3bdf7024de2745c285}{mdtDeviceModbus}.



Definition at line 964 of file mdtDevice.cpp.

\hypertarget{classmdt_device_acecf7934ce29b3a957accb0f4c98c746}{
\index{mdtDevice@{mdtDevice}!readAnalogInput@{readAnalogInput}}
\index{readAnalogInput@{readAnalogInput}!mdtDevice@{mdtDevice}}
\subsubsection[{readAnalogInput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readAnalogInput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_acecf7934ce29b3a957accb0f4c98c746}


Read one analog input on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_ab828764660ba53ffce1995901ddf5a0a}{getAnalogInputValue()} .


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details). 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_aa2a024793ae2a5e81c7e92260a70cd9e}{mdtDeviceModbus}.



Definition at line 978 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a40674e7bf0c367bb3edb407d73a5bd8e}{
\index{mdtDevice@{mdtDevice}!readAnalogInputs@{readAnalogInputs}}
\index{readAnalogInputs@{readAnalogInputs}!mdtDevice@{mdtDevice}}
\subsubsection[{readAnalogInputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readAnalogInputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_a40674e7bf0c367bb3edb407d73a5bd8e}


Read all analog inputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a98cba3132db15317daf54eb701388e91}{getAnalogInputs()} .


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains:
\begin{DoxyItemize}
\item ioCount : number of I/Os to get
\item address : first I/O address to considere
\item QueryReplyMode flag 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a846af6dbf80bbf747f3f966420ef6f92}{mdtDeviceModbus}.



Definition at line 983 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a7934063c3f41a742515f1232c9598c2a}{
\index{mdtDevice@{mdtDevice}!readAnalogOutput@{readAnalogOutput}}
\index{readAnalogOutput@{readAnalogOutput}!mdtDevice@{mdtDevice}}
\subsubsection[{readAnalogOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readAnalogOutput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_a7934063c3f41a742515f1232c9598c2a}


Read one analog output on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a163ee286d905feafe50b3e4351d4bf41}{getAnalogOutputValue()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a30c815cbe5e603e8114dcbc09849e322}{mdtDeviceModbus}.



Definition at line 988 of file mdtDevice.cpp.

\hypertarget{classmdt_device_ab0232ac83c38bc93d3bc2aa91d94c291}{
\index{mdtDevice@{mdtDevice}!readAnalogOutputs@{readAnalogOutputs}}
\index{readAnalogOutputs@{readAnalogOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{readAnalogOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readAnalogOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_ab0232ac83c38bc93d3bc2aa91d94c291}


Read all analog outputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a78a8968cf61c1cac518b0a8af471110c}{getAnalogOutputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains:
\begin{DoxyItemize}
\item ioCount : number of I/Os to get
\item address : first I/O address (for read access) to considere
\item QueryReplyMode flag 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_ae02dd44f1d873fcc15ff75d781b62b0b}{mdtDeviceModbus}.



Definition at line 993 of file mdtDevice.cpp.

\hypertarget{classmdt_device_af128b606050035abaf8d049bb2227015}{
\index{mdtDevice@{mdtDevice}!readDigitalInput@{readDigitalInput}}
\index{readDigitalInput@{readDigitalInput}!mdtDevice@{mdtDevice}}
\subsubsection[{readDigitalInput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readDigitalInput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_af128b606050035abaf8d049bb2227015}


Read one digital input on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_afe8bd7811ccc4a2ba8088edf073e0a8d}{getDigitalInputValue()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains:
\begin{DoxyItemize}
\item digitalIo object
\item QueryReplyMode flag
\item address 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a9dd05e51223ee5bb79970fbe84c501f9}{mdtDeviceModbus}.



Definition at line 1008 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a150e3abae6db5bf1ad11017bf2b76c14}{
\index{mdtDevice@{mdtDevice}!readDigitalInputs@{readDigitalInputs}}
\index{readDigitalInputs@{readDigitalInputs}!mdtDevice@{mdtDevice}}
\subsubsection[{readDigitalInputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readDigitalInputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_a150e3abae6db5bf1ad11017bf2b76c14}


Read all digital inputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a6e338b959c86591b6b3401f925c49050}{getDigitalInputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains:
\begin{DoxyItemize}
\item ioCount : number of I/Os to get
\item address : first I/O address to considere
\item QueryReplyMode flag 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a3fba9e113092f9da187cf684fb62b132}{mdtDeviceModbus}.



Definition at line 1013 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a1faee6ab31b094731211ea0943544501}{
\index{mdtDevice@{mdtDevice}!readDigitalOutput@{readDigitalOutput}}
\index{readDigitalOutput@{readDigitalOutput}!mdtDevice@{mdtDevice}}
\subsubsection[{readDigitalOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readDigitalOutput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_a1faee6ab31b094731211ea0943544501}


Read one digital output on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a978bde9f2b6177b6f3742163e7a712a9}{getDigitalOutputValue()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a13a334ac86135751893f37064d8f548d}{mdtDeviceModbus}.



Definition at line 1018 of file mdtDevice.cpp.

\hypertarget{classmdt_device_aac038c24c3b91757584bdf0d09fb8b02}{
\index{mdtDevice@{mdtDevice}!readDigitalOutputs@{readDigitalOutputs}}
\index{readDigitalOutputs@{readDigitalOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{readDigitalOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::readDigitalOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_aac038c24c3b91757584bdf0d09fb8b02}


Read all digital outputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_ab35b81b8eb68e161ac06ae882be39a25}{getDigitalOutputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains:
\begin{DoxyItemize}
\item ioCount : number of I/Os to get
\item address : first I/O address (for read access) to considere
\item QueryReplyMode flag 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a8915a036472bff0f356756992c1eae51}{mdtDeviceModbus}.



Definition at line 1023 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a4619d8be240cafe48865a89f7424de92}{
\index{mdtDevice@{mdtDevice}!restoreTransaction@{restoreTransaction}}
\index{restoreTransaction@{restoreTransaction}!mdtDevice@{mdtDevice}}
\subsubsection[{restoreTransaction}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::restoreTransaction (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_device_a4619d8be240cafe48865a89f7424de92}


Restore a transaction into pool. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}{mdtPortManager::restoreTransaction()}
\end{DoxySeeAlso}
\begin{DoxyPrecond}{Precondition}
portManager must be set before calling this method 
\end{DoxyPrecond}


Definition at line 1046 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a14634fec6cd6bae810562b3bd88a5c05}{
\index{mdtDevice@{mdtDevice}!runQueries@{runQueries}}
\index{runQueries@{runQueries}!mdtDevice@{mdtDevice}}
\subsubsection[{runQueries}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::runQueries (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}slot\mbox{]}}}}
\label{classmdt_device_a14634fec6cd6bae810562b3bd88a5c05}


Queries to send periodically. 

This slot is periodically called after a call of \hyperlink{classmdt_device_a721c5bf2cfa0eef5304333f08da182f7}{start()}. 

Definition at line 955 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a57e1cee7e670469035c57e3bd2ff4c9d}{
\index{mdtDevice@{mdtDevice}!setAnalogOutputs@{setAnalogOutputs}}
\index{setAnalogOutputs@{setAnalogOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{setAnalogOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::setAnalogOutputs (
\begin{DoxyParamCaption}
\item[{bool}]{waitOnReply}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a57e1cee7e670469035c57e3bd2ff4c9d}


Write all analog outputs on physical device and update (G)UI representation. 

To send the analog outputs values once, it's possible to set them without sending query. See \hyperlink{classmdt_device_ios}{mdtDeviceIos} and \hyperlink{classmdt_analog_io}{mdtAnalogIo} for details. Then, call this method to sent all analog outputs values to device.

\hyperlink{classmdt_device_abc52b797df29945bf0a6358aab1b7245}{writeAnalogOutputs()} will be called, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_abc52b797df29945bf0a6358aab1b7245}{writeAnalogOutputs()} for details).

Once results are available or on error, the internal analog outputs are updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em waitOnReply} & If true, this method will wait until reply comes in, or timeout (See \hyperlink{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{waitTransactionDone()} ), else it will return immediately after the query was sent. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout ar other error, a value $<$ 0 is returned. 
\end{DoxyReturn}


Definition at line 495 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a766d9adcf8c2274f61f120a4a5c5c6d9}{
\index{mdtDevice@{mdtDevice}!setAnalogOutputValue@{setAnalogOutputValue}}
\index{setAnalogOutputValue@{setAnalogOutputValue}!mdtDevice@{mdtDevice}}
\subsubsection[{setAnalogOutputValue}]{\setlength{\rightskip}{0pt plus 5cm}mdtDevice::setAnalogOutputValue (
\begin{DoxyParamCaption}
\item[{{\bf mdtAnalogIo} $\ast$}]{analogOutput, }
\item[{const {\bf mdtValue} \&}]{value, }
\item[{bool}]{sendToDevice, }
\item[{bool}]{waitOnReply}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a766d9adcf8c2274f61f120a4a5c5c6d9}


Set analog output value. 

Set device or internal analog value. Internal value is updated if queryDevice is set.


\begin{DoxyParams}{Parameters}
{\em analogOutput} & Pointer to a analog output object. \\
\hline
{\em value} & Value to send/store. \\
\hline
{\em sendToDevice} & If true, value is sent device by calling \hyperlink{classmdt_device_ae764634bba2b321ac2b4731c0353e45f}{writeAnalogOutput()}, else value is only cached. Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_ae764634bba2b321ac2b4731c0353e45f}{writeAnalogOutput()} for details). \\
\hline
{\em waitOnReply} & If true, this method will wait until reply comes in, or timeout (See \hyperlink{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{waitTransactionDone()} ), else it will return immediately after the query was sent. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout, on invalid value or other error, a value $<$ 0 is returned. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
analogOutput must be valid.
\end{DoxyPrecond}
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.


\begin{DoxyParams}{Parameters}
{\em addressWrite} & Depending on device organisation and protocol, this can be a relative or absolute address (f.ex. MODBUS queries), a output number, etc...\\
\hline
\end{DoxyParams}
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.


\begin{DoxyParams}{Parameters}
{\em labelShort} & Short label set in I/O (see \hyperlink{classmdt_analog_io}{mdtAnalogIo} for details). \\
\hline
\end{DoxyParams}


Definition at line 414 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a83cdf442f4cec7261742ca5939e390a1}{
\index{mdtDevice@{mdtDevice}!setAnalogOutputValue@{setAnalogOutputValue}}
\index{setAnalogOutputValue@{setAnalogOutputValue}!mdtDevice@{mdtDevice}}
\subsubsection[{setAnalogOutputValue}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::setAnalogOutputValue (
\begin{DoxyParamCaption}
\item[{{\bf mdtAnalogIo} $\ast$}]{analogOutput}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}slot\mbox{]}}}}
\label{classmdt_device_a83cdf442f4cec7261742ca5939e390a1}


Set value on a analog output on physical device. 

Checks device's state and send request if Ready.

This slot is used by \hyperlink{classmdt_device_ios}{mdtDeviceIos} to notify that a value has changed.

See \hyperlink{classmdt_device_a766d9adcf8c2274f61f120a4a5c5c6d9}{setAnalogOutputValue(mdtAnalogIo$\ast$, const mdtValue\&, bool, bool)} for details. 

Definition at line 933 of file mdtDevice.cpp.

\hypertarget{classmdt_device_aa241c40514683254990e742cf1bbb155}{
\index{mdtDevice@{mdtDevice}!setBackToReadyStateTimeout@{setBackToReadyStateTimeout}}
\index{setBackToReadyStateTimeout@{setBackToReadyStateTimeout}!mdtDevice@{mdtDevice}}
\subsubsection[{setBackToReadyStateTimeout}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::setBackToReadyStateTimeout (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_aa241c40514683254990e742cf1bbb155}


Set back to ready state timeout. 

After some event (device disconnected, response timeout, ...) the state can be changed from Ready to another.

Note: if state is different than Ready, the slots setAnalogOutputValue(int) and setDigitalOutputState(int) will return immediately, without trying to send a request.

In some application, it can be usefull that state comes back automatically to ready.


\begin{DoxyParams}{Parameters}
{\em timeout} & Time before go back to ready state \mbox{[}ms\mbox{]} If timeout is $<$ 0, device still in current state, and setStateReady() can be used. \\
\hline
\end{DoxyParams}


Definition at line 116 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a7b86a816e55a91f0d62426e1741437c6}{
\index{mdtDevice@{mdtDevice}!setDigitalOutputs@{setDigitalOutputs}}
\index{setDigitalOutputs@{setDigitalOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{setDigitalOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::setDigitalOutputs (
\begin{DoxyParamCaption}
\item[{bool}]{waitOnReply}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a7b86a816e55a91f0d62426e1741437c6}


Write all digital outputs to physical device and update (G)UI representation. 

To send the digital outputs values once. It's possible to use \hyperlink{classmdt_device_a04564fd9be440c026e7c399f0e619485}{setDigitalOutputValue()} without sending the query to device, then using this method to commit all values once.

See \hyperlink{classmdt_device_ios}{mdtDeviceIos} and \hyperlink{classmdt_digital_io}{mdtDigitalIo} for details.

\hyperlink{classmdt_device_aa9e8ae7b4ff2455b4105d280d8523fc1}{writeDigitalOutputs()} will be called, witch also sends the request to device. Depending on result, device's state can be updated.

Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_aa9e8ae7b4ff2455b4105d280d8523fc1}{writeDigitalOutputs()} for details).

Once results are available, the internal digital outputs are updated. (See \hyperlink{classmdt_device_ios}{mdtDeviceIos} for details).


\begin{DoxyParams}{Parameters}
{\em waitOnReply} & If true, this method will wait until reply comes in, or timeout (See \hyperlink{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{waitTransactionDone()} ), else it will return immediately after the query was sent. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout ar other error, a value $<$ 0 is returned. 
\end{DoxyReturn}


Definition at line 877 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a93abbc706a1e6601ce947eee5e50fba6}{
\index{mdtDevice@{mdtDevice}!setDigitalOutputValue@{setDigitalOutputValue}}
\index{setDigitalOutputValue@{setDigitalOutputValue}!mdtDevice@{mdtDevice}}
\subsubsection[{setDigitalOutputValue}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::setDigitalOutputValue (
\begin{DoxyParamCaption}
\item[{{\bf mdtDigitalIo} $\ast$}]{digitalOutput}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}slot\mbox{]}}}}
\label{classmdt_device_a93abbc706a1e6601ce947eee5e50fba6}


Set value on a digital output on physical device. 

Checks device's state and send request if Ready.

This slot is used by \hyperlink{classmdt_device_ios}{mdtDeviceIos} to notify that a value has changed.

See \hyperlink{classmdt_device_a04564fd9be440c026e7c399f0e619485}{setDigitalOutputValue(mdtDigitalIo$\ast$, const mdtValue\&, bool, bool)} for details. 

Definition at line 944 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a04564fd9be440c026e7c399f0e619485}{
\index{mdtDevice@{mdtDevice}!setDigitalOutputValue@{setDigitalOutputValue}}
\index{setDigitalOutputValue@{setDigitalOutputValue}!mdtDevice@{mdtDevice}}
\subsubsection[{setDigitalOutputValue}]{\setlength{\rightskip}{0pt plus 5cm}mdtDevice::setDigitalOutputValue (
\begin{DoxyParamCaption}
\item[{{\bf mdtDigitalIo} $\ast$}]{digitalOutput, }
\item[{const {\bf mdtValue} \&}]{value, }
\item[{bool}]{sendToDevice, }
\item[{bool}]{waitOnReply}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a04564fd9be440c026e7c399f0e619485}


Set a digital output value. 

Set device or internal digital value. Internal value is updated if queryDevice is set.


\begin{DoxyParams}{Parameters}
{\em digitalOutput} & Pointer to a digital output object. \\
\hline
{\em value} & Value to send/store. \\
\hline
{\em sendToDevice} & If true, value is sent device by calling \hyperlink{classmdt_device_a0fbe57503d86554829e708b2b83d73f1}{writeDigitalOutput()}, else value is only cached. Behaviour of this method can vary, depending on device specific subclass. (See sublcass \hyperlink{classmdt_device_a0fbe57503d86554829e708b2b83d73f1}{writeDigitalOutput()} for details). \\
\hline
{\em waitOnReply} & If true, this method will wait until reply comes in, or timeout (See \hyperlink{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{waitTransactionDone()} ), else it will return immediately after the query was sent. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success. If no I/O's are set, on timeout, on invalid value or other error, a value $<$ 0 is returned. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
digitalOutput must be valid.
\end{DoxyPrecond}
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.


\begin{DoxyParams}{Parameters}
{\em addressWrite} & Depending on device organisation and protocol, this can be a relative or absolute address (f.ex. MODBUS queries), a output number, etc...\\
\hline
\end{DoxyParams}
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.


\begin{DoxyParams}{Parameters}
{\em labelShort} & Short label set in I/O (see \hyperlink{classmdt_digital_io}{mdtDigitalIo} for details). \\
\hline
\end{DoxyParams}


Definition at line 797 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{
\index{mdtDevice@{mdtDevice}!setIos@{setIos}}
\index{setIos@{setIos}!mdtDevice@{mdtDevice}}
\subsubsection[{setIos}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::setIos (
\begin{DoxyParamCaption}
\item[{{\bf mdtDeviceIos} $\ast$}]{ios, }
\item[{bool}]{autoOutputUpdate = {\ttfamily false}}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}


Set the I/O's container. 


\begin{DoxyParams}{Parameters}
{\em ios} & A pointer to a \hyperlink{classmdt_device_ios}{mdtDeviceIos} object \\
\hline
{\em autoOutputUpdate} & If true, \hyperlink{classmdt_abstract_io_a43feaa62996af78f64aea084122f1370}{mdtAnalogIo::valueChanged()} signal will be connected to setAnalogOutputValue(int, int) slot for each analog output and mdtDigitalIo::stateChanged() signal will be connected to setDigitalOutputState(int, bool) slot for each digital output.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
ios must be a valid pointer 
\end{DoxyPrecond}


Definition at line 70 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a721c5bf2cfa0eef5304333f08da182f7}{
\index{mdtDevice@{mdtDevice}!start@{start}}
\index{start@{start}!mdtDevice@{mdtDevice}}
\subsubsection[{start}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::start (
\begin{DoxyParamCaption}
\item[{int}]{queryInterval}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a721c5bf2cfa0eef5304333f08da182f7}


Start periodic device querying. 

Internally, the \hyperlink{classmdt_device_a14634fec6cd6bae810562b3bd88a5c05}{runQueries()} slot will be called each queryInterval of time.

Note: if device is ready, querying starts immediatly, else it will start once device becomes ready.

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_device_a8887a1142d3d3be673c18cf3376e7af4}{isReady()} 
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em queryInterval} & Query interval \mbox{[}ms\mbox{]} \\
\hline
\end{DoxyParams}


Definition at line 134 of file mdtDevice.cpp.

\hypertarget{classmdt_device_aecd2d9d2cc3665f2084d0fd20eb3db2d}{
\index{mdtDevice@{mdtDevice}!stateChanged@{stateChanged}}
\index{stateChanged@{stateChanged}!mdtDevice@{mdtDevice}}
\subsubsection[{stateChanged}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::stateChanged (
\begin{DoxyParamCaption}
\item[{int}]{state}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_device_aecd2d9d2cc3665f2084d0fd20eb3db2d}


\hyperlink{classmdt_device_ios}{mdtDeviceIos} $\ast$pvIos; // I/O's container 

Emitted when state has changed

See setStateFromPortManager() for some details.

This signal should be used by application developpers, and not directly \hyperlink{classmdt_port_manager_a01da0634bc52a71c0df0d83fc166eeda}{mdtPortManager::stateChanged()}. This is because some actions are made when entering new state, and \hyperlink{classmdt_device_aecd2d9d2cc3665f2084d0fd20eb3db2d}{stateChanged()} is sent after.

But, to display current state in a easier way (f.ex. using \hyperlink{classmdt_port_status_widget}{mdtPortStatusWidget}), \hyperlink{classmdt_port_manager_ae00d513ed335fbd203852dcb7180005c}{mdtPortManager::stateChangedForUi()} can be used. \hypertarget{classmdt_device_a3fbc6e71241e2e9daa2d8557f870c03c}{
\index{mdtDevice@{mdtDevice}!statusMessageChanged@{statusMessageChanged}}
\index{statusMessageChanged@{statusMessageChanged}!mdtDevice@{mdtDevice}}
\subsubsection[{statusMessageChanged}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::statusMessageChanged (
\begin{DoxyParamCaption}
\item[{const QString \&}]{message, }
\item[{const QString \&}]{details, }
\item[{int}]{timeout}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_device_a3fbc6e71241e2e9daa2d8557f870c03c}


Emitted when a new status message is to display. 

Typically used with \hyperlink{classmdt_port_status_widget}{mdtPortStatusWidget} \hypertarget{classmdt_device_a6def09a050cbf3521b615e8300c42f66}{
\index{mdtDevice@{mdtDevice}!wait@{wait}}
\index{wait@{wait}!mdtDevice@{mdtDevice}}
\subsubsection[{wait}]{\setlength{\rightskip}{0pt plus 5cm}void mdtDevice::wait (
\begin{DoxyParamCaption}
\item[{int}]{ms}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_a6def09a050cbf3521b615e8300c42f66}


Wait some time. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_aaa85e0200aba0e0f4392dfe01abae2cf}{mdtPortManager::wait()} 
\end{DoxySeeAlso}
\begin{DoxyPrecond}{Precondition}
Port manager must be set before using this method 
\end{DoxyPrecond}


Definition at line 149 of file mdtDevice.cpp.

\hypertarget{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}{
\index{mdtDevice@{mdtDevice}!waitTransactionDone@{waitTransactionDone}}
\index{waitTransactionDone@{waitTransactionDone}!mdtDevice@{mdtDevice}}
\subsubsection[{waitTransactionDone}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtDevice::waitTransactionDone (
\begin{DoxyParamCaption}
\item[{int}]{id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_device_ab937015c1a319b7234442a4cc29a02a8}


Wait until a transaction is done without break the GUI's event loop. 

\begin{Desc}
\item[\hyperlink{todo__todo000007}{Todo}]Adapt, comment\end{Desc}


This is a helper method that provide a blocking wait. Internally, a couple of sleep and event processing is done, avoiding freezing the GUI.

Internally, \hyperlink{classmdt_port_manager_a5551802de2c08632078f2cc0e2607913}{mdtPortManager::waitTransactionDone()} is called.


\begin{DoxyParams}{Parameters}
{\em id} & Id returned by query method \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True on success, false on timeout. If id was not found in transactions list, a warning will be generated in \hyperlink{classmdt_error}{mdtError} system, and false will be returned. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
granularity must be $>$ 0. 
\end{DoxyPrecond}


Definition at line 1054 of file mdtDevice.cpp.

\hypertarget{classmdt_device_ae764634bba2b321ac2b4731c0353e45f}{
\index{mdtDevice@{mdtDevice}!writeAnalogOutput@{writeAnalogOutput}}
\index{writeAnalogOutput@{writeAnalogOutput}!mdtDevice@{mdtDevice}}
\subsubsection[{writeAnalogOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::writeAnalogOutput (
\begin{DoxyParamCaption}
\item[{int}]{value, }
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_ae764634bba2b321ac2b4731c0353e45f}


Write value on a analog output to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a766d9adcf8c2274f61f120a4a5c5c6d9}{setAnalogOutputValue()}.


\begin{DoxyParams}{Parameters}
{\em value} & Value encoded regarding device format. \\
\hline
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_ac63297a31205759622f341525c34251f}{mdtDeviceModbus}.



Definition at line 998 of file mdtDevice.cpp.

\hypertarget{classmdt_device_abc52b797df29945bf0a6358aab1b7245}{
\index{mdtDevice@{mdtDevice}!writeAnalogOutputs@{writeAnalogOutputs}}
\index{writeAnalogOutputs@{writeAnalogOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{writeAnalogOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::writeAnalogOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_abc52b797df29945bf0a6358aab1b7245}


Write all analog outputs to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a57e1cee7e670469035c57e3bd2ff4c9d}{setAnalogOutputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains:
\begin{DoxyItemize}
\item ioCount : number of I/Os to set
\item address : first I/O address (for write access) to considere
\item QueryReplyMode flag 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a87af02c83cede03d6ee988c678e0fc00}{mdtDeviceModbus}.



Definition at line 1003 of file mdtDevice.cpp.

\hypertarget{classmdt_device_a0fbe57503d86554829e708b2b83d73f1}{
\index{mdtDevice@{mdtDevice}!writeDigitalOutput@{writeDigitalOutput}}
\index{writeDigitalOutput@{writeDigitalOutput}!mdtDevice@{mdtDevice}}
\subsubsection[{writeDigitalOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::writeDigitalOutput (
\begin{DoxyParamCaption}
\item[{bool}]{state, }
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_a0fbe57503d86554829e708b2b83d73f1}


Write state on a digital output to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from setDigitalOutputState().


\begin{DoxyParams}{Parameters}
{\em state} & State (ON/OFF). \\
\hline
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_a6950c10fc521b193fb3c754223879694}{mdtDeviceModbus}.



Definition at line 1028 of file mdtDevice.cpp.

\hypertarget{classmdt_device_aa9e8ae7b4ff2455b4105d280d8523fc1}{
\index{mdtDevice@{mdtDevice}!writeDigitalOutputs@{writeDigitalOutputs}}
\index{writeDigitalOutputs@{writeDigitalOutputs}!mdtDevice@{mdtDevice}}
\subsubsection[{writeDigitalOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDevice::writeDigitalOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_aa9e8ae7b4ff2455b4105d280d8523fc1}


Write all digital outputs to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a7b86a816e55a91f0d62426e1741437c6}{setDigitalOutputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains:
\begin{DoxyItemize}
\item ioCount : number of I/Os to set
\item address : first I/O address (for write access) to considere
\item QueryReplyMode flag 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see mdtPortManager::writeData() for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_aad3ce85a19307e3056b940da99fe512b}{mdtDeviceModbus}.



Definition at line 1033 of file mdtDevice.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtdevice/mdtDevice.h\item 
src/mdtdevice/mdtDevice.cpp\end{DoxyCompactItemize}
