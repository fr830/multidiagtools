<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Multi diag tools: mdtUsbtmcPortManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Multi diag tools</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-slots">Public Slots</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">mdtUsbtmcPortManager Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="mdtUsbtmcPortManager" --><!-- doxytag: inherits="mdtUsbPortManager" -->
<p>USBTMC port manager.  
 <a href="classmdt_usbtmc_port_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mdt_usbtmc_port_manager_8h_source.html">mdtUsbtmcPortManager.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mdtUsbtmcPortManager:</div>
<div class="dyncontent">
<div class="center"><img src="classmdt_usbtmc_port_manager__inherit__graph.png" border="0" usemap="#mdt_usbtmc_port_manager_inherit__map" alt="Inheritance graph"/></div>
<map name="mdt_usbtmc_port_manager_inherit__map" id="mdt_usbtmc_port_manager_inherit__map">
<area shape="rect" id="node2" href="classmdt_usb_port_manager.html" title="Helper class that simplify access to USB port API." alt="" coords="16,83,157,112"/><area shape="rect" id="node4" href="classmdt_port_manager.html" title="Port manager base class." alt="" coords="28,5,145,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mdtUsbtmcPortManager:</div>
<div class="dyncontent">
<div class="center"><img src="classmdt_usbtmc_port_manager__coll__graph.png" border="0" usemap="#mdt_usbtmc_port_manager_coll__map" alt="Collaboration graph"/></div>
<map name="mdt_usbtmc_port_manager_coll__map" id="mdt_usbtmc_port_manager_coll__map">
<area shape="rect" id="node2" href="classmdt_usb_port_manager.html" title="Helper class that simplify access to USB port API." alt="" coords="275,552,417,581"/><area shape="rect" id="node4" href="classmdt_port_manager.html" title="Port manager base class." alt="" coords="287,472,405,501"/><area shape="rect" id="node6" href="classmdt_port_manager_state_machine.html" title="State machine for port manager." alt="" coords="61,360,258,389"/><area shape="rect" id="node8" href="classmdt_state_machine.html" title="Extend Qt&#39;s QStateMachine." alt="" coords="137,183,259,212"/><area shape="rect" id="node10" href="classmdt_state.html" title="Representation of a state in mdtStateMachine." alt="" coords="37,5,111,35"/><area shape="rect" id="node13" href="classmdt_port_thread.html" title="mdtPortThread" alt="" coords="369,360,475,389"/><area shape="rect" id="node15" href="classmdt_abstract_port.html" title="Base class for port I/O." alt="" coords="298,183,415,212"/><area shape="rect" id="node17" href="classmdt_port_config.html" title="mdtPortConfig" alt="" coords="303,5,410,35"/><area shape="rect" id="node19" href="classmdt_port_info.html" title="Contains informations about a port." alt="" coords="499,360,590,389"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classmdt_usbtmc_port_manager-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-slots"></a>
Public Slots</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usbtmc_port_manager.html#aca42b343ae1f6a324e6e45968f03bbea">fromThreadNewFrameReaden</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the thread whenn a frame was readen.  <a href="#aca42b343ae1f6a324e6e45968f03bbea"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usbtmc_port_manager.html#a99a24e4360e70ffc63677dbe888513f7">mdtUsbtmcPortManager</a> (QObject *parent=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a USBTMC port manager.  <a href="#a99a24e4360e70ffc63677dbe888513f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usbtmc_port_manager.html#aad6b2eef9b5cfb5c324affb6962a463b">~mdtUsbtmcPortManager</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#aad6b2eef9b5cfb5c324affb6962a463b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QList&lt; <a class="el" href="classmdt_port_info.html">mdtPortInfo</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usbtmc_port_manager.html#a992d1227810186d3c7dc166452e2e3b6">scan</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan for available ports with a USBTMC compatible device attached.  <a href="#a992d1227810186d3c7dc166452e2e3b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usbtmc_port_manager.html#a0b90ceb0bbf424222ec878a355d206d7">isReady</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if port manager is ready.  <a href="#a0b90ceb0bbf424222ec878a355d206d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usbtmc_port_manager.html#af6abc4a3693fc386a12f346f57282c11">sendCommand</a> (const QByteArray &amp;command)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a command to device.  <a href="#af6abc4a3693fc386a12f346f57282c11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QByteArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usbtmc_port_manager.html#acbbb8539c54034989b2ea6f6071e90bf">sendQuery</a> (const QByteArray &amp;query)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a query to device.  <a href="#acbbb8539c54034989b2ea6f6071e90bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usbtmc_port_manager.html#a205901666c797055bee1902bd1e1e09c">sendData</a> (<a class="el" href="classmdt_port_transaction.html">mdtPortTransaction</a> *transaction)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data on port.  <a href="#a205901666c797055bee1902bd1e1e09c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usbtmc_port_manager.html#a6d566c68ddeb7c7ca14b5c70ae784efc">sendData</a> (const QByteArray &amp;data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data by copy.  <a href="#a6d566c68ddeb7c7ca14b5c70ae784efc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usbtmc_port_manager.html#a2920bdd6b189f198f132de9e5555a78b">sendReadRequest</a> (<a class="el" href="classmdt_port_transaction.html">mdtPortTransaction</a> *transaction)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a read request to device.  <a href="#a2920bdd6b189f198f132de9e5555a78b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usbtmc_port_manager.html#ab1604a1c8f2e9192714d039dbf9a5158">sendReadRequest</a> (bool enqueueResponse)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a read request to device.  <a href="#ab1604a1c8f2e9192714d039dbf9a5158"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usbtmc_port_manager.html#a7bcc280bd4a26ed523832550b1e61553">sendReadStatusByteRequest</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a READ_STATUS_BYTE request thru the control endpoint.  <a href="#a7bcc280bd4a26ed523832550b1e61553"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>USBTMC port manager. </p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>abortBulkIn() does not work properly </dd></dl>
<p>This is the easiest way to use the USBTMC port API.</p>
<p>All needed object are created by constructor. To alter configuration, use <a class="el" href="classmdt_port_manager.html#a9cf3ea2da38f81682695b37448712ffd" title="Get the port&#39;s config object.">config()</a>. To access the usb port object, use port().</p>
<p>Use <a class="el" href="classmdt_usb_port_manager.html#ac656805c6de08c9c6a2487291cf3f347" title="Open the port.">start()</a> to begin read/write and stop to end. </p>

<p>Definition at line <a class="el" href="mdt_usbtmc_port_manager_8h_source.html#l00044">44</a> of file <a class="el" href="mdt_usbtmc_port_manager_8h_source.html">mdtUsbtmcPortManager.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a99a24e4360e70ffc63677dbe888513f7"></a><!-- doxytag: member="mdtUsbtmcPortManager::mdtUsbtmcPortManager" ref="a99a24e4360e70ffc63677dbe888513f7" args="(QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mdtUsbtmcPortManager::mdtUsbtmcPortManager </td>
          <td>(</td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a USBTMC port manager. </p>
<p>Create a thread and setup port. </p>

<p><p>connect(portThread, SIGNAL(controlResponseReaden()), this, SLOT(<a class="el" href="classmdt_usb_port_manager.html#af043c75c74665b23d13f3cb73150935c" title="Called from USB thread when a control reply was received.">fromThreadControlResponseReaden()</a>)); connect(portThread, SIGNAL(messageInReaden()), this, SLOT(<a class="el" href="classmdt_usb_port_manager.html#a9b7154590a4eb267aff4e11ba53dd7aa" title="Called from USB thread when a message IN was received ( on additionnal interrupt IN endpoint)...">fromThreadMessageInReaden()</a>)); </p>
</p>

<p>Definition at line <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html#l00037">37</a> of file <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html">mdtUsbtmcPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad6b2eef9b5cfb5c324affb6962a463b"></a><!-- doxytag: member="mdtUsbtmcPortManager::~mdtUsbtmcPortManager" ref="aad6b2eef9b5cfb5c324affb6962a463b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mdtUsbtmcPortManager::~mdtUsbtmcPortManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>Stop the manager (if running), and close the port (if open). All internal objects (port, config and threads) are deleted here. </p>

<p>Definition at line <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html#l00068">68</a> of file <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html">mdtUsbtmcPortManager.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aca42b343ae1f6a324e6e45968f03bbea"></a><!-- doxytag: member="mdtUsbtmcPortManager::fromThreadNewFrameReaden" ref="aca42b343ae1f6a324e6e45968f03bbea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtUsbtmcPortManager::fromThreadNewFrameReaden </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called by the thread whenn a frame was readen. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000059">Todo:</a></b></dt><dd>On complete frame, check bTag/bTagInverse, and INITIATE_CLEAR on error. &lt;- Should be done in thread.. </dd></dl>

<p><p>qDebug() &lt;&lt; "mdtUsbtmcPortManager::fromThreadNewFrameReaden() - bTag: " &lt;&lt; frame-&gt;bTag();</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000060">Todo:</a></b></dt><dd>Check ID coherence ? Should be a assertion ? </dd></dl>
</p>

<p>Reimplemented from <a class="el" href="classmdt_port_manager.html#a4fcc8f0699b655156e661bb3de6056cc">mdtPortManager</a>.</p>

<p>Definition at line <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html#l00297">297</a> of file <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html">mdtUsbtmcPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b90ceb0bbf424222ec878a355d206d7"></a><!-- doxytag: member="mdtUsbtmcPortManager::isReady" ref="a0b90ceb0bbf424222ec878a355d206d7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mdtUsbtmcPortManager::isReady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if port manager is ready. </p>
<p>Internally, the currentState is used to check if port manager is ready. This implementation returns true if currentState is Ready. </p>

<p>Reimplemented from <a class="el" href="classmdt_port_manager.html#a6dc2798324521d177fb8f79d4f6c5f0f">mdtPortManager</a>.</p>

<p>Definition at line <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html#l00101">101</a> of file <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html">mdtUsbtmcPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a992d1227810186d3c7dc166452e2e3b6"></a><!-- doxytag: member="mdtUsbtmcPortManager::scan" ref="a992d1227810186d3c7dc166452e2e3b6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; <a class="el" href="classmdt_port_info.html">mdtPortInfo</a> * &gt; mdtUsbtmcPortManager::scan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scan for available ports with a USBTMC compatible device attached. </p>
<p>Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Manager must be closed </dd></dl>

<p>Reimplemented from <a class="el" href="classmdt_usb_port_manager.html#a3a2370c3a2d0353a880bf9b777728c3b">mdtUsbPortManager</a>.</p>

<p>Definition at line <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html#l00072">72</a> of file <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html">mdtUsbtmcPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6abc4a3693fc386a12f346f57282c11"></a><!-- doxytag: member="mdtUsbtmcPortManager::sendCommand" ref="af6abc4a3693fc386a12f346f57282c11" args="(const QByteArray &amp;command)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mdtUsbtmcPortManager::sendCommand </td>
          <td>(</td>
          <td class="paramtype">const QByteArray &amp;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a command to device. </p>
<p>At first, this method waits until the ready state is set calling <a class="el" href="classmdt_usbtmc_port_manager.html#a0b90ceb0bbf424222ec878a355d206d7" title="Check if port manager is ready.">isReady()</a> , a frame is available in port's write frames pool, and until a transaction is possible (see <a class="el" href="classmdt_port_manager.html#ac04a12f8aa20ba04695083afce45a6cc" title="Wait until transaction pending queue has less than maximum possible items.">waitTransactionPossible()</a> ). This wait will not break event loop, so no GUI freeze occurs. If port manager is stopped during this wait (unhandled error, stop request), this method returns.</p>
<p>Note that the wait will not break the GUI's event loop (see mdtPortManager::waitOnWriteReady() for details).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>Command to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bTag on success, or a error &lt; 0 (see mdtUsbtmcPortManager::writeData() for details). </dd></dl>

<p>Definition at line <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html#l00106">106</a> of file <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html">mdtUsbtmcPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a205901666c797055bee1902bd1e1e09c"></a><!-- doxytag: member="mdtUsbtmcPortManager::sendData" ref="a205901666c797055bee1902bd1e1e09c" args="(mdtPortTransaction *transaction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mdtUsbtmcPortManager::sendData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmdt_port_transaction.html">mdtPortTransaction</a> *&#160;</td>
          <td class="paramname"><em>transaction</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send data on port. </p>
<p>At first, this method waits until the ready state is set calling <a class="el" href="classmdt_usbtmc_port_manager.html#a0b90ceb0bbf424222ec878a355d206d7" title="Check if port manager is ready.">isReady()</a> , a frame is available in port's write frames pool, and until a transaction is possible (see <a class="el" href="classmdt_port_manager.html#ac04a12f8aa20ba04695083afce45a6cc" title="Wait until transaction pending queue has less than maximum possible items.">waitTransactionPossible()</a> ). This wait will not break event loop, so no GUI freeze occurs. If port manager is stopped during this wait (unhandled error, stop request), this method returns.</p>
<p>Then, data contained in transaction will be passed to the mdtPort's write queue by copy. This method returns immediatly after enqueue, and don't wait until data was written.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">transaction</td><td>Transaction used to send data. Following members are used by this method:<ul>
<li>id : transaction will be added to pending transactions with this id, and currentTransactionId will be set with it.</li>
<li>data : will be sent to port.</li>
<li>isQueryReplyMode : if true, the transaction will be keeped in transactions done queue until <a class="el" href="classmdt_port_manager.html#a830ae182d06dd6a52c43a7f45b9240ac" title="Get data by frame ID.">readenFrame()</a> or <a class="el" href="classmdt_port_manager.html#addd5dcae9644cea42a9871205af41796" title="Get all readen data.">readenFrames()</a> is called. Note: it's possible to force keeping all incomming data (wich also owerwrite this flag) by setting the global keepTransactionsDone flag.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bTag on success or value &lt; 0 on error. In this implementation, the only possible error is <a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85eae50ff4a9393507ad39005ddc7d5be42f">mdtAbstractPort::WriteCanceled</a>, witch typically occurs when port manager stops. Note: on failure, the transaction is restored to pool. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Port must be set with <a class="el" href="classmdt_port_manager.html#afcd156b2d0c9d340999935efb6cd8cb6" title="Set port object.">setPort()</a> before use of this method. </dd>
<dd>
transaction must be a valid pointer, and not allready exists in transactions pending or transactions done queue. </dd></dl>

<p>Reimplemented from <a class="el" href="classmdt_port_manager.html#ad98399edba146af5cf32a9002094385c">mdtPortManager</a>.</p>

<p>Definition at line <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html#l00138">138</a> of file <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html">mdtUsbtmcPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d566c68ddeb7c7ca14b5c70ae784efc"></a><!-- doxytag: member="mdtUsbtmcPortManager::sendData" ref="a6d566c68ddeb7c7ca14b5c70ae784efc" args="(const QByteArray &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mdtUsbtmcPortManager::sendData </td>
          <td>(</td>
          <td class="paramtype">const QByteArray &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write data by copy. </p>
<p>At first, this method waits until the ready state is set calling <a class="el" href="classmdt_usbtmc_port_manager.html#a0b90ceb0bbf424222ec878a355d206d7" title="Check if port manager is ready.">isReady()</a> , a frame is available in port's write frames pool, and until a transaction is possible (see <a class="el" href="classmdt_port_manager.html#ac04a12f8aa20ba04695083afce45a6cc" title="Wait until transaction pending queue has less than maximum possible items.">waitTransactionPossible()</a> ). This wait will not break event loop, so no GUI freeze occurs. If port manager is stopped during this wait (unhandled error, stop request), this method returns.</p>
<p>Then, data will be encoded regarding USBTMC standard and passed to the mdtUsbPort's write queue by copy. This method returns immediatly after enqueue, and don't wait until data was written.</p>
<p>This method does not use transaction, because no response will be returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Data to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bTag ID on success or <a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85eae50ff4a9393507ad39005ddc7d5be42f">mdtAbstractPort::WriteCanceled</a> (&lt; 0). </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Port must be set with <a class="el" href="classmdt_port_manager.html#afcd156b2d0c9d340999935efb6cd8cb6" title="Set port object.">setPort()</a> before use of this method. </dd></dl>

<p>Definition at line <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html#l00190">190</a> of file <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html">mdtUsbtmcPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbbb8539c54034989b2ea6f6071e90bf"></a><!-- doxytag: member="mdtUsbtmcPortManager::sendQuery" ref="acbbb8539c54034989b2ea6f6071e90bf" args="(const QByteArray &amp;query)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QByteArray mdtUsbtmcPortManager::sendQuery </td>
          <td>(</td>
          <td class="paramtype">const QByteArray &amp;&#160;</td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a query to device. </p>
<p>Will wait until it's possible to write. See <a class="el" href="classmdt_usbtmc_port_manager.html#a205901666c797055bee1902bd1e1e09c" title="Send data on port.">sendData()</a> and <a class="el" href="classmdt_usbtmc_port_manager.html#a2920bdd6b189f198f132de9e5555a78b" title="Send a read request to device.">sendReadRequest()</a> for details (used internally).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>Query to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Result as string (empty string on error) Note that <a class="el" href="classmdt_frame_codec_scpi.html" title="#include &lt;QVariant&gt;">mdtFrameCodecScpi</a> can be helpful to decode returned result. </dd></dl>

<p>Definition at line <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html#l00111">111</a> of file <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html">mdtUsbtmcPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2920bdd6b189f198f132de9e5555a78b"></a><!-- doxytag: member="mdtUsbtmcPortManager::sendReadRequest" ref="a2920bdd6b189f198f132de9e5555a78b" args="(mdtPortTransaction *transaction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mdtUsbtmcPortManager::sendReadRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmdt_port_transaction.html">mdtPortTransaction</a> *&#160;</td>
          <td class="paramname"><em>transaction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a read request to device. </p>
<p>USBTMC standard need that a read request is sent to device before we can read any data.</p>
<p>At first, this method waits until the ready state is set calling <a class="el" href="classmdt_usbtmc_port_manager.html#a0b90ceb0bbf424222ec878a355d206d7" title="Check if port manager is ready.">isReady()</a> , and a frame is available in port's write frames pool. This wait will not break event loop, so no GUI freeze occurs. If port manager is stopped during this wait (unhandled error, stop request), this method returns.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">transaction</td><td>A pointer to a valid transaction, with queryReplyMode set. (id will be set internally). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bTag ID on success or <a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85eae50ff4a9393507ad39005ddc7d5be42f">mdtAbstractPort::WriteCanceled</a> (&lt; 0). On failure, the transaction is restored to pool. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>port must be set </dd>
<dd>
transaction must be a valid pointer </dd></dl>

<p>Definition at line <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html#l00204">204</a> of file <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html">mdtUsbtmcPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1604a1c8f2e9192714d039dbf9a5158"></a><!-- doxytag: member="mdtUsbtmcPortManager::sendReadRequest" ref="ab1604a1c8f2e9192714d039dbf9a5158" args="(bool enqueueResponse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mdtUsbtmcPortManager::sendReadRequest </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enqueueResponse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a read request to device. </p>
<p>USBTMC standard need that a read request is sent to device before we can read any data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">enqueueResponse</td><td>When data comes in,</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000061">Todo:</a></b></dt><dd>SigName is emited. In blocking mode, data must (additionally) be enqueued until there are readen. So, for blocking mode ("script"), set this parameter true. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bTag ID on success or value &lt; 0 if write queue is full. </dd></dl>

<p>Definition at line <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html#l00257">257</a> of file <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html">mdtUsbtmcPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7bcc280bd4a26ed523832550b1e61553"></a><!-- doxytag: member="mdtUsbtmcPortManager::sendReadStatusByteRequest" ref="a7bcc280bd4a26ed523832550b1e61553" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mdtUsbtmcPortManager::sendReadStatusByteRequest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a READ_STATUS_BYTE request thru the control endpoint. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>bTag on success or WriteQueueEmpty on error.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000058">Todo:</a></b></dt><dd>finish ! </dd></dl>

<p><p>m.sendControlRequest(f); End Sandbox ! </p>
</p>

<p>Definition at line <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html#l00269">269</a> of file <a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html">mdtUsbtmcPortManager.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/mdtport/<a class="el" href="mdt_usbtmc_port_manager_8h_source.html">mdtUsbtmcPortManager.h</a></li>
<li>src/mdtport/<a class="el" href="mdt_usbtmc_port_manager_8cpp_source.html">mdtUsbtmcPortManager.cpp</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sun Jan 12 2014 12:42:30 for Multi diag tools by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
