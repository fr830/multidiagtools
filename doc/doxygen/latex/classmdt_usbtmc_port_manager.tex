\hypertarget{classmdt_usbtmc_port_manager}{
\section{mdtUsbtmcPortManager Class Reference}
\label{classmdt_usbtmc_port_manager}\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
}


\#include \char`\"{}mdtUsbtmcPort.h\char`\"{}  




{\ttfamily \#include $<$mdtUsbtmcPortManager.h$>$}



Inheritance diagram for mdtUsbtmcPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=202pt]{classmdt_usbtmc_port_manager__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtUsbtmcPortManager:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=202pt]{classmdt_usbtmc_port_manager__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Slots}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_usbtmc_port_manager_af16af21bb713410e3441e0d092872aab}{
void {\bfseries frameWritten} ()}
\label{classmdt_usbtmc_port_manager_af16af21bb713410e3441e0d092872aab}

\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_usbtmc_port_manager_a99a24e4360e70ffc63677dbe888513f7}{mdtUsbtmcPortManager} (QObject $\ast$parent=0)
\begin{DoxyCompactList}\small\item\em Construct a USBTMC port manager. \end{DoxyCompactList}\item 
\hyperlink{classmdt_usbtmc_port_manager_aad6b2eef9b5cfb5c324affb6962a463b}{$\sim$mdtUsbtmcPortManager} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_usbtmc_port_manager_afc1afc7deb3f5d7cf6031037d63e9bff}{writeData} (QByteArray data, bool waitAnswer)
\begin{DoxyCompactList}\small\item\em Scan available USBTMC ports. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_usbtmc_port_manager_a7ff9a9ada7919af9a90286859695a29d}{writeData} (QByteArray data)
\begin{DoxyCompactList}\small\item\em Write data by copy. \end{DoxyCompactList}\item 
\hypertarget{classmdt_usbtmc_port_manager_ad75e0cc788d1768f7fac6e63166f2cdb}{
QByteArray {\bfseries readData} ()}
\label{classmdt_usbtmc_port_manager_ad75e0cc788d1768f7fac6e63166f2cdb}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
\#include \char`\"{}mdtUsbtmcPort.h\char`\"{} 

USBTMC port manager

This is the easiest way to use the USBTMC port API.

All needed object are created by constructor. To alter configuration, use \hyperlink{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{config()}. To access the usb port object, use port().

Use \hyperlink{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{start()} to begin read/write and stop to end. 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_usbtmc_port_manager_a99a24e4360e70ffc63677dbe888513f7}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{mdtUsbtmcPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtUsbtmcPortManager::mdtUsbtmcPortManager (
\begin{DoxyParamCaption}
\item[{QObject $\ast$}]{parent = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_a99a24e4360e70ffc63677dbe888513f7}


Construct a USBTMC port manager. 

Creates a \hyperlink{classmdt_port_config}{mdtPortConfig}, a \hyperlink{classmdt_usb_port}{mdtUsbPort}, and thread object. 

setPort(new mdtUsbtmcPort); pvPort-\/$>$setConfig(new mdtPortConfig); /Q\_\-ASSERT(pvWriteThread != 0); /connect(pvWriteThread, SIGNAL(frameWritten()), this, SLOT(frameWritten())); Set USBTMC specific configuration /setConfig(new \hyperlink{classmdt_port_config}{mdtPortConfig}); \hyperlink{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{config()}.setFrameType(mdtFrame::FT\_\-ASCII); \hyperlink{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{config()}.setEndOfFrameSeq(\char`\"{}$\backslash$n\char`\"{}); \hyperlink{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{config()}.setReadFrameSize(512); \hyperlink{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{config()}.setWriteFrameSize(512); Flags pvFrameWritten = false; pvWaitingFrame = false;

\hypertarget{classmdt_usbtmc_port_manager_aad6b2eef9b5cfb5c324affb6962a463b}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!$\sim$mdtUsbtmcPortManager@{$\sim$mdtUsbtmcPortManager}}
\index{$\sim$mdtUsbtmcPortManager@{$\sim$mdtUsbtmcPortManager}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{$\sim$mdtUsbtmcPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtUsbtmcPortManager::$\sim$mdtUsbtmcPortManager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_aad6b2eef9b5cfb5c324affb6962a463b}


Destructor. 

Stop the manager (if running), and close the port (if open). All internal objects (port, config and threads) are deleted here. 

delete pvPort; 



\subsection{Member Function Documentation}
\hypertarget{classmdt_usbtmc_port_manager_afc1afc7deb3f5d7cf6031037d63e9bff}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!writeData@{writeData}}
\index{writeData@{writeData}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{writeData}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtUsbtmcPortManager::writeData (
\begin{DoxyParamCaption}
\item[{QByteArray}]{data, }
\item[{bool}]{waitAnswer}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_afc1afc7deb3f5d7cf6031037d63e9bff}


Scan available USBTMC ports. 

QStringList \hyperlink{classmdt_port_manager_aceb9b570a2ebf354e347b8d9b46f6927}{scan()};

Write data to device

By sending data, it's important to tell if the device will return some data back. This is due to large timeout of USBTMC kernel driver whenn no data are available on port. \begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager}{mdtPortManager} 

\hyperlink{classmdt_usbtmc_port}{mdtUsbtmcPort}
\end{DoxySeeAlso}
QStringList \hyperlink{classmdt_port_manager_aceb9b570a2ebf354e347b8d9b46f6927}{mdtUsbtmcPortManager::scan()} \{ QStringList portNames; QStringList availablePorts; \hyperlink{classmdt_usbtmc_port}{mdtUsbtmcPort} $\ast$port; QFileInfoList filesInfo; QDir dir; QStringList extList;

We only need system files dir.setFilter(QDir::Files $|$ QDir::System); USBTMC interfaces extList $<$$<$ \char`\"{}usbtmc$\ast$\char`\"{}; Common device directory dir.setPath(\char`\"{}/dev\char`\"{}); if(!dir.exists())\{ \hyperlink{classmdt_error}{mdtError} e(MDT\_\-UNDEFINED\_\-ERROR, \char`\"{}directory '\char`\"{} + dir.dirName() + \char`\"{}' not exists\char`\"{}, mdtError::Error); MDT\_\-ERROR\_\-SET\_\-SRC(e, \char`\"{}mdtSerialPortManagerPosix\char`\"{}); e.commit(); return availablePorts; \} dir.setNameFilters(extList); Gest list of found files filesInfo = dir.entryInfoList(); Construct the list of absolute file paths for(int i=0; i$<$filesInfo.size(); ++i)\{ portNames $<$$<$ filesInfo.at(i).absoluteFilePath(); \} Sort the list portNames = mdtAlgorithms::sortStringListWithNumericEnd(portNames); For each port name, try to open the port and get some attributes (to see if it really exists) for(int i=0; i$<$portNames.size(); ++i)\{ Try to open port port = new \hyperlink{classmdt_usbtmc_port}{mdtUsbtmcPort}; Q\_\-ASSERT(port != 0); port-\/$>$setPortName(portNames.at(i)); if(port-\/$>$open() == \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eab898bd273effe5cb4ed1a399a2d4baad}{mdtAbstractPort::NoError})\{ availablePorts.append(portNames.at(i)); port-\/$>$close(); \} delete port; \}

return availablePorts; \} \hypertarget{classmdt_usbtmc_port_manager_a7ff9a9ada7919af9a90286859695a29d}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!writeData@{writeData}}
\index{writeData@{writeData}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{writeData}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtUsbtmcPortManager::writeData (
\begin{DoxyParamCaption}
\item[{QByteArray}]{data}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_a7ff9a9ada7919af9a90286859695a29d}


Write data by copy. 

Data will be passed to the mdtPort's write queue by copy. This method returns immediatly after enqueue, and don't wait until data was written.


\begin{DoxyParams}{Parameters}
{\em data} & Data to write \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True on success. False if write queue is full. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_port_manager_a6d3cc4e522326e2a6ca0da401ae58271}{mdtPortManager}.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtUsbtmcPortManager.h\item 
src/mdtport/mdtUsbtmcPortManager.cpp\end{DoxyCompactItemize}
