\hypertarget{classmdt_port_manager}{
\section{mdtPortManager Class Reference}
\label{classmdt_port_manager}\index{mdtPortManager@{mdtPortManager}}
}


Port manager base class.  




{\ttfamily \#include $<$mdtPortManager.h$>$}



Inheritance diagram for mdtPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{classmdt_port_manager__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=254pt]{classmdt_port_manager__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Slots}
\begin{DoxyCompactItemize}
\item 
virtual void \hyperlink{classmdt_port_manager_a1d185e9bb610aee16ccd9499ae7bff0d}{abort} ()
\begin{DoxyCompactList}\small\item\em Cancel read and write operations. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{fromThreadNewFrameReaden} ()
\begin{DoxyCompactList}\small\item\em Try to. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}{onThreadsErrorOccured} (int error)
\begin{DoxyCompactList}\small\item\em Manage errors comming from port threads. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Signals}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_port_manager_a77ef4a432306638f5b0f91df7863ac62}{newReadenFrame} (QByteArray data)
\begin{DoxyCompactList}\small\item\em Emitted when new frame was readen. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a915ff3372cccd5f412b828cc81a3381f}{newReadenFrame} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} transaction)
\begin{DoxyCompactList}\small\item\em Emitted when new frame was readen. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a053ba62f090eced0cf635c9be5c6b052}{
void \hyperlink{classmdt_port_manager_a053ba62f090eced0cf635c9be5c6b052}{errorStateChanged} (int error)}
\label{classmdt_port_manager_a053ba62f090eced0cf635c9be5c6b052}

\begin{DoxyCompactList}\small\item\em Emitted when error number has changed. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_port_manager_a5ec36523089b7528d973e29cdbc64d01}{mdtPortManager} (QObject $\ast$parent=0)
\item 
virtual \hyperlink{classmdt_port_manager_adf797f8fd7a3ffdc000890a224e4c1b6}{$\sim$mdtPortManager} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
virtual QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}{scan} ()
\begin{DoxyCompactList}\small\item\em Scan for available ports. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort} (\hyperlink{classmdt_abstract_port}{mdtAbstractPort} $\ast$port)
\begin{DoxyCompactList}\small\item\em Set port object. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a39cb4af4aedc0b6b7c4d4f53002c3fd1}{detachPort} (bool deletePort, bool deleteThreads)
\begin{DoxyCompactList}\small\item\em Detach port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}{addThread} (\hyperlink{classmdt_port_thread}{mdtPortThread} $\ast$thread)
\begin{DoxyCompactList}\small\item\em Add a thread and assign it to port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_aaa0a474183bcae0fff4fb9ef43023c25}{removeThreads} (bool releaseMemory)
\begin{DoxyCompactList}\small\item\em Detach threads from port and remove threads. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{start} ()
\begin{DoxyCompactList}\small\item\em Start threads. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_af460167e604b8b6e2e933a98b2b6b5a2}{isRunning} ()
\begin{DoxyCompactList}\small\item\em Get the running state. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_aacbf87cc3d9c37c87e21696f8a6514bd}{stop} ()
\begin{DoxyCompactList}\small\item\em Stop threads. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}{setPortName} (const QString \&portName)
\begin{DoxyCompactList}\small\item\em Set port name. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a7e2ef93ec2731e66aa2b2d5f7ce9bc1c}{setPortInfo} (\hyperlink{classmdt_port_info}{mdtPortInfo} info)
\begin{DoxyCompactList}\small\item\em Set port info. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}{
\hyperlink{classmdt_port_info}{mdtPortInfo} \hyperlink{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}{portInfo} ()}
\label{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}

\begin{DoxyCompactList}\small\item\em Get port info. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_port_config}{mdtPortConfig} \& \hyperlink{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{config} ()
\begin{DoxyCompactList}\small\item\em Get the port's config object. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{openPort} ()
\begin{DoxyCompactList}\small\item\em Open the port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ace8065f1f5083041ee7f65c2892bc77d}{closePort} ()
\begin{DoxyCompactList}\small\item\em Close the port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a7f0bc97ad55160ea09b9079dd6d816d4}{setTransactionsEnabled} ()
\begin{DoxyCompactList}\small\item\em Enable transactions support. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a40f6d2a420d1ce103af207237c45901a}{setTransactionsDisabled} (bool enqueueIncommingFrames)
\begin{DoxyCompactList}\small\item\em Diseable transactions support. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$ \hyperlink{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}{getNewTransaction} ()
\begin{DoxyCompactList}\small\item\em Get a new transaction. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_ae1cc1010067bcbf104fb3d1b19f2fa48}{waitOnWriteReady} (int timeout, int granularity=50)
\begin{DoxyCompactList}\small\item\em Wait until data can be written. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{writeData} (QByteArray data)
\begin{DoxyCompactList}\small\item\em Write data by copy. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_a44ca338c8c56893612301e09d2ee6e88}{waitReadenFrame} (int timeout=500)
\begin{DoxyCompactList}\small\item\em Wait until a complete frame is available. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_manager_a5afae1537acf351f3f4a1d30c3997476}{waitOnFrame} (int id, int timeout=500, int granularity=50)
\begin{DoxyCompactList}\small\item\em Wait on readen frame with defined ID. \end{DoxyCompactList}\item 
QByteArray \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame} (int id)
\begin{DoxyCompactList}\small\item\em Get data by frame ID. \end{DoxyCompactList}\item 
QList$<$ QByteArray $>$ \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames} ()
\begin{DoxyCompactList}\small\item\em Get all readen data. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classmdt_port_manager_acc5c63ad33fdd3cc153fc23e00c6e69c}{wait} (int msecs, int granularity=50)
\begin{DoxyCompactList}\small\item\em Wait some time without break the GUI's event loop. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}{restoreTransaction} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Restore a transaction into pool. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ae5357262f1a0d6b95cc3fc7b975cdd38}{addTransaction} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Add a transaction to pending queue. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a4b5300fbf05c2c267ca3a247ac3ab77f}{addTransaction} (int id, bool queryReplyMode)
\begin{DoxyCompactList}\small\item\em Add a transaction to pending queue. \end{DoxyCompactList}\item 
\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$ \hyperlink{classmdt_port_manager_a117486e5720465e1295d337063d536c2}{pendingTransaction} (int id)
\begin{DoxyCompactList}\small\item\em Get pending transaction matching id. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ada4b906ade973dfd45200dacbfe63f73}{removeTransactionDone} (int id)
\begin{DoxyCompactList}\small\item\em Remove a transaction from DONE queue and restore it to pool. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ad024a2db17ae2e6459da0adad3d7c3c8}{enqueueTransactionDone} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Add a transaction to the DONE queue. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_ab30fc99951b2b6a566422c7525106ddf}{enqueueTransactionRx} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Add a transaction to the RX queue. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_manager_a84d37b380080eb26e56c68424dedd958}{commitFrames} ()
\begin{DoxyCompactList}\small\item\em Emit signals for each done transactions. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_port_manager_af856162aab4f1c5202c1dfb330fae538}{
\hyperlink{classmdt_abstract_port}{mdtAbstractPort} $\ast$ {\bfseries pvPort}}
\label{classmdt_port_manager_af856162aab4f1c5202c1dfb330fae538}

\item 
\hypertarget{classmdt_port_manager_a8e0d49b789f8b01d469e84b487799573}{
QList$<$ \hyperlink{classmdt_port_thread}{mdtPortThread} $\ast$ $>$ {\bfseries pvThreads}}
\label{classmdt_port_manager_a8e0d49b789f8b01d469e84b487799573}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Port manager base class. 

Manages a port based on \hyperlink{classmdt_abstract_port}{mdtAbstractPort} an several threads based on \hyperlink{classmdt_port_thread}{mdtPortThread}. The goal is to hide the complexity of the port API.

Example: 
\begin{DoxyCode}
 mdtPortManager m;
 mdtPort *port;
 mdtPortConfig *config;
 QList<QByteArray> responses;

 // Setup
 config = new mdtPortConfig;
 config->setFrameType(mdtFrame::FT_ASCII);
 config->setEndOfFrameSeq("$");

 // Init port
 port = new mdtPort;
 port->setConfig(config);

 // Init port manager - We wand blocking mode
 m.setTransactionsDisabled(true);
 m.setPort(port);
 m.addThread(mew mdtPortWriteThread);
 m.addThread(mew mdtPortReadThread);
 m.setPortName("/dev/xyz"));
 if(!m.openPort()){
  // Handle error
 }

 // Start threads
 if(!m.start()){
  // Handle error
 }

 // Send some data
 if(!m.writeData("Test$")){
  // Handle error
 }

 // Wait on answer - Timout: 1500 [ms]
 if(!m.waitReadenFrame(1500)){
  // Timout , handle error
 }

 // Do something with received data
 responses = m.readenFrames();
 for(int i=0; i<responses.size(); i++){
  qDebug() << responses.at(i);
 }

 // Cleanup - detachPort() will delete port and threads objects
 m.detachPort(true, true);
 delete config;
\end{DoxyCode}


A (recommended) alternative is to disable frames enqueuing and use the \hyperlink{classmdt_port_manager_a77ef4a432306638f5b0f91df7863ac62}{newReadenFrame(QByteArray)} signal.
\begin{DoxyItemize}
\item Disable enqueuing with setTransactionsDisabled(false)
\item Connect \hyperlink{classmdt_port_manager_a77ef4a432306638f5b0f91df7863ac62}{newReadenFrame(QByteArray)} to a slot 
\end{DoxyItemize}

Definition at line 104 of file mdtPortManager.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_port_manager_a5ec36523089b7528d973e29cdbc64d01}{
\index{mdtPortManager@{mdtPortManager}!mdtPortManager@{mdtPortManager}}
\index{mdtPortManager@{mdtPortManager}!mdtPortManager@{mdtPortManager}}
\subsubsection[{mdtPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtPortManager::mdtPortManager (
\begin{DoxyParamCaption}
\item[{QObject $\ast$}]{parent = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a5ec36523089b7528d973e29cdbc64d01}


pvEnqueueReadenFrames = false; pvNotifyNewReadenFrame = false; 



Definition at line 30 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_adf797f8fd7a3ffdc000890a224e4c1b6}{
\index{mdtPortManager@{mdtPortManager}!$\sim$mdtPortManager@{$\sim$mdtPortManager}}
\index{$\sim$mdtPortManager@{$\sim$mdtPortManager}!mdtPortManager@{mdtPortManager}}
\subsubsection[{$\sim$mdtPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtPortManager::$\sim$mdtPortManager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_adf797f8fd7a3ffdc000890a224e4c1b6}


Destructor. 

If a port was set, the manager will stop (if running), and port will be closed (if open).

Note that port set by \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} and threads are not deleted. 

Definition at line 43 of file mdtPortManager.cpp.



\subsection{Member Function Documentation}
\hypertarget{classmdt_port_manager_a1d185e9bb610aee16ccd9499ae7bff0d}{
\index{mdtPortManager@{mdtPortManager}!abort@{abort}}
\index{abort@{abort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{abort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::abort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual, slot\mbox{]}}}}
\label{classmdt_port_manager_a1d185e9bb610aee16ccd9499ae7bff0d}


Cancel read and write operations. 

Default implementation calls \hyperlink{classmdt_abstract_port_abde440c49b95833f821e1333c40a7398}{mdtAbstractPort::flush()}. 

pvPort-\/$>$flushIn(); pvPort-\/$>$flushOut(); 



Definition at line 414 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}{
\index{mdtPortManager@{mdtPortManager}!addThread@{addThread}}
\index{addThread@{addThread}!mdtPortManager@{mdtPortManager}}
\subsubsection[{addThread}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::addThread (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortThread} $\ast$}]{thread}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}


Add a thread and assign it to port. 

\begin{DoxyPrecond}{Precondition}
Port must be set with setPort before using this method 

Manager must no running 

thread must be a valid pointer 
\end{DoxyPrecond}


Definition at line 97 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ae5357262f1a0d6b95cc3fc7b975cdd38}{
\index{mdtPortManager@{mdtPortManager}!addTransaction@{addTransaction}}
\index{addTransaction@{addTransaction}!mdtPortManager@{mdtPortManager}}
\subsubsection[{addTransaction}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::addTransaction (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_ae5357262f1a0d6b95cc3fc7b975cdd38}


Add a transaction to pending queue. 

Add a existing transaction to the pending queue. A transaction can be requested with \hyperlink{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}{getNewTransaction()}.

If id and queryReplyMode are sufficient, see addTransaction(id, bool).

\begin{DoxyPrecond}{Precondition}
transaction must be a valid pointer. 
\end{DoxyPrecond}


Definition at line 469 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a4b5300fbf05c2c267ca3a247ac3ab77f}{
\index{mdtPortManager@{mdtPortManager}!addTransaction@{addTransaction}}
\index{addTransaction@{addTransaction}!mdtPortManager@{mdtPortManager}}
\subsubsection[{addTransaction}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::addTransaction (
\begin{DoxyParamCaption}
\item[{int}]{id, }
\item[{bool}]{queryReplyMode}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a4b5300fbf05c2c267ca3a247ac3ab77f}


Add a transaction to pending queue. 

Will get a new transaction and add it to pending transactions queue.


\begin{DoxyParams}{Parameters}
{\em id} & Frame ID (f.ex. transaction ID in MODBUS/TCP, bTag in USBTMC) \\
\hline
{\em queryReplyMode} & If true, transaction will be keeped in transactions done queue until \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} or \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()} is called. If false, transaction will be removed from transactions done queue just after\\
\hline
\end{DoxyParams}
\begin{Desc}
\item[\hyperlink{todo__todo000031}{Todo}]sigName is emited. \end{Desc}


Definition at line 484 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ace8065f1f5083041ee7f65c2892bc77d}{
\index{mdtPortManager@{mdtPortManager}!closePort@{closePort}}
\index{closePort@{closePort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{closePort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::closePort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_ace8065f1f5083041ee7f65c2892bc77d}


Close the port. 

This stops the threads (if exists) and close the port.

If port was never set (with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} ), this method does nothing. 

Definition at line 212 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a84d37b380080eb26e56c68424dedd958}{
\index{mdtPortManager@{mdtPortManager}!commitFrames@{commitFrames}}
\index{commitFrames@{commitFrames}!mdtPortManager@{mdtPortManager}}
\subsubsection[{commitFrames}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::commitFrames (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a84d37b380080eb26e56c68424dedd958}


Emit signals for each done transactions. 

The emited signals depend on setup ....

Internally, transactions are restored to pool.

\begin{DoxyNote}{Note}
Clarify + implement 
\end{DoxyNote}


Definition at line 528 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{
\index{mdtPortManager@{mdtPortManager}!config@{config}}
\index{config@{config}!mdtPortManager@{mdtPortManager}}
\subsubsection[{config}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortConfig} \& mdtPortManager::config (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}


Get the port's config object. 

Usefull to alter internal port configuration

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_serial_port_manager_a4b8ab7b9d53966a1887d9ce8557b8416}{mdtSerialPortManager}.



Definition at line 194 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a39cb4af4aedc0b6b7c4d4f53002c3fd1}{
\index{mdtPortManager@{mdtPortManager}!detachPort@{detachPort}}
\index{detachPort@{detachPort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{detachPort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::detachPort (
\begin{DoxyParamCaption}
\item[{bool}]{deletePort, }
\item[{bool}]{deleteThreads}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a39cb4af4aedc0b6b7c4d4f53002c3fd1}


Detach port. 

Will detach port from each thread and from port manager. If port was not set, this method does nothing. If manager is running, it will be stopped. If port is open, it will be closed.


\begin{DoxyParams}{Parameters}
{\em deletePort} & If true, the port object that was set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} will be deleted. \\
\hline
{\em deleteThreads} & If true, each thread added with \hyperlink{classmdt_port_manager_ab62591409d019a4a2576b4310c411b8f}{addThread()} will be deleted. \\
\hline
\end{DoxyParams}


Definition at line 76 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ad024a2db17ae2e6459da0adad3d7c3c8}{
\index{mdtPortManager@{mdtPortManager}!enqueueTransactionDone@{enqueueTransactionDone}}
\index{enqueueTransactionDone@{enqueueTransactionDone}!mdtPortManager@{mdtPortManager}}
\subsubsection[{enqueueTransactionDone}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::enqueueTransactionDone (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_ad024a2db17ae2e6459da0adad3d7c3c8}


Add a transaction to the DONE queue. 

\begin{DoxyPrecond}{Precondition}
transaction must be a valid pointer. 
\end{DoxyPrecond}


Definition at line 513 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ab30fc99951b2b6a566422c7525106ddf}{
\index{mdtPortManager@{mdtPortManager}!enqueueTransactionRx@{enqueueTransactionRx}}
\index{enqueueTransactionRx@{enqueueTransactionRx}!mdtPortManager@{mdtPortManager}}
\subsubsection[{enqueueTransactionRx}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::enqueueTransactionRx (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_ab30fc99951b2b6a566422c7525106ddf}


Add a transaction to the RX queue. 

\begin{DoxyPrecond}{Precondition}
transaction must be a valid pointer. 
\end{DoxyPrecond}


Definition at line 520 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{
\index{mdtPortManager@{mdtPortManager}!fromThreadNewFrameReaden@{fromThreadNewFrameReaden}}
\index{fromThreadNewFrameReaden@{fromThreadNewFrameReaden}!mdtPortManager@{mdtPortManager}}
\subsubsection[{fromThreadNewFrameReaden}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::fromThreadNewFrameReaden (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual, slot\mbox{]}}}}
\label{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}


Try to. 

Called by the read thread whenn a complete frame was readen

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_thread}{mdtPortThread} 
\end{DoxySeeAlso}


\begin{Desc}
\item[\hyperlink{todo__todo000028}{Todo}]Error on incomplete frame \end{Desc}




Reimplemented in \hyperlink{classmdt_modbus_tcp_port_manager_ad941ea607f00db54aa6deb2866a539e9}{mdtModbusTcpPortManager}, and \hyperlink{classmdt_usbtmc_port_manager_aca42b343ae1f6a324e6e45968f03bbea}{mdtUsbtmcPortManager}.



Definition at line 423 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}{
\index{mdtPortManager@{mdtPortManager}!getNewTransaction@{getNewTransaction}}
\index{getNewTransaction@{getNewTransaction}!mdtPortManager@{mdtPortManager}}
\subsubsection[{getNewTransaction}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortTransaction} $\ast$ mdtPortManager::getNewTransaction (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a75ebd3d1859e3ed38b9558981e53aac4}


Get a new transaction. 

If transactions pool is empty, a new transaction is created. Note that each transaction should be put back in pool with \hyperlink{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}{restoreTransaction()}.

\begin{DoxyReturn}{Returns}
A empty transaction (\hyperlink{classmdt_port_transaction_a5f7b04df58291d52e61c5bd1b7f7bb7f}{mdtPortTransaction::clear()} is called internally).
\end{DoxyReturn}
\begin{DoxyPostcond}{Postcondition}
Returned transaction is valid (never Null). 
\end{DoxyPostcond}


Definition at line 242 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_af460167e604b8b6e2e933a98b2b6b5a2}{
\index{mdtPortManager@{mdtPortManager}!isRunning@{isRunning}}
\index{isRunning@{isRunning}!mdtPortManager@{mdtPortManager}}
\subsubsection[{isRunning}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::isRunning (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_af460167e604b8b6e2e933a98b2b6b5a2}


Get the running state. 

If one of the threads is running, true is returned.

If port was not set, it returns false. 

Definition at line 148 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a77ef4a432306638f5b0f91df7863ac62}{
\index{mdtPortManager@{mdtPortManager}!newReadenFrame@{newReadenFrame}}
\index{newReadenFrame@{newReadenFrame}!mdtPortManager@{mdtPortManager}}
\subsubsection[{newReadenFrame}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::newReadenFrame (
\begin{DoxyParamCaption}
\item[{QByteArray}]{data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a77ef4a432306638f5b0f91df7863ac62}


Emitted when new frame was readen. 

This variant is sent when transactions support is OFF. (See \hyperlink{classmdt_port_manager_a40f6d2a420d1ce103af207237c45901a}{setTransactionsDisabled()} for details). \hypertarget{classmdt_port_manager_a915ff3372cccd5f412b828cc81a3381f}{
\index{mdtPortManager@{mdtPortManager}!newReadenFrame@{newReadenFrame}}
\index{newReadenFrame@{newReadenFrame}!mdtPortManager@{mdtPortManager}}
\subsubsection[{newReadenFrame}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::newReadenFrame (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction}}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_manager_a915ff3372cccd5f412b828cc81a3381f}


Emitted when new frame was readen. 

This variant is sent when transactions support is ON. (See \hyperlink{classmdt_port_manager_a40f6d2a420d1ce103af207237c45901a}{setTransactionsDisabled()} for details). \hypertarget{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}{
\index{mdtPortManager@{mdtPortManager}!onThreadsErrorOccured@{onThreadsErrorOccured}}
\index{onThreadsErrorOccured@{onThreadsErrorOccured}!mdtPortManager@{mdtPortManager}}
\subsubsection[{onThreadsErrorOccured}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::onThreadsErrorOccured (
\begin{DoxyParamCaption}
\item[{int}]{error}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}slot\mbox{]}}}}
\label{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}


Manage errors comming from port threads. 

\begin{Desc}
\item[\hyperlink{todo__todo000029}{Todo}]Error handling (in general ...) 

On disconnect, should flush I/O ? \end{Desc}


Definition at line 451 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{
\index{mdtPortManager@{mdtPortManager}!openPort@{openPort}}
\index{openPort@{openPort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{openPort}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::openPort (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}


Open the port. 

Will try to open port defined with \hyperlink{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}{setPortName()}.

\begin{DoxyReturn}{Returns}
True on success, false else. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}
\begin{Desc}
\item[\hyperlink{todo__todo000030}{Todo}]Should return \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \end{Desc}


Definition at line 201 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a117486e5720465e1295d337063d536c2}{
\index{mdtPortManager@{mdtPortManager}!pendingTransaction@{pendingTransaction}}
\index{pendingTransaction@{pendingTransaction}!mdtPortManager@{mdtPortManager}}
\subsubsection[{pendingTransaction}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtPortTransaction} $\ast$ mdtPortManager::pendingTransaction (
\begin{DoxyParamCaption}
\item[{int}]{id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a117486e5720465e1295d337063d536c2}


Get pending transaction matching id. 

\begin{DoxyReturn}{Returns}
A valid transaction if exists, else a Null pointer. 
\end{DoxyReturn}


Definition at line 496 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{
\index{mdtPortManager@{mdtPortManager}!readenFrame@{readenFrame}}
\index{readenFrame@{readenFrame}!mdtPortManager@{mdtPortManager}}
\subsubsection[{readenFrame}]{\setlength{\rightskip}{0pt plus 5cm}QByteArray mdtPortManager::readenFrame (
\begin{DoxyParamCaption}
\item[{int}]{id}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}


Get data by frame ID. 

The frame ID is a protocol specific identification. F.ex. in MODBUS/TCP, the transaction ID is used, or bTag for USBTMC.

If found, the frame is removed from received queue. (A second call with same ID will return a empty QByteArray).

If ID was not found, a empty QByteArray is returned.

Note: if transactions support is diseabled, a empty QByteArray is allways returned. 

Definition at line 363 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{
\index{mdtPortManager@{mdtPortManager}!readenFrames@{readenFrames}}
\index{readenFrames@{readenFrames}!mdtPortManager@{mdtPortManager}}
\subsubsection[{readenFrames}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ QByteArray $>$ mdtPortManager::readenFrames (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}


Get all readen data. 

Note that calling this methode will clear the internal queue. (A second call will return a empty list). 

Definition at line 376 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_aaa0a474183bcae0fff4fb9ef43023c25}{
\index{mdtPortManager@{mdtPortManager}!removeThreads@{removeThreads}}
\index{removeThreads@{removeThreads}!mdtPortManager@{mdtPortManager}}
\subsubsection[{removeThreads}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::removeThreads (
\begin{DoxyParamCaption}
\item[{bool}]{releaseMemory}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_aaa0a474183bcae0fff4fb9ef43023c25}


Detach threads from port and remove threads. 


\begin{DoxyParams}{Parameters}
{\em releaseMemory} & If true, all threads are deleted \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port manager must not running. 
\end{DoxyPrecond}


Definition at line 113 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ada4b906ade973dfd45200dacbfe63f73}{
\index{mdtPortManager@{mdtPortManager}!removeTransactionDone@{removeTransactionDone}}
\index{removeTransactionDone@{removeTransactionDone}!mdtPortManager@{mdtPortManager}}
\subsubsection[{removeTransactionDone}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::removeTransactionDone (
\begin{DoxyParamCaption}
\item[{int}]{id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_ada4b906ade973dfd45200dacbfe63f73}


Remove a transaction from DONE queue and restore it to pool. 

If transaction not exists in DONE queue, this method simply makes nothing. 

Definition at line 503 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}{
\index{mdtPortManager@{mdtPortManager}!restoreTransaction@{restoreTransaction}}
\index{restoreTransaction@{restoreTransaction}!mdtPortManager@{mdtPortManager}}
\subsubsection[{restoreTransaction}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::restoreTransaction (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_manager_a5fea4a9b8e94d38e8ec699dba05c7ca8}


Restore a transaction into pool. 

\begin{DoxyPrecond}{Precondition}
transaction must be a valid pointer (not Null) 
\end{DoxyPrecond}


Definition at line 464 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}{
\index{mdtPortManager@{mdtPortManager}!scan@{scan}}
\index{scan@{scan}!mdtPortManager@{mdtPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtPortManager::scan (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}


Scan for available ports. 

This method is implemented is port's specific subclass. Default implementation returns a empty list.

Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).

\begin{DoxyPrecond}{Precondition}
Manager must no running 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_usb_port_manager_a3a2370c3a2d0353a880bf9b777728c3b}{mdtUsbPortManager}, \hyperlink{classmdt_usbtmc_port_manager_a992d1227810186d3c7dc166452e2e3b6}{mdtUsbtmcPortManager}, and \hyperlink{classmdt_serial_port_manager_a791572f869d1d605d0c4658ca4187260}{mdtSerialPortManager}.



Definition at line 61 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{
\index{mdtPortManager@{mdtPortManager}!setPort@{setPort}}
\index{setPort@{setPort}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setPort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setPort (
\begin{DoxyParamCaption}
\item[{{\bf mdtAbstractPort} $\ast$}]{port}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}


Set port object. 

\begin{DoxyPrecond}{Precondition}
port must be a valid pointer to the expected class instance (for ex: \hyperlink{classmdt_serial_port}{mdtSerialPort}). 

Manager must no running 
\end{DoxyPrecond}


Definition at line 68 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a7e2ef93ec2731e66aa2b2d5f7ce9bc1c}{
\index{mdtPortManager@{mdtPortManager}!setPortInfo@{setPortInfo}}
\index{setPortInfo@{setPortInfo}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setPortInfo}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setPortInfo (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortInfo}}]{info}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a7e2ef93ec2731e66aa2b2d5f7ce9bc1c}


Set port info. 

Store given port info, and call \hyperlink{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}{setPortName()} with port info's stored port name (see \hyperlink{classmdt_port_info_ad456aac33dccc9b0583ed8aa4796cdf0}{mdtPortInfo::portName()} ).

Setting a port info can be usefull if other informations are needed later in application (f.ex. \hyperlink{classmdt_port_info_a38bcac67372782228a91d8e7dbf49211}{mdtPortInfo::displayText()} ). You can get port informations later with \hyperlink{classmdt_port_manager_a88109b455fc5a5f5adf0636f7450143e}{portInfo()}. 

Definition at line 183 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}{
\index{mdtPortManager@{mdtPortManager}!setPortName@{setPortName}}
\index{setPortName@{setPortName}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setPortName}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setPortName (
\begin{DoxyParamCaption}
\item[{const QString \&}]{portName}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a2b2ed690cbba9f544c6ac1b46684e59a}


Set port name. 

Set the port name to internally port object. Does nothing else. To open the port, use \hyperlink{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{openPort()}.

\begin{DoxyPrecond}{Precondition}
Port must be set before with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} 
\end{DoxyPrecond}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_abstract_port}{mdtAbstractPort} 
\end{DoxySeeAlso}


Definition at line 176 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a40f6d2a420d1ce103af207237c45901a}{
\index{mdtPortManager@{mdtPortManager}!setTransactionsDisabled@{setTransactionsDisabled}}
\index{setTransactionsDisabled@{setTransactionsDisabled}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setTransactionsDisabled}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setTransactionsDisabled (
\begin{DoxyParamCaption}
\item[{bool}]{enqueueIncommingFrames}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a40f6d2a420d1ce103af207237c45901a}


Diseable transactions support. 

See \hyperlink{classmdt_port_manager_a7f0bc97ad55160ea09b9079dd6d816d4}{setTransactionsEnabled()} for details about transactions.

If transactions are disabled, it's only possible to choose once if blocking mode is supported. Each time a frame comes in, the newReadenFrame(int, QByteArray) signal is emited.

In this mode, \hyperlink{classmdt_port_manager_a5afae1537acf351f3f4a1d30c3997476}{waitOnFrame()} will allways timeout.


\begin{DoxyParams}{Parameters}
{\em enqueueIncommingFrames} & If true, each incomming frame is enqueued (usefull for blocking mode). Note: if true, don't forget to take each frame with \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} or \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()}.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port manager must not running when this method is called. 
\end{DoxyPrecond}


Definition at line 234 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a7f0bc97ad55160ea09b9079dd6d816d4}{
\index{mdtPortManager@{mdtPortManager}!setTransactionsEnabled@{setTransactionsEnabled}}
\index{setTransactionsEnabled@{setTransactionsEnabled}!mdtPortManager@{mdtPortManager}}
\subsubsection[{setTransactionsEnabled}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::setTransactionsEnabled (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a7f0bc97ad55160ea09b9079dd6d816d4}


Enable transactions support. 

Transaction is usefull for protocols wich supports frame identification (like transaction ID in MODBUS/TCP or bTag in USBTMC).

If transaction support is enabled, port manager can work on both event (signal) and blocking mode \char`\"{}on the fly\char`\"{}. Each time a frame comes in, the \hyperlink{classmdt_port_manager_a915ff3372cccd5f412b828cc81a3381f}{newReadenFrame(mdtPortTransaction)} signal is emited. Optionnaly, it's possible to request that a frame must be enqueued for a given transaction (regarding a specific ID), witch is requierd for blocking mode (see \hyperlink{classmdt_port_manager_a5afae1537acf351f3f4a1d30c3997476}{waitOnFrame()} ).

Note that not all port manager support transactions. For example, this default implementation cannot work with transactions. By default, they are disabled, and no frame is enqueued (see \hyperlink{classmdt_port_manager_a40f6d2a420d1ce103af207237c45901a}{setTransactionsDisabled()}). See specific subclass for details.

\begin{DoxyPrecond}{Precondition}
Port manager must not running when this method is called. 
\end{DoxyPrecond}


Definition at line 226 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{
\index{mdtPortManager@{mdtPortManager}!start@{start}}
\index{start@{start}!mdtPortManager@{mdtPortManager}}
\subsubsection[{start}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::start (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}


Start threads. 

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Definition at line 133 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_aacbf87cc3d9c37c87e21696f8a6514bd}{
\index{mdtPortManager@{mdtPortManager}!stop@{stop}}
\index{stop@{stop}!mdtPortManager@{mdtPortManager}}
\subsubsection[{stop}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::stop (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_aacbf87cc3d9c37c87e21696f8a6514bd}


Stop threads. 

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Definition at line 165 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_acc5c63ad33fdd3cc153fc23e00c6e69c}{
\index{mdtPortManager@{mdtPortManager}!wait@{wait}}
\index{wait@{wait}!mdtPortManager@{mdtPortManager}}
\subsubsection[{wait}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortManager::wait (
\begin{DoxyParamCaption}
\item[{int}]{msecs, }
\item[{int}]{granularity = {\ttfamily 50}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classmdt_port_manager_acc5c63ad33fdd3cc153fc23e00c6e69c}


Wait some time without break the GUI's event loop. 

This is a helper method that provide a blocking wait. Internally, a couple of sleep and event processing is done, avoiding freesing the GUI.

This wait method is not precise.


\begin{DoxyParams}{Parameters}
{\em msecs} & Time to wait \mbox{[}ms\mbox{]} \\
\hline
{\em granularity} & Sleep time between each call of event processing \mbox{[}ms\mbox{]}\par
 A little value needs more CPU and big value can freese the GUI. Should be between 50 and 100, and must be $>$ 0. Note that msecs must be a multiple of granularity. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
granularity must be $>$ 0. 
\end{DoxyPrecond}


Definition at line 401 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a5afae1537acf351f3f4a1d30c3997476}{
\index{mdtPortManager@{mdtPortManager}!waitOnFrame@{waitOnFrame}}
\index{waitOnFrame@{waitOnFrame}!mdtPortManager@{mdtPortManager}}
\subsubsection[{waitOnFrame}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::waitOnFrame (
\begin{DoxyParamCaption}
\item[{int}]{id, }
\item[{int}]{timeout = {\ttfamily 500}, }
\item[{int}]{granularity = {\ttfamily 50}}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a5afae1537acf351f3f4a1d30c3997476}


Wait on readen frame with defined ID. 

Will return when frame with given ID was read or after timeout.

Internally, a couple of sleep and process event are called, so Qt's event loop will not be broken.


\begin{DoxyParams}{Parameters}
{\em id} & Frame ID. Depending on protocol, this can be a transaction ID or what else. \\
\hline
{\em timeout} & Maximum wait time \mbox{[}ms\mbox{]}. Must be a multiple of granularity \mbox{[}ms\mbox{]} \\
\hline
{\em granularity} & Sleep time between each call of event processing \mbox{[}ms\mbox{]}\par
 A little value needs more CPU and big value can freese the GUI. Should be between 50 and 100, and must be $>$ 0. Note that timeout must be a multiple of granularity. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if Ok, false on timeout. If id was not found in transactions lists, a warning will be generated in \hyperlink{classmdt_error}{mdtError} system, and false will be returned. 
\end{DoxyReturn}


Definition at line 334 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_ae1cc1010067bcbf104fb3d1b19f2fa48}{
\index{mdtPortManager@{mdtPortManager}!waitOnWriteReady@{waitOnWriteReady}}
\index{waitOnWriteReady@{waitOnWriteReady}!mdtPortManager@{mdtPortManager}}
\subsubsection[{waitOnWriteReady}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::waitOnWriteReady (
\begin{DoxyParamCaption}
\item[{int}]{timeout, }
\item[{int}]{granularity = {\ttfamily 50}}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_ae1cc1010067bcbf104fb3d1b19f2fa48}


Wait until data can be written. 

Wait until a frame is available in write frames pool. The wait will not breack Qt's event loop, so this method can be called from GUI Thread. (See \hyperlink{classmdt_port_manager_acc5c63ad33fdd3cc153fc23e00c6e69c}{wait()} for details).


\begin{DoxyParams}{Parameters}
{\em timeout} & Timeout \mbox{[}ms\mbox{]} \\
\hline
{\em granularity} & Sleep time between each call of event processing \mbox{[}ms\mbox{]}\par
 A little value needs more CPU and big value can freese the GUI. Should be between 50 and 100, and must be $>$ 0. Note that timeout must be a multiple of granularity. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if a frame is available before timeout, false else. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Granularity must be $>$ 0. 

Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before calling this method. 
\end{DoxyPrecond}


Definition at line 257 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a44ca338c8c56893612301e09d2ee6e88}{
\index{mdtPortManager@{mdtPortManager}!waitReadenFrame@{waitReadenFrame}}
\index{waitReadenFrame@{waitReadenFrame}!mdtPortManager@{mdtPortManager}}
\subsubsection[{waitReadenFrame}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortManager::waitReadenFrame (
\begin{DoxyParamCaption}
\item[{int}]{timeout = {\ttfamily 500}}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_manager_a44ca338c8c56893612301e09d2ee6e88}


Wait until a complete frame is available. 

This method will return when a complete frame was readen. This is usefull for query/answer protocols.

Internally, a couple of sleep and process event are called, so Qt's event loop will not be broken.


\begin{DoxyParams}{Parameters}
{\em timeout} & Maximum wait time \mbox{[}ms\mbox{]}. Must be a multiple of 50 \mbox{[}ms\mbox{]} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if Ok, false on timeout 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager_a77ef4a432306638f5b0f91df7863ac62}{newReadenFrame()} 
\end{DoxySeeAlso}


Definition at line 307 of file mdtPortManager.cpp.

\hypertarget{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{
\index{mdtPortManager@{mdtPortManager}!writeData@{writeData}}
\index{writeData@{writeData}!mdtPortManager@{mdtPortManager}}
\subsubsection[{writeData}]{\setlength{\rightskip}{0pt plus 5cm}int mdtPortManager::writeData (
\begin{DoxyParamCaption}
\item[{QByteArray}]{data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}


Write data by copy. 

Data will be passed to the mdtPort's write queue by copy. This method returns immediatly after enqueue, and don't wait until data was written.


\begin{DoxyParams}{Parameters}
{\em data} & Data to write \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success or value $<$ 0 on error. In this implementation, the only possible error is mdtAbstractPort::WriteQueueEmpty . Some subclass can return a frame ID on success, or a other error. See subclass documentation for details. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method.
\end{DoxyPrecond}
Subclass notes:\par
 This method can be reimplemented in subclass if needed. Typically usefull if some encoding is needed before the frame is submitted to port. A frame must be taken from port's write frames pool with \hyperlink{classmdt_abstract_port_abf093b67fddebffa4f3c52277b9a8cf7}{mdtAbstractPort::writeFramesPool()} dequeue() method (see Qt's QQueue documentation for more details on dequeue() ), then added to port's write queue with \hyperlink{classmdt_abstract_port_a9a69eb2fc07d551ab37c011487fa319d}{mdtAbstractPort::addFrameToWrite()} . If protocol supports frame identification (like MODBUS's transaction ID or USBTMC's bTag), it should be returned here and incremented. 

Reimplemented in \hyperlink{classmdt_usbtmc_port_manager_ab7229e9d519e80a6509bec90dc9239b3}{mdtUsbtmcPortManager}.



Definition at line 280 of file mdtPortManager.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtPortManager.h\item 
src/mdtport/mdtPortManager.cpp\end{DoxyCompactItemize}
