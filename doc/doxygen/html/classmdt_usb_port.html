<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Multi diag tools: mdtUsbPort Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Multi diag tools</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">mdtUsbPort Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="mdtUsbPort" --><!-- doxytag: inherits="mdtAbstractPort" -->
<p>USB port I/O port class.  
 <a href="classmdt_usb_port.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mdt_usb_port_8h_source.html">mdtUsbPort.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mdtUsbPort:</div>
<div class="dyncontent">
<div class="center"><img src="classmdt_usb_port__inherit__graph.png" border="0" usemap="#mdt_usb_port_inherit__map" alt="Inheritance graph"/></div>
<map name="mdt_usb_port_inherit__map" id="mdt_usb_port_inherit__map">
<area shape="rect" id="node2" href="classmdt_abstract_port.html" title="Base class for port I/O." alt="" coords="5,5,123,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mdtUsbPort:</div>
<div class="dyncontent">
<div class="center"><img src="classmdt_usb_port__coll__graph.png" border="0" usemap="#mdt_usb_port_coll__map" alt="Collaboration graph"/></div>
<map name="mdt_usb_port_coll__map" id="mdt_usb_port_coll__map">
<area shape="rect" id="node2" href="classmdt_abstract_port.html" title="Base class for port I/O." alt="" coords="5,101,123,131"/><area shape="rect" id="node4" href="classmdt_port_config.html" title="mdtPortConfig" alt="" coords="11,5,117,35"/><area shape="rect" id="node6" href="classmdt_frame_usb_control.html" title="USB Control frame." alt="" coords="147,101,293,131"/><area shape="rect" id="node8" href="classmdt_frame.html" title="Provide an array of bytes." alt="" coords="180,5,260,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classmdt_usb_port-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a311650f4b2d29b6f16336c8777196d1c"></a><!-- doxytag: member="mdtUsbPort::mdtUsbPort" ref="a311650f4b2d29b6f16336c8777196d1c" args="(QObject *parent=0)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>mdtUsbPort</b> (QObject *parent=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa9f1942ca4ae384887441e01b362c16"></a><!-- doxytag: member="mdtUsbPort::~mdtUsbPort" ref="afa9f1942ca4ae384887441e01b362c16" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#afa9f1942ca4ae384887441e01b362c16">~mdtUsbPort</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#af2399348faf1abc20130eab20cfc36ee">reconnect</a> (int timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconnect device.  <a href="#af2399348faf1abc20130eab20cfc36ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a44ed5024a81a573b5196b8f64c42cd6a">setReadTimeout</a> (int timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the read data timeout.  <a href="#a44ed5024a81a573b5196b8f64c42cd6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a592af88bd7e7f45dd80df0ecab375ace">setWriteTimeout</a> (int timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the write data timeout.  <a href="#a592af88bd7e7f45dd80df0ecab375ace"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QQueue&lt; <a class="el" href="classmdt_frame_usb_control.html">mdtFrameUsbControl</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#af146b08006ddbe18fb537ae1a75b622e">controlFramesPool</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the control pool queue.  <a href="#af146b08006ddbe18fb537ae1a75b622e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QQueue&lt; <a class="el" href="classmdt_frame_usb_control.html">mdtFrameUsbControl</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#afbb20c403e7a5885d5e4221bab9f304e">controlQueryFrames</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the control query queue.  <a href="#afbb20c403e7a5885d5e4221bab9f304e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a4fbcd0fcc179335c55c6d7ccc40a7c31">addControlRequest</a> (<a class="el" href="classmdt_frame_usb_control.html">mdtFrameUsbControl</a> *frame, bool setwIndexAsbInterfaceNumber=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a control request.  <a href="#a4fbcd0fcc179335c55c6d7ccc40a7c31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a274b6fd10bd84027bb66773ed805de2a">submitControlQuery</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a control query.  <a href="#a274b6fd10bd84027bb66773ed805de2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a6566e654df8a1c3503941702593db3c5">cancelControlTransfer</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel current control transfer.  <a href="#a6566e654df8a1c3503941702593db3c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QQueue&lt; <a class="el" href="classmdt_frame_usb_control.html">mdtFrameUsbControl</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a304825c7d9173a3dcb5e26a412f1038b">controlResponseFrames</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the control responses queue.  <a href="#a304825c7d9173a3dcb5e26a412f1038b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a719fc7b43461a3e2d9a4926d3e3961c2">requestReadUntilShortPacketReceived</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request to read until a short packet is received.  <a href="#a719fc7b43461a3e2d9a4926d3e3961c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a3c0685d67fe608abe24c140c2858779c">readUntilShortPacketReceivedRequestPending</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a request to read until a short packet is received is pending.  <a href="#a3c0685d67fe608abe24c140c2858779c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#af546a031ed8621fee1d5e9498cbcd174">readBufferSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get read buffer size.  <a href="#af546a031ed8621fee1d5e9498cbcd174"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a5e380852b8726f71e8558c86cba5bd1f">initReadTransfer</a> (qint64 maxSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read transfer.  <a href="#a5e380852b8726f71e8558c86cba5bd1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a3570b708f9f51408e4bbf2f61cc8c881">cancelReadTransfer</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel current bulk/interrupt input transfer.  <a href="#a3570b708f9f51408e4bbf2f61cc8c881"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#ab8ddd4ebee603ac381e8da0383a61e36">waitForReadyRead</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until data is available on port.  <a href="#ab8ddd4ebee603ac381e8da0383a61e36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">qint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#abce257345c8af47494215cd7ee75f82d">read</a> (char *data, qint64 maxSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from port.  <a href="#abce257345c8af47494215cd7ee75f82d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a897234cc2c7561da323cb124f57bcc28">initMessageInTransfer</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a new interrupt input transfer for additional message input.  <a href="#a897234cc2c7561da323cb124f57bcc28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#afddcb02a1e2bd87609fd2b6305534560">cancelMessageInTransfer</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel current interrupt message input transfer.  <a href="#afddcb02a1e2bd87609fd2b6305534560"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QQueue&lt; <a class="el" href="classmdt_frame.html">mdtFrame</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a3ad4385983122fcaf6d2560b6bd43acf">messageInFramesPool</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the message IN frames pool.  <a href="#a3ad4385983122fcaf6d2560b6bd43acf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QQueue&lt; <a class="el" href="classmdt_frame.html">mdtFrame</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a3365431076a3197540cbc99278658bda">messageInFrames</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the message IN frames.  <a href="#a3365431076a3197540cbc99278658bda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a38200f806037e06988e73af246e8a494">addFrameToWrite</a> (<a class="el" href="classmdt_frame.html">mdtFrame</a> *frame)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a frame to write.  <a href="#a38200f806037e06988e73af246e8a494"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a3340dc3f53e857e39053988e4925fc97">initWriteTransfer</a> (const char *data, qint64 maxSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a new bulk/interrupt out transfer.  <a href="#a3340dc3f53e857e39053988e4925fc97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a7cbe1cd3649861aac5e6a14830f06cf9">cancelWriteTransfer</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel current bulk/interrupt input transfer.  <a href="#a7cbe1cd3649861aac5e6a14830f06cf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a3be875f6f10ae94fd3a94f925bb935e7">waitEventWriteReady</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until data can be written to port.  <a href="#a3be875f6f10ae94fd3a94f925bb935e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">qint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#ae777e33325ff2adef326dd7f81b00838">write</a> (const char *, qint64)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to port.  <a href="#ae777e33325ff2adef326dd7f81b00838"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#aa857e94b4167c53b26573042ee3af280">addError</a> (<a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set error.  <a href="#aa857e94b4167c53b26573042ee3af280"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QList&lt; <a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">error_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a81855cebd9b672a74d836955236c19bf">lastErrors</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lis of current errors.  <a href="#a81855cebd9b672a74d836955236c19bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#afe5b473e1df8b828c17f83a45a3902fb">cancelTransfers</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel pending transfers.  <a href="#afe5b473e1df8b828c17f83a45a3902fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#abb66e85fc1366112eeb0a6e86f6e7e32">handleUsbEvents</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call libusb handle_event() function.  <a href="#abb66e85fc1366112eeb0a6e86f6e7e32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">quint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a860e89069ba433e6174c032a28d0eae2">currentReadEndpointAddress</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current read endpoint address.  <a href="#a860e89069ba433e6174c032a28d0eae2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">quint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#ae2319ee6ff5a2f4399410175fbac6a44">currentWriteEndpointAddress</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current write endpoint address.  <a href="#ae2319ee6ff5a2f4399410175fbac6a44"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#a84ddd2d0bf77b4db60358846c7da4853">controlTransferCallback</a> (struct libusb_transfer *transfer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer callback for control endpoint.  <a href="#a84ddd2d0bf77b4db60358846c7da4853"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#ab4f1f0456c84f954604b192f6085c3f2">readTransferCallback</a> (struct libusb_transfer *transfer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer callback for read endpoint.  <a href="#ab4f1f0456c84f954604b192f6085c3f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#ae8932368e2777356695ab69f6ed08f41">messageInTransferCallback</a> (struct libusb_transfer *transfer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer callback for message in (additional interrupt) endpoint.  <a href="#ae8932368e2777356695ab69f6ed08f41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_usb_port.html#af910071a5a5c401cd20cee3519120cc2">writeTransferCallback</a> (struct libusb_transfer *transfer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer callback for write endpoint.  <a href="#af910071a5a5c401cd20cee3519120cc2"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>USB port I/O port class. </p>
<p>Built on top of libusb-1.x API</p>
<p>Note about the port name (set with <a class="el" href="classmdt_abstract_port.html#a0ca143d32fc677bac7c1cf0e04144932" title="Set the port name.">setPortName()</a> ):<br/>
 Because it can happen that multiple devices with same vendor ID and product ID can be attached to system, this class must provide a unique identifier when (re-)open the port. Because of this, the choosen format is: VID=0x1234:PID=0x1234:SID=0x1234:bInterfaceNumber=0. VID is the Vendor ID, PID the Product ID, SID the Serial ID (also called Serial Number) and bInterfaceNumber the interface number (some devices have mor than one interface, f.ex. sound cards, keboard/mouse receiver, ...). SID and bInterfaceNumber are optional. In this case, the first port with given vendor ID and device ID is open. In brief, following names are allowed:</p>
<ul>
<li>VID=0x1234:PID=0x5678 (Open the first port with given Vendor ID and Product ID. bInterfaceNumber is 0)</li>
<li>VID=0x1234:PID=0x5678:SID=ABC1234 (Open the first port with given Vendor ID, Product ID and Serial ID. bInterfaceNumber is 0)</li>
<li>VID=0x1234:PID=0x5678:bInterfaceNumber=1 (Open the first port with given Vendor ID and Product ID. bInterfaceNumber is 1)</li>
<li>VID=0x1234:PID=0x5678:SID=ABC1234:bInterfaceNumber=1 (Open the first port with given Vendor ID, Product ID and Serial ID. bInterfaceNumber is 1) The last example in the above list is the format returned by <a class="el" href="classmdt_usb_port_manager.html#a3a2370c3a2d0353a880bf9b777728c3b" title="Get a list of attached USB devices.">mdtUsbPortManager::scan()</a>.</li>
</ul>
<p>For read and write of data, the mdtAbstractPort's API is used, expected that <a class="el" href="classmdt_usb_port.html#ab8ddd4ebee603ac381e8da0383a61e36" title="Wait until data is available on port.">waitForReadyRead()</a> and <a class="el" href="classmdt_usb_port.html#a3be875f6f10ae94fd3a94f925bb935e7" title="Wait until data can be written to port.">waitEventWriteReady()</a> are not used.</p>
<p>The control transfer is a little bit different:</p>
<ul>
<li>If the main thread (f.ex. GUI thread) wants to send a request, it locks the mutex using <a class="el" href="classmdt_abstract_port.html#a6bf2ecdcf894da3929a22eb8793a9fe3" title="Lock the mutex.">lockMutex()</a>, then it takes a frame in pool with <a class="el" href="classmdt_usb_port.html#af146b08006ddbe18fb537ae1a75b622e" title="Get the control pool queue.">controlFramesPool()</a>. Finaly, query is submitted using <a class="el" href="classmdt_usb_port.html#a4fbcd0fcc179335c55c6d7ccc40a7c31" title="Add a control request.">addControlRequest()</a>, witch will submit the frame, and main thread unlocks the mutex with <a class="el" href="classmdt_abstract_port.html#a3523c72a06e4d950338f91e56c286e84" title="Unlock the mutex.">unlockMutex()</a>.</li>
<li>The thread periodically checks if a response is available using <a class="el" href="classmdt_usb_port.html#a304825c7d9173a3dcb5e26a412f1038b" title="Get the control responses queue.">controlResponseFrames()</a> queue's size, and emit controlResponseReaden() if a control response is available.</li>
</ul>
<p>If a additional (to read and write) interrupt IN endpoint exists, it is handled as message IN as follow:</p>
<ul>
<li>The thread periodically checks if a message IN is available using <a class="el" href="classmdt_usb_port.html#a3365431076a3197540cbc99278658bda" title="Get the message IN frames.">messageInFrames()</a> queue's size, and emit messageInReaden() if a message IN is available.</li>
<li>A new transfer is reinitialized by thread. </li>
</ul>

<p>Definition at line <a class="el" href="mdt_usb_port_8h_source.html#l00064">64</a> of file <a class="el" href="mdt_usb_port_8h_source.html">mdtUsbPort.h</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4fbcd0fcc179335c55c6d7ccc40a7c31"></a><!-- doxytag: member="mdtUsbPort::addControlRequest" ref="a4fbcd0fcc179335c55c6d7ccc40a7c31" args="(mdtFrameUsbControl *frame, bool setwIndexAsbInterfaceNumber=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtUsbPort::addControlRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmdt_frame_usb_control.html">mdtFrameUsbControl</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setwIndexAsbInterfaceNumber</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a control request. </p>
<p>Add a control frame to the queries queue. Frame will be sent as soon as possible.</p>
<p>The mutex must be locked before calling this method, and still locked inside.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>Control frame </td></tr>
    <tr><td class="paramname">setwIndexAsbInterfaceNumber</td><td>If true, wIndex will be set with current bInterfaceNumber </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>frame must be a valid pointer. </dd></dl>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00137">137</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa857e94b4167c53b26573042ee3af280"></a><!-- doxytag: member="mdtUsbPort::addError" ref="aa857e94b4167c53b26573042ee3af280" args="(mdtAbstractPort::error_t error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtUsbPort::addError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a>&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set error. </p>
<p>Used by transfer callbacks</p>
<p>Mutex is not handled by this method. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00923">923</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38200f806037e06988e73af246e8a494"></a><!-- doxytag: member="mdtUsbPort::addFrameToWrite" ref="a38200f806037e06988e73af246e8a494" args="(mdtFrame *frame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtUsbPort::addFrameToWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmdt_frame.html">mdtFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a frame to write. </p>
<p>Once the frame is added to the write queue, waiting thread will be woken up (if waiting) and will send the frame.</p>
<p>The mutex must be locked before calling this method, and still locked inside.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>frame must be a valid pointer. </dd></dl>

<p>Reimplemented from <a class="el" href="classmdt_abstract_port.html#a9a69eb2fc07d551ab37c011487fa319d">mdtAbstractPort</a>.</p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00726">726</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6566e654df8a1c3503941702593db3c5"></a><!-- doxytag: member="mdtUsbPort::cancelControlTransfer" ref="a6566e654df8a1c3503941702593db3c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> mdtUsbPort::cancelControlTransfer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel current control transfer. </p>
<p>Used by <a class="el" href="classmdt_usb_port_thread.html">mdtUsbPortThread</a>, should not be used else. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00308">308</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afddcb02a1e2bd87609fd2b6305534560"></a><!-- doxytag: member="mdtUsbPort::cancelMessageInTransfer" ref="afddcb02a1e2bd87609fd2b6305534560" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> mdtUsbPort::cancelMessageInTransfer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel current interrupt message input transfer. </p>
<p>Used by <a class="el" href="classmdt_usb_port_thread.html">mdtUsbPortThread</a>, should not be used else. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00677">677</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3570b708f9f51408e4bbf2f61cc8c881"></a><!-- doxytag: member="mdtUsbPort::cancelReadTransfer" ref="a3570b708f9f51408e4bbf2f61cc8c881" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> mdtUsbPort::cancelReadTransfer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel current bulk/interrupt input transfer. </p>
<p>Used by <a class="el" href="classmdt_usb_port_thread.html">mdtUsbPortThread</a>, should not be used else. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00486">486</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe5b473e1df8b828c17f83a45a3902fb"></a><!-- doxytag: member="mdtUsbPort::cancelTransfers" ref="afe5b473e1df8b828c17f83a45a3902fb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> mdtUsbPort::cancelTransfers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel pending transfers. </p>
<p>Will cancel all pending transfers.</p>
<p>Used by <a class="el" href="classmdt_usb_port_thread.html">mdtUsbPortThread</a>, should not be used else. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00938">938</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7cbe1cd3649861aac5e6a14830f06cf9"></a><!-- doxytag: member="mdtUsbPort::cancelWriteTransfer" ref="a7cbe1cd3649861aac5e6a14830f06cf9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> mdtUsbPort::cancelWriteTransfer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancel current bulk/interrupt input transfer. </p>
<p>Used by <a class="el" href="classmdt_usb_port_thread.html">mdtUsbPortThread</a>, should not be used else. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00856">856</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af146b08006ddbe18fb537ae1a75b622e"></a><!-- doxytag: member="mdtUsbPort::controlFramesPool" ref="af146b08006ddbe18fb537ae1a75b622e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QQueue&lt; <a class="el" href="classmdt_frame_usb_control.html">mdtFrameUsbControl</a> * &gt; &amp; mdtUsbPort::controlFramesPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the control pool queue. </p>
<p>This queue contains the pool of control frames.</p>
<p>Mutex is not handled by this method. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00298">298</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afbb20c403e7a5885d5e4221bab9f304e"></a><!-- doxytag: member="mdtUsbPort::controlQueryFrames" ref="afbb20c403e7a5885d5e4221bab9f304e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QQueue&lt; <a class="el" href="classmdt_frame_usb_control.html">mdtFrameUsbControl</a> * &gt; &amp; mdtUsbPort::controlQueryFrames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the control query queue. </p>
<p>This queue contains control query frames (control requests).</p>
<p>Mutex is not handled by this method. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00303">303</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a304825c7d9173a3dcb5e26a412f1038b"></a><!-- doxytag: member="mdtUsbPort::controlResponseFrames" ref="a304825c7d9173a3dcb5e26a412f1038b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QQueue&lt; <a class="el" href="classmdt_frame_usb_control.html">mdtFrameUsbControl</a> * &gt; &amp; mdtUsbPort::controlResponseFrames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the control responses queue. </p>
<p>This queue contains the response frames returned from device.</p>
<p>Mutex is not handled by this method. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00347">347</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a84ddd2d0bf77b4db60358846c7da4853"></a><!-- doxytag: member="mdtUsbPort::controlTransferCallback" ref="a84ddd2d0bf77b4db60358846c7da4853" args="(struct libusb_transfer *transfer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtUsbPort::controlTransferCallback </td>
          <td>(</td>
          <td class="paramtype">struct libusb_transfer *&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer callback for control endpoint. </p>
<p>Check completion and error flags and add control frame in responses queue if ok, or in pool else. On error, <a class="el" href="classmdt_usb_port.html#aa857e94b4167c53b26573042ee3af280" title="Set error.">addError()</a> is called, so thread can notify it.</p>
<p>Once done, <a class="el" href="classmdt_usb_port.html#a274b6fd10bd84027bb66773ed805de2a" title="Submit a control query.">submitControlQuery()</a> is called.</p>
<p>This method is called from libusb and should not be used directly.</p>
<p>Mutex is locked during process and unlocked befor return.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>transfer must be valid </dd>
<dd>
transfer-&gt;user_data must be valid </dd></dl>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00197">197</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a860e89069ba433e6174c032a28d0eae2"></a><!-- doxytag: member="mdtUsbPort::currentReadEndpointAddress" ref="a860e89069ba433e6174c032a28d0eae2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">quint8 mdtUsbPort::currentReadEndpointAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get current read endpoint address. </p>
<p>Note: mutex is not handled by this method </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00996">996</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2319ee6ff5a2f4399410175fbac6a44"></a><!-- doxytag: member="mdtUsbPort::currentWriteEndpointAddress" ref="ae2319ee6ff5a2f4399410175fbac6a44" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">quint8 mdtUsbPort::currentWriteEndpointAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get current write endpoint address. </p>
<p>Note: mutex is not handled by this method </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l01001">1001</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb66e85fc1366112eeb0a6e86f6e7e32"></a><!-- doxytag: member="mdtUsbPort::handleUsbEvents" ref="abb66e85fc1366112eeb0a6e86f6e7e32" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> mdtUsbPort::handleUsbEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call libusb handle_event() function. </p>
<p>Notes: must be called only by I/O thread (typically <a class="el" href="classmdt_usb_port_thread.html">mdtUsbPortThread</a>). This method unlocks the mutex during wait (must be locked by call, is locked again before return)</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NoError or <a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e" title="Error.">mdtAbstractPort::error_t</a> error (Note: timeout is ignored here) </dd></dl>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00962">962</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a897234cc2c7561da323cb124f57bcc28"></a><!-- doxytag: member="mdtUsbPort::initMessageInTransfer" ref="a897234cc2c7561da323cb124f57bcc28" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> mdtUsbPort::initMessageInTransfer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request a new interrupt input transfer for additional message input. </p>
<p>Will fill and init a new interrupt transfer and submit it to libusb.</p>
<p>If a transfer is pending, this method simply returns.</p>
<p>This method is called by USB port thread and should not be used else.</p>
<p>Mutex is not handled by this method.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NoError or a error from <a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e" title="Error.">mdtAbstractPort::error_t</a> </dd></dl>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00560">560</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e380852b8726f71e8558c86cba5bd1f"></a><!-- doxytag: member="mdtUsbPort::initReadTransfer" ref="a5e380852b8726f71e8558c86cba5bd1f" args="(qint64 maxSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> mdtUsbPort::initReadTransfer </td>
          <td>(</td>
          <td class="paramtype">qint64&#160;</td>
          <td class="paramname"><em>maxSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Submit a read transfer. </p>
<p>If a transfer is pending, this method simply returns.</p>
<p>This method is called by USB port thread and should not be used else.</p>
<p>Mutex is not handled by this method.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NoError or a error from <a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e" title="Error.">mdtAbstractPort::error_t</a> </dd></dl>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00373">373</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3340dc3f53e857e39053988e4925fc97"></a><!-- doxytag: member="mdtUsbPort::initWriteTransfer" ref="a3340dc3f53e857e39053988e4925fc97" args="(const char *data, qint64 maxSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> mdtUsbPort::initWriteTransfer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qint64&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request a new bulk/interrupt out transfer. </p>
<p>Will fill and init a new bulk/interrupt (depending setup) transfer and submit it to libusb.</p>
<p>If a transfer is pending, this method simply returns.</p>
<p>This method is called by USB port thread and should not be used else.</p>
<p>Mutex is not handled by this method.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NoError or a error from <a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e" title="Error.">mdtAbstractPort::error_t</a> </dd></dl>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00744">744</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a81855cebd9b672a74d836955236c19bf"></a><!-- doxytag: member="mdtUsbPort::lastErrors" ref="a81855cebd9b672a74d836955236c19bf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; <a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> &gt; mdtUsbPort::lastErrors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the lis of current errors. </p>
<p>Will clear internal list (a second call will return a empty list)</p>
<p>Used by <a class="el" href="classmdt_usb_port_thread.html">mdtUsbPortThread</a>, should not be used else. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00928">928</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3365431076a3197540cbc99278658bda"></a><!-- doxytag: member="mdtUsbPort::messageInFrames" ref="a3365431076a3197540cbc99278658bda" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QQueue&lt; <a class="el" href="classmdt_frame.html">mdtFrame</a> * &gt; &amp; mdtUsbPort::messageInFrames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the message IN frames. </p>
<p>This queue contains the message IN frames.</p>
<p>Mutex is not handled by this method. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00721">721</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ad4385983122fcaf6d2560b6bd43acf"></a><!-- doxytag: member="mdtUsbPort::messageInFramesPool" ref="a3ad4385983122fcaf6d2560b6bd43acf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QQueue&lt; <a class="el" href="classmdt_frame.html">mdtFrame</a> * &gt; &amp; mdtUsbPort::messageInFramesPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the message IN frames pool. </p>
<p>This queue contains the pool of message IN frames.</p>
<p>Mutex is not handled by this method. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00716">716</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae8932368e2777356695ab69f6ed08f41"></a><!-- doxytag: member="mdtUsbPort::messageInTransferCallback" ref="ae8932368e2777356695ab69f6ed08f41" args="(struct libusb_transfer *transfer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtUsbPort::messageInTransferCallback </td>
          <td>(</td>
          <td class="paramtype">struct libusb_transfer *&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer callback for message in (additional interrupt) endpoint. </p>
<p>Check completion and error flags. On error, <a class="el" href="classmdt_usb_port.html#aa857e94b4167c53b26573042ee3af280" title="Set error.">addError()</a> is called, so thread can notify it.</p>
<p>This method is called from libusb and should not be used directly.</p>
<p>Mutex is not handled by this method.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>transfer must be valid </dd>
<dd>
transfer-&gt;user_data must be valid </dd></dl>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00592">592</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abce257345c8af47494215cd7ee75f82d"></a><!-- doxytag: member="mdtUsbPort::read" ref="abce257345c8af47494215cd7ee75f82d" args="(char *data, qint64 maxSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qint64 mdtUsbPort::read </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qint64&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read data from port. </p>
<p>This method is called from <a class="el" href="classmdt_usb_port_thread.html">mdtUsbPortThread</a> , and should not be used directly.</p>
<p>Mutex is not handled by this method.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Amount of readen data (can be 0 if transfer is pending or no more data are available), <a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e" title="Error.">mdtAbstractPort::error_t</a> code on error. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>data must be valid </dd></dl>

<p>Implements <a class="el" href="classmdt_abstract_port.html#a9d9c45220d5328c9856a2445557fe970">mdtAbstractPort</a>.</p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00531">531</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af546a031ed8621fee1d5e9498cbcd174"></a><!-- doxytag: member="mdtUsbPort::readBufferSize" ref="af546a031ed8621fee1d5e9498cbcd174" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mdtUsbPort::readBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get read buffer size. </p>
<p>This is the same as wMaxPacketSize of read endpoint.</p>
<p>This method is used by USB thread, and should not be used else.</p>
<p>Mutex is not handled by this method. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00555">555</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4f1f0456c84f954604b192f6085c3f2"></a><!-- doxytag: member="mdtUsbPort::readTransferCallback" ref="ab4f1f0456c84f954604b192f6085c3f2" args="(struct libusb_transfer *transfer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtUsbPort::readTransferCallback </td>
          <td>(</td>
          <td class="paramtype">struct libusb_transfer *&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer callback for read endpoint. </p>
<p>Check completion and error flags. On error, <a class="el" href="classmdt_usb_port.html#aa857e94b4167c53b26573042ee3af280" title="Set error.">addError()</a> is called, so thread can notify it.</p>
<p>This method is called from libusb and should not be used directly.</p>
<p>Mutex is not handled by this method.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>transfer must be valid </dd>
<dd>
transfer-&gt;user_data must be valid </dd></dl>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00425">425</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3c0685d67fe608abe24c140c2858779c"></a><!-- doxytag: member="mdtUsbPort::readUntilShortPacketReceivedRequestPending" ref="a3c0685d67fe608abe24c140c2858779c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mdtUsbPort::readUntilShortPacketReceivedRequestPending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a request to read until a short packet is received is pending. </p>
<p>Flag will be cleared after a call of this method.</p>
<p>This method is used by USB thread, and should not be used else.</p>
<p>Mutex is not handled by this method. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00364">364</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2399348faf1abc20130eab20cfc36ee"></a><!-- doxytag: member="mdtUsbPort::reconnect" ref="af2399348faf1abc20130eab20cfc36ee" args="(int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> mdtUsbPort::reconnect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reconnect device. </p>
<p>If one of the method returns a Disconnected error, the thread will call this method to try to reconnect.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Timeout [ms] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NoError if connection could be done. Disconnected if connection could not be done, in wich case the thread will retry (until max retry). A UnhandledError can be returned. </dd></dl>

<p>Reimplemented from <a class="el" href="classmdt_abstract_port.html#aec74b2db1a629d98a95d8f042ea96653">mdtAbstractPort</a>.</p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00086">86</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a719fc7b43461a3e2d9a4926d3e3961c2"></a><!-- doxytag: member="mdtUsbPort::requestReadUntilShortPacketReceived" ref="a719fc7b43461a3e2d9a4926d3e3961c2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtUsbPort::requestReadUntilShortPacketReceived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request to read until a short packet is received. </p>
<p>The mutex must be locked before calling this method, and still locked inside. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00352">352</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44ed5024a81a573b5196b8f64c42cd6a"></a><!-- doxytag: member="mdtUsbPort::setReadTimeout" ref="a44ed5024a81a573b5196b8f64c42cd6a" args="(int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtUsbPort::setReadTimeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the read data timeout. </p>
<p>The mutex is not handled by this method. </p>

<p>Implements <a class="el" href="classmdt_abstract_port.html#a6589b04467e0073d18ba872201bdcd84">mdtAbstractPort</a>.</p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00111">111</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a592af88bd7e7f45dd80df0ecab375ace"></a><!-- doxytag: member="mdtUsbPort::setWriteTimeout" ref="a592af88bd7e7f45dd80df0ecab375ace" args="(int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtUsbPort::setWriteTimeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the write data timeout. </p>
<p>The mutex is not handled by this method. </p>

<p>Implements <a class="el" href="classmdt_abstract_port.html#a12eb422d52ebb09a650f8497b258c2e7">mdtAbstractPort</a>.</p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00124">124</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a274b6fd10bd84027bb66773ed805de2a"></a><!-- doxytag: member="mdtUsbPort::submitControlQuery" ref="a274b6fd10bd84027bb66773ed805de2a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtUsbPort::submitControlQuery </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Submit a control query. </p>
<p>If frames are available in queries queue and no control transfer is pending, a transfer will be submitted.</p>
<p>This method is called by <a class="el" href="classmdt_usb_port.html#a4fbcd0fcc179335c55c6d7ccc40a7c31" title="Add a control request.">addControlRequest()</a> and <a class="el" href="classmdt_usb_port.html#a84ddd2d0bf77b4db60358846c7da4853" title="Transfer callback for control endpoint.">controlTransferCallback()</a> and should not be used directly.</p>
<p>The mutex must be locked before calling this method, and still locked inside. </p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00148">148</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3be875f6f10ae94fd3a94f925bb935e7"></a><!-- doxytag: member="mdtUsbPort::waitEventWriteReady" ref="a3be875f6f10ae94fd3a94f925bb935e7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> mdtUsbPort::waitEventWriteReady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait until data can be written to port. </p>
<p>This method is not implemented here and will allways return a UnhandledError. </p>

<p>Implements <a class="el" href="classmdt_abstract_port.html#a35e4686f50e2c53c7e3618cf2c485d92">mdtAbstractPort</a>.</p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00897">897</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab8ddd4ebee603ac381e8da0383a61e36"></a><!-- doxytag: member="mdtUsbPort::waitForReadyRead" ref="ab8ddd4ebee603ac381e8da0383a61e36" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmdt_abstract_port.html#ad4121bb930c95887e77f8bafa065a85e">mdtAbstractPort::error_t</a> mdtUsbPort::waitForReadyRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait until data is available on port. </p>
<p>Not implemented, will allways return a UnhandledError </p>

<p>Implements <a class="el" href="classmdt_abstract_port.html#aeda364cb191da1038a22dd1fc06a1d49">mdtAbstractPort</a>.</p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00526">526</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae777e33325ff2adef326dd7f81b00838"></a><!-- doxytag: member="mdtUsbPort::write" ref="ae777e33325ff2adef326dd7f81b00838" args="(const char *, qint64)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qint64 mdtUsbPort::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qint64&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write data to port. </p>
<p>This method is called from <a class="el" href="classmdt_port_write_thread.html">mdtPortWriteThread</a> , and should not be used directly.</p>
<p>Mutex is not handled by this method. </p>

<p>Implements <a class="el" href="classmdt_abstract_port.html#a64d4802975a76474b9196c91f57a6d90">mdtAbstractPort</a>.</p>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00902">902</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af910071a5a5c401cd20cee3519120cc2"></a><!-- doxytag: member="mdtUsbPort::writeTransferCallback" ref="af910071a5a5c401cd20cee3519120cc2" args="(struct libusb_transfer *transfer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtUsbPort::writeTransferCallback </td>
          <td>(</td>
          <td class="paramtype">struct libusb_transfer *&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer callback for write endpoint. </p>
<p>Check completion and error flags. On error, <a class="el" href="classmdt_usb_port.html#aa857e94b4167c53b26573042ee3af280" title="Set error.">addError()</a> is called, so thread can notify it.</p>
<p>This method is called from libusb and should not be used directly.</p>
<p>Mutex is not handled by this method.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>transfer must be valid </dd>
<dd>
transfer-&gt;user_data must be valid </dd></dl>

<p>Definition at line <a class="el" href="mdt_usb_port_8cpp_source.html#l00798">798</a> of file <a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/mdtport/<a class="el" href="mdt_usb_port_8h_source.html">mdtUsbPort.h</a></li>
<li>src/mdtport/<a class="el" href="mdt_usb_port_8cpp_source.html">mdtUsbPort.cpp</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sun Apr 21 2013 17:41:43 for Multi diag tools by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
