<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Multi diag tools: mdtModbusTcpPortManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Multi diag tools</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-slots">Public Slots</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">mdtModbusTcpPortManager Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="mdtModbusTcpPortManager" --><!-- doxytag: inherits="mdtPortManager" -->
<p>MODBUS/TCP port manager.  
 <a href="classmdt_modbus_tcp_port_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mdt_modbus_tcp_port_manager_8h_source.html">mdtModbusTcpPortManager.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mdtModbusTcpPortManager:</div>
<div class="dyncontent">
<div class="center"><img src="classmdt_modbus_tcp_port_manager__inherit__graph.png" border="0" usemap="#mdt_modbus_tcp_port_manager_inherit__map" alt="Inheritance graph"/></div>
<map name="mdt_modbus_tcp_port_manager_inherit__map" id="mdt_modbus_tcp_port_manager_inherit__map">
<area shape="rect" id="node2" href="classmdt_port_manager.html" title="Port manager base class." alt="" coords="40,5,157,35"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mdtModbusTcpPortManager:</div>
<div class="dyncontent">
<div class="center"><img src="classmdt_modbus_tcp_port_manager__coll__graph.png" border="0" usemap="#mdt_modbus_tcp_port_manager_coll__map" alt="Collaboration graph"/></div>
<map name="mdt_modbus_tcp_port_manager_coll__map" id="mdt_modbus_tcp_port_manager_coll__map">
<area shape="rect" id="node2" href="classmdt_port_manager.html" title="Port manager base class." alt="" coords="81,309,199,339"/><area shape="rect" id="node4" href="classmdt_port_thread.html" title="mdtPortThread" alt="" coords="87,197,193,227"/><area shape="rect" id="node6" href="classmdt_abstract_port.html" title="Base class for port I/O." alt="" coords="5,101,123,131"/><area shape="rect" id="node8" href="classmdt_port_config.html" title="mdtPortConfig" alt="" coords="11,5,117,35"/><area shape="rect" id="node10" href="classmdt_port_info.html" title="Contains informations about a port." alt="" coords="217,197,308,227"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classmdt_modbus_tcp_port_manager-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-slots"></a>
Public Slots</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6cc6b2a57c1c126be0a9c3142a6f0e5"></a><!-- doxytag: member="mdtModbusTcpPortManager::abortScan" ref="ab6cc6b2a57c1c126be0a9c3142a6f0e5" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_modbus_tcp_port_manager.html#ab6cc6b2a57c1c126be0a9c3142a6f0e5">abortScan</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the scan process. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_modbus_tcp_port_manager.html#ad941ea607f00db54aa6deb2866a539e9">fromThreadNewFrameReaden</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the thread whenn a complete frame was readen.  <a href="#ad941ea607f00db54aa6deb2866a539e9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_modbus_tcp_port_manager.html#a2f65f779bbad19d9d3f85ef35220ffb8">mdtModbusTcpPortManager</a> (QObject *parent=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a MODBUS/TCP port manager.  <a href="#a2f65f779bbad19d9d3f85ef35220ffb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_modbus_tcp_port_manager.html#aabe51a50a53c6b23884cc4862730b731">~mdtModbusTcpPortManager</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#aabe51a50a53c6b23884cc4862730b731"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QList&lt; <a class="el" href="classmdt_port_info.html">mdtPortInfo</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_modbus_tcp_port_manager.html#a216ee2495440be4eefb2faf9da3c9e47">scan</a> (const QStringList &amp;hosts, int timeout=500)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan for available hosts with a MODBUS/TCP compatible device attached.  <a href="#a216ee2495440be4eefb2faf9da3c9e47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QList&lt; <a class="el" href="classmdt_port_info.html">mdtPortInfo</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_modbus_tcp_port_manager.html#a7cfd5dcde142cd262925974b43e58bff">scan</a> (const QNetworkInterface &amp;iface, quint16 port=502, int timeout=500)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan for available hosts with a MODBUS/TCP compatible device attached.  <a href="#a7cfd5dcde142cd262925974b43e58bff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QList&lt; <a class="el" href="classmdt_port_info.html">mdtPortInfo</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_modbus_tcp_port_manager.html#a2f1128e1f564a785e35b2e9b16bc990f">scan</a> (const QList&lt; QNetworkInterface &gt; &amp;ifaces, quint16 port=502, int timeout=500, bool ignoreLoopback=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan for available hosts with a MODBUS/TCP compatible device attached.  <a href="#a2f1128e1f564a785e35b2e9b16bc990f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_modbus_tcp_port_manager.html#ab04f69b660487a7c59d309df7a8f5baa">tryToConnect</a> (const QString &amp;hostName, quint16 port, int timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to connect to a host.  <a href="#ab04f69b660487a7c59d309df7a8f5baa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_modbus_tcp_port_manager.html#a3a1f5a54c93fa90ba83dea8785407da3">saveScanResult</a> (const QList&lt; <a class="el" href="classmdt_port_info.html">mdtPortInfo</a> * &gt; scanResult)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a scan result into the known hosts file.  <a href="#a3a1f5a54c93fa90ba83dea8785407da3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QStringList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_modbus_tcp_port_manager.html#ab4d0a994973af6008faf489ca9ddb03d">readScanResult</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read scan result stored in cache file.  <a href="#ab4d0a994973af6008faf489ca9ddb03d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_modbus_tcp_port_manager.html#a4f52a477c264f809984e25abbc856db8">getHardwareNodeAddress</a> (int bitsCount, int startFrom=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hardware node ID.  <a href="#a4f52a477c264f809984e25abbc856db8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_modbus_tcp_port_manager.html#ab5e780409492b5f56326a870bc4262ec">getRegisterValues</a> (int address, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method for register service.  <a href="#ab5e780409492b5f56326a870bc4262ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QList&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_modbus_tcp_port_manager.html#a99a13b5250a8523aa63869991581e56a">registerValues</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method for register service.  <a href="#a99a13b5250a8523aa63869991581e56a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_modbus_tcp_port_manager.html#afdee5f0444f7f6b258a23733cc134684">writeData</a> (<a class="el" href="classmdt_port_transaction.html">mdtPortTransaction</a> *transaction)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write PDU by copy.  <a href="#afdee5f0444f7f6b258a23733cc134684"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmdt_modbus_tcp_port_manager.html#a5e687204475d788170b9b61a1f06eecf">writeData</a> (const QByteArray &amp;pdu, bool queryReplyMode=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write PDU by copy.  <a href="#a5e687204475d788170b9b61a1f06eecf"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>MODBUS/TCP port manager. </p>
<p>This is the simplest way to use the MODBUS/TCP API.</p>
<p>All needed object are created by constructor. To alter configuration, use <a class="el" href="classmdt_port_manager.html#a9cf3ea2da38f81682695b37448712ffd" title="Get the port&#39;s config object.">config()</a>. To access the tcp port object, use port().</p>
<p>Use <a class="el" href="classmdt_port_manager.html#af1fb103ffafc227337a59c7e82f44fbc" title="Start threads.">start()</a> to begin read/write and stop to end.</p>
<p>References:</p>
<ul>
<li>MODBUS Application Protocol Specification V1.1b</li>
<li><a href="http://www.Modbus-IDA.org">http://www.Modbus-IDA.org</a> </li>
</ul>

<p>Definition at line <a class="el" href="mdt_modbus_tcp_port_manager_8h_source.html#l00046">46</a> of file <a class="el" href="mdt_modbus_tcp_port_manager_8h_source.html">mdtModbusTcpPortManager.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2f65f779bbad19d9d3f85ef35220ffb8"></a><!-- doxytag: member="mdtModbusTcpPortManager::mdtModbusTcpPortManager" ref="a2f65f779bbad19d9d3f85ef35220ffb8" args="(QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mdtModbusTcpPortManager::mdtModbusTcpPortManager </td>
          <td>(</td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a MODBUS/TCP port manager. </p>
<p>Creates a <a class="el" href="classmdt_port_config.html">mdtPortConfig</a>, a <a class="el" href="classmdt_tcp_socket.html">mdtTcpSocket</a>, and thread object. </p>

<p>Definition at line <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html#l00040">40</a> of file <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html">mdtModbusTcpPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aabe51a50a53c6b23884cc4862730b731"></a><!-- doxytag: member="mdtModbusTcpPortManager::~mdtModbusTcpPortManager" ref="aabe51a50a53c6b23884cc4862730b731" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mdtModbusTcpPortManager::~mdtModbusTcpPortManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>Stop the manager (if running), and close the port (if open). All internal objects (port, config and threads) are deleted here. </p>

<p>Definition at line <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html#l00065">65</a> of file <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html">mdtModbusTcpPortManager.cpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad941ea607f00db54aa6deb2866a539e9"></a><!-- doxytag: member="mdtModbusTcpPortManager::fromThreadNewFrameReaden" ref="ad941ea607f00db54aa6deb2866a539e9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mdtModbusTcpPortManager::fromThreadNewFrameReaden </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called by the thread whenn a complete frame was readen. </p>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>Error on incomplete frame </dd></dl>
</p>

<p>Reimplemented from <a class="el" href="classmdt_port_manager.html#a4fcc8f0699b655156e661bb3de6056cc">mdtPortManager</a>.</p>

<p>Definition at line <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html#l00473">473</a> of file <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html">mdtModbusTcpPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f52a477c264f809984e25abbc856db8"></a><!-- doxytag: member="mdtModbusTcpPortManager::getHardwareNodeAddress" ref="a4f52a477c264f809984e25abbc856db8" args="(int bitsCount, int startFrom=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mdtModbusTcpPortManager::getHardwareNodeAddress </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bitsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startFrom</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the hardware node ID. </p>
<p>The concept of node ID is specific to MultiDiagTools. It was introduced to solve the problem of network IP configurations.</p>
<p>Take a example: We have a application that needs several MODBUS/TCP nodes. Each node has several I/O's. Say that digital output 1 of node 1 is used to activate a lamp and output 1 of node 2 must activate heating register. We could choose to have static IP addresses in the network and configure the application to activate the correct output of correct node. But, this can be a problem when a node must be replaced. More cumbersome case is a modular application that could manage several nodes, and change his I/Os layout in a dynamic way regarding a context.</p>
<p>A easy way to solve such problems is to have a DHCP server in the network and all nodes configured as DHCP clients (static addressing can still be a solution, but we not depend on it). Then, for a given application, we can fix a number of digital inputs to play the role of node address. Then, instead of using IP address as identification (as in the example), we use node address.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bitsCount</td><td>Number of digital inputs that represents the hardware node address. </td></tr>
    <tr><td class="paramname">startFrom</td><td>First digital input that represents the hardware node address (is the LSB). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Node address or value &lt; 0 corresponding on <a class="el" href="classmdt_abstract_port.html" title="Base class for port I/O.">mdtAbstractPort</a> error_t. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Port manager must be connected and thread running before calling this method. </dd>
<dd>
bitsCount must be &gt; 0 </dd>
<dd>
startFrom must be &gt;= 0 </dd></dl>

<p>Definition at line <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html#l00312">312</a> of file <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html">mdtModbusTcpPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab5e780409492b5f56326a870bc4262ec"></a><!-- doxytag: member="mdtModbusTcpPortManager::getRegisterValues" ref="ab5e780409492b5f56326a870bc4262ec" args="(int address, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mdtModbusTcpPortManager::getRegisterValues </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper method for register service. </p>
<p>Usefull to get resgister values (f.ex. configurations regsisters, ...).</p>
<p>Note: to get analog I/O values, the <a class="el" href="classmdt_device.html" title="Base class for a device connected to a port.">mdtDevice</a> API should be used.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on success. Values are the available with <a class="el" href="classmdt_modbus_tcp_port_manager.html#a99a13b5250a8523aa63869991581e56a" title="Helper method for register service.">registerValues()</a> </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>address and n must be &gt; 0 </dd></dl>

<p>Definition at line <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html#l00364">364</a> of file <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html">mdtModbusTcpPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4d0a994973af6008faf489ca9ddb03d"></a><!-- doxytag: member="mdtModbusTcpPortManager::readScanResult" ref="ab4d0a994973af6008faf489ca9ddb03d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QStringList mdtModbusTcpPortManager::readScanResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read scan result stored in cache file. </p>
<p>The file stored by <a class="el" href="classmdt_modbus_tcp_port_manager.html#a3a1f5a54c93fa90ba83dea8785407da3" title="Save a scan result into the known hosts file.">saveScanResult()</a> is readen (if exists) and content returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>List of lines or empty list if file not exists or on error. </dd></dl>

<p>Definition at line <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html#l00291">291</a> of file <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html">mdtModbusTcpPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99a13b5250a8523aa63869991581e56a"></a><!-- doxytag: member="mdtModbusTcpPortManager::registerValues" ref="a99a13b5250a8523aa63869991581e56a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const QList&lt; int &gt; &amp; mdtModbusTcpPortManager::registerValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper method for register service. </p>
<p>Return result set by <a class="el" href="classmdt_modbus_tcp_port_manager.html#ab5e780409492b5f56326a870bc4262ec" title="Helper method for register service.">getRegisterValues()</a>. Note that values are keeped until next call of <a class="el" href="classmdt_modbus_tcp_port_manager.html#ab5e780409492b5f56326a870bc4262ec" title="Helper method for register service.">getRegisterValues()</a>. </p>

<p>Definition at line <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html#l00413">413</a> of file <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html">mdtModbusTcpPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3a1f5a54c93fa90ba83dea8785407da3"></a><!-- doxytag: member="mdtModbusTcpPortManager::saveScanResult" ref="a3a1f5a54c93fa90ba83dea8785407da3" args="(const QList&lt; mdtPortInfo * &gt; scanResult)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mdtModbusTcpPortManager::saveScanResult </td>
          <td>(</td>
          <td class="paramtype">const QList&lt; <a class="el" href="classmdt_port_info.html">mdtPortInfo</a> * &gt;&#160;</td>
          <td class="paramname"><em>scanResult</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a scan result into the known hosts file. </p>
<p>The file will be written to the $HOME/.mdt/cache directory, and contains lines with format host:port.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scanResult</td><td>List of port informations returned by a <a class="el" href="classmdt_port_manager.html#ad56afb411ab5468005fca04767557ece" title="Scan for available ports.">scan()</a> method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on successfull write. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Manager must no running </dd></dl>

<p><p>Q_ASSERT(!isRunning()); </p>
</p>

<p>Definition at line <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html#l00257">257</a> of file <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html">mdtModbusTcpPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a216ee2495440be4eefb2faf9da3c9e47"></a><!-- doxytag: member="mdtModbusTcpPortManager::scan" ref="a216ee2495440be4eefb2faf9da3c9e47" args="(const QStringList &amp;hosts, int timeout=500)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; <a class="el" href="classmdt_port_info.html">mdtPortInfo</a> * &gt; mdtModbusTcpPortManager::scan </td>
          <td>(</td>
          <td class="paramtype">const QStringList &amp;&#160;</td>
          <td class="paramname"><em>hosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>500</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scan for available hosts with a MODBUS/TCP compatible device attached. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hosts</td><td>A list of hosts to scan. Each host must be set with format hostname:port, or ip:port. Note that MODBUS/TCP default port is 502. </td></tr>
    <tr><td class="paramname">timeout</td><td>Maximum wait time [ms]. Must be a multiple of 50 [ms]</td></tr>
  </table>
  </dd>
</dl>
<p>Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Manager must no running </dd></dl>

<p>Definition at line <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html#l00073">73</a> of file <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html">mdtModbusTcpPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7cfd5dcde142cd262925974b43e58bff"></a><!-- doxytag: member="mdtModbusTcpPortManager::scan" ref="a7cfd5dcde142cd262925974b43e58bff" args="(const QNetworkInterface &amp;iface, quint16 port=502, int timeout=500)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; <a class="el" href="classmdt_port_info.html">mdtPortInfo</a> * &gt; mdtModbusTcpPortManager::scan </td>
          <td>(</td>
          <td class="paramtype">const QNetworkInterface &amp;&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">quint16&#160;</td>
          <td class="paramname"><em>port</em> = <code>502</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>500</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scan for available hosts with a MODBUS/TCP compatible device attached. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">iface</td><td>Scan will be done for all IP addresses available for given intarface. Note that only IPv4 is implemented. </td></tr>
    <tr><td class="paramname">port</td><td>Port. Note that MODBUS/TCP default port is 502. </td></tr>
    <tr><td class="paramname">timeout</td><td>Maximum wait time [ms]. Must be a multiple of 50 [ms]</td></tr>
  </table>
  </dd>
</dl>
<p>Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Manager must no running </dd></dl>

<p><p>portInfo-&gt;setDisplayText(currentIp.toString() + ":" + QString::number(port));</p>
<p>qDebug() &lt;&lt; "mdtModbusTcpPortManager::scan(): add port: " &lt;&lt; portInfo-&gt;<a class="el" href="classmdt_port_manager.html#af4fcab6aaad98d74aeabfc972da1d406" title="Get current port name.">portName()</a>; </p>
</p>

<p>Definition at line <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html#l00119">119</a> of file <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html">mdtModbusTcpPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2f1128e1f564a785e35b2e9b16bc990f"></a><!-- doxytag: member="mdtModbusTcpPortManager::scan" ref="a2f1128e1f564a785e35b2e9b16bc990f" args="(const QList&lt; QNetworkInterface &gt; &amp;ifaces, quint16 port=502, int timeout=500, bool ignoreLoopback=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; <a class="el" href="classmdt_port_info.html">mdtPortInfo</a> * &gt; mdtModbusTcpPortManager::scan </td>
          <td>(</td>
          <td class="paramtype">const QList&lt; QNetworkInterface &gt; &amp;&#160;</td>
          <td class="paramname"><em>ifaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">quint16&#160;</td>
          <td class="paramname"><em>port</em> = <code>502</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>500</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreLoopback</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scan for available hosts with a MODBUS/TCP compatible device attached. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ifaces</td><td>Scan will be done for all IP addresses available for all given intarfaces. Note that only IPv4 is implemented. </td></tr>
    <tr><td class="paramname">port</td><td>Port. Note that MODBUS/TCP default port is 502. </td></tr>
    <tr><td class="paramname">timeout</td><td>Maximum wait time [ms]. Must be a multiple of 50 [ms] </td></tr>
    <tr><td class="paramname">ignoreLoopback</td><td>If true, loopback interface will be ignored.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Manager must no running </dd></dl>

<p>Definition at line <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html#l00194">194</a> of file <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html">mdtModbusTcpPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab04f69b660487a7c59d309df7a8f5baa"></a><!-- doxytag: member="mdtModbusTcpPortManager::tryToConnect" ref="ab04f69b660487a7c59d309df7a8f5baa" args="(const QString &amp;hostName, quint16 port, int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mdtModbusTcpPortManager::tryToConnect </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>hostName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">quint16&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to connect to a host. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hostName</td><td>Host name or a IP address </td></tr>
    <tr><td class="paramname">port</td><td>Port. Note that MODBUS/TCP default port is 502. </td></tr>
    <tr><td class="paramname">timeout</td><td>Maximum wait time [ms]. Must be a multiple of 50 [ms] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True on successfull connection. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Manager must no running </dd></dl>

<p>Definition at line <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html#l00219">219</a> of file <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html">mdtModbusTcpPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afdee5f0444f7f6b258a23733cc134684"></a><!-- doxytag: member="mdtModbusTcpPortManager::writeData" ref="afdee5f0444f7f6b258a23733cc134684" args="(mdtPortTransaction *transaction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mdtModbusTcpPortManager::writeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmdt_port_transaction.html">mdtPortTransaction</a> *&#160;</td>
          <td class="paramname"><em>transaction</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write PDU by copy. </p>
<p>Data will be encoded regarding MODBUS/TCP standard and passed to the mdtTcpSocket's write queue by copy. This method returns immediatly after enqueue, and don't wait until data was written.</p>
<p>Internally, the transaction ID is incremented at each request and returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pdu</td><td>MODBUS PDU (see the MODBUS Application Protocol Specification for details) </td></tr>
    <tr><td class="paramname">transaction</td><td>A valid pointer to a <a class="el" href="classmdt_port_transaction.html" title="Store port transaction identifications data.">mdtPortTransaction</a> object. The id is set internally. Transaction's data is get as PDU. If isQueryReplyMode is set true, transaction will be keeped in done queue until <a class="el" href="classmdt_port_manager.html#a830ae182d06dd6a52c43a7f45b9240ac" title="Get data by frame ID.">readenFrame(int)</a> is called. For all cases, signal newReadenFrame(mdtPortTransaction*) is emitted when data comes in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Transaction ID on success. If the maximum of authorized transactions are reached, mdtAbstractPort::WriteQueueEmpty (&lt; 0) is returned. Note: internally, the writeFramesPool size of <a class="el" href="classmdt_abstract_port.html" title="Base class for port I/O.">mdtAbstractPort</a> is used to fix maximum transactions, and this is configurable in <a class="el" href="classmdt_port_config.html">mdtPortConfig</a>. See <a class="el" href="classmdt_port_manager.html#a9cf3ea2da38f81682695b37448712ffd" title="Get the port&#39;s config object.">mdtPortManager::config()</a> . On failure, the transaction is restored to pool. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Port must be set with <a class="el" href="classmdt_port_manager.html#afcd156b2d0c9d340999935efb6cd8cb6" title="Set port object.">setPort()</a> before use of this method. </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>Handle this ? </dd></dl>
</p>

<p>Reimplemented from <a class="el" href="classmdt_port_manager.html#a328abc7f5f2677c19ea11567df6597da">mdtPortManager</a>.</p>

<p>Definition at line <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html#l00418">418</a> of file <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html">mdtModbusTcpPortManager.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e687204475d788170b9b61a1f06eecf"></a><!-- doxytag: member="mdtModbusTcpPortManager::writeData" ref="a5e687204475d788170b9b61a1f06eecf" args="(const QByteArray &amp;pdu, bool queryReplyMode=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mdtModbusTcpPortManager::writeData </td>
          <td>(</td>
          <td class="paramtype">const QByteArray &amp;&#160;</td>
          <td class="paramname"><em>pdu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>queryReplyMode</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write PDU by copy. </p>
<p>Will get a new transaction, setup it with pdu as data and queryReplyMode flag, then send it with <a class="el" href="classmdt_modbus_tcp_port_manager.html#afdee5f0444f7f6b258a23733cc134684" title="Write PDU by copy.">writeData(mdtPortTransaction*)</a>. </p>

<p>Reimplemented from <a class="el" href="classmdt_port_manager.html#a9b902a60c8b21585904bcb1d6e604369">mdtPortManager</a>.</p>

<p>Definition at line <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html#l00454">454</a> of file <a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html">mdtModbusTcpPortManager.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/mdtport/<a class="el" href="mdt_modbus_tcp_port_manager_8h_source.html">mdtModbusTcpPortManager.h</a></li>
<li>src/mdtport/<a class="el" href="mdt_modbus_tcp_port_manager_8cpp_source.html">mdtModbusTcpPortManager.cpp</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sun May 12 2013 19:04:31 for Multi diag tools by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
