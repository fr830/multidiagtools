\hypertarget{classmdt_modbus_tcp_port_manager}{
\section{mdtModbusTcpPortManager Class Reference}
\label{classmdt_modbus_tcp_port_manager}\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
}


MODBUS/TCP port manager.  




{\ttfamily \#include $<$mdtModbusTcpPortManager.h$>$}



Inheritance diagram for mdtModbusTcpPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=220pt]{classmdt_modbus_tcp_port_manager__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtModbusTcpPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=310pt]{classmdt_modbus_tcp_port_manager__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Slots}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_modbus_tcp_port_manager_ab6cc6b2a57c1c126be0a9c3142a6f0e5}{
void \hyperlink{classmdt_modbus_tcp_port_manager_ab6cc6b2a57c1c126be0a9c3142a6f0e5}{abortScan} ()}
\label{classmdt_modbus_tcp_port_manager_ab6cc6b2a57c1c126be0a9c3142a6f0e5}

\begin{DoxyCompactList}\small\item\em Abort the scan process. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_modbus_tcp_port_manager_ad941ea607f00db54aa6deb2866a539e9}{fromThreadNewFrameReaden} ()
\begin{DoxyCompactList}\small\item\em Called by the thread whenn a complete frame was readen. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_modbus_tcp_port_manager_a2f65f779bbad19d9d3f85ef35220ffb8}{mdtModbusTcpPortManager} (QObject $\ast$parent=0)
\begin{DoxyCompactList}\small\item\em Construct a MODBUS/TCP port manager. \end{DoxyCompactList}\item 
\hyperlink{classmdt_modbus_tcp_port_manager_aabe51a50a53c6b23884cc4862730b731}{$\sim$mdtModbusTcpPortManager} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_modbus_tcp_port_manager_a216ee2495440be4eefb2faf9da3c9e47}{scan} (const QStringList \&hosts, int timeout=500)
\begin{DoxyCompactList}\small\item\em Scan for available hosts with a MODBUS/TCP compatible device attached. \end{DoxyCompactList}\item 
QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_modbus_tcp_port_manager_a7cfd5dcde142cd262925974b43e58bff}{scan} (const QNetworkInterface \&iface, quint16 port=502, int timeout=500)
\begin{DoxyCompactList}\small\item\em Scan for available hosts with a MODBUS/TCP compatible device attached. \end{DoxyCompactList}\item 
QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_modbus_tcp_port_manager_a2f1128e1f564a785e35b2e9b16bc990f}{scan} (const QList$<$ QNetworkInterface $>$ \&ifaces, quint16 port=502, int timeout=500, bool ignoreLoopback=true)
\begin{DoxyCompactList}\small\item\em Scan for available hosts with a MODBUS/TCP compatible device attached. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_modbus_tcp_port_manager_ab04f69b660487a7c59d309df7a8f5baa}{tryToConnect} (const QString \&hostName, quint16 port, int timeout)
\begin{DoxyCompactList}\small\item\em Try to connect to a host. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_modbus_tcp_port_manager_a3a1f5a54c93fa90ba83dea8785407da3}{saveScanResult} (const QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ scanResult)
\begin{DoxyCompactList}\small\item\em Save a scan result into the known hosts file. \end{DoxyCompactList}\item 
QStringList \hyperlink{classmdt_modbus_tcp_port_manager_ab4d0a994973af6008faf489ca9ddb03d}{readScanResult} ()
\begin{DoxyCompactList}\small\item\em Read scan result stored in cache file. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{getHardwareNodeAddress} (int bitsCount, int startFrom=0)
\begin{DoxyCompactList}\small\item\em Get the hardware node ID. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_modbus_tcp_port_manager_ab5e780409492b5f56326a870bc4262ec}{getRegisterValues} (int address, int n)
\begin{DoxyCompactList}\small\item\em Helper method for register service. \end{DoxyCompactList}\item 
const QList$<$ int $>$ \& \hyperlink{classmdt_modbus_tcp_port_manager_a99a13b5250a8523aa63869991581e56a}{registerValues} () const 
\begin{DoxyCompactList}\small\item\em Helper method for register service. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_modbus_tcp_port_manager_afdee5f0444f7f6b258a23733cc134684}{writeData} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write PDU by copy. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_modbus_tcp_port_manager_a5e687204475d788170b9b61a1f06eecf}{writeData} (const QByteArray \&pdu, bool queryReplyMode=false)
\begin{DoxyCompactList}\small\item\em Write PDU by copy. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
MODBUS/TCP port manager. 

This is the simplest way to use the MODBUS/TCP API.

All needed object are created by constructor. To alter configuration, use \hyperlink{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{config()}. To access the tcp port object, use port().

Use \hyperlink{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{start()} to begin read/write and stop to end.

References:
\begin{DoxyItemize}
\item MODBUS Application Protocol Specification V1.1b
\item \href{http://www.Modbus-IDA.org}{\tt http://www.Modbus-\/IDA.org} 
\end{DoxyItemize}

Definition at line 46 of file mdtModbusTcpPortManager.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_modbus_tcp_port_manager_a2f65f779bbad19d9d3f85ef35220ffb8}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{mdtModbusTcpPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtModbusTcpPortManager::mdtModbusTcpPortManager (
\begin{DoxyParamCaption}
\item[{QObject $\ast$}]{parent = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_a2f65f779bbad19d9d3f85ef35220ffb8}


Construct a MODBUS/TCP port manager. 

Creates a \hyperlink{classmdt_port_config}{mdtPortConfig}, a \hyperlink{classmdt_tcp_socket}{mdtTcpSocket}, and thread object. 

Definition at line 40 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_aabe51a50a53c6b23884cc4862730b731}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!$\sim$mdtModbusTcpPortManager@{$\sim$mdtModbusTcpPortManager}}
\index{$\sim$mdtModbusTcpPortManager@{$\sim$mdtModbusTcpPortManager}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{$\sim$mdtModbusTcpPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtModbusTcpPortManager::$\sim$mdtModbusTcpPortManager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_aabe51a50a53c6b23884cc4862730b731}


Destructor. 

Stop the manager (if running), and close the port (if open). All internal objects (port, config and threads) are deleted here. 

Definition at line 65 of file mdtModbusTcpPortManager.cpp.



\subsection{Member Function Documentation}
\hypertarget{classmdt_modbus_tcp_port_manager_ad941ea607f00db54aa6deb2866a539e9}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!fromThreadNewFrameReaden@{fromThreadNewFrameReaden}}
\index{fromThreadNewFrameReaden@{fromThreadNewFrameReaden}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{fromThreadNewFrameReaden}]{\setlength{\rightskip}{0pt plus 5cm}void mdtModbusTcpPortManager::fromThreadNewFrameReaden (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual, slot\mbox{]}}}}
\label{classmdt_modbus_tcp_port_manager_ad941ea607f00db54aa6deb2866a539e9}


Called by the thread whenn a complete frame was readen. 



\begin{Desc}
\item[\hyperlink{todo__todo000017}{Todo}]Error on incomplete frame \end{Desc}


\begin{Desc}
\item[\hyperlink{todo__todo000018}{Todo}]check about transaction ID ? Should be a assertion ? \end{Desc}




Reimplemented from \hyperlink{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{mdtPortManager}.



Definition at line 475 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!getHardwareNodeAddress@{getHardwareNodeAddress}}
\index{getHardwareNodeAddress@{getHardwareNodeAddress}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{getHardwareNodeAddress}]{\setlength{\rightskip}{0pt plus 5cm}int mdtModbusTcpPortManager::getHardwareNodeAddress (
\begin{DoxyParamCaption}
\item[{int}]{bitsCount, }
\item[{int}]{startFrom = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}


Get the hardware node ID. 

The concept of node ID is specific to MultiDiagTools. It was introduced to solve the problem of network IP configurations.

Take a example: We have a application that needs several MODBUS/TCP nodes. Each node has several I/O's. Say that digital output 1 of node 1 is used to activate a lamp and output 1 of node 2 must activate heating register. We could choose to have static IP addresses in the network and configure the application to activate the correct output of correct node. But, this can be a problem when a node must be replaced. More cumbersome case is a modular application that could manage several nodes, and change his I/Os layout in a dynamic way regarding a context.

A easy way to solve such problems is to have a DHCP server in the network and all nodes configured as DHCP clients (static addressing can still be a solution, but we not depend on it). Then, for a given application, we can fix a number of digital inputs to play the role of node address. Then, instead of using IP address as identification (as in the example), we use node address.


\begin{DoxyParams}{Parameters}
{\em bitsCount} & Number of digital inputs that represents the hardware node address. \\
\hline
{\em startFrom} & First digital input that represents the hardware node address (is the LSB). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Node address or value $<$ 0 corresponding on \hyperlink{classmdt_abstract_port}{mdtAbstractPort} error\_\-t. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port manager must be connected and thread running before calling this method. 

bitsCount must be $>$ 0 

startFrom must be $>$= 0 
\end{DoxyPrecond}


Definition at line 312 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_ab5e780409492b5f56326a870bc4262ec}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!getRegisterValues@{getRegisterValues}}
\index{getRegisterValues@{getRegisterValues}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{getRegisterValues}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtModbusTcpPortManager::getRegisterValues (
\begin{DoxyParamCaption}
\item[{int}]{address, }
\item[{int}]{n}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_ab5e780409492b5f56326a870bc4262ec}


Helper method for register service. 

Usefull to get resgister values (f.ex. configurations regsisters, ...).

Note: to get analog I/O values, the \hyperlink{classmdt_device}{mdtDevice} API should be used.

\begin{DoxyReturn}{Returns}
True on success. Values are the available with \hyperlink{classmdt_modbus_tcp_port_manager_a99a13b5250a8523aa63869991581e56a}{registerValues()} 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
address and n must be $>$ 0 
\end{DoxyPrecond}


Definition at line 364 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_ab4d0a994973af6008faf489ca9ddb03d}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!readScanResult@{readScanResult}}
\index{readScanResult@{readScanResult}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{readScanResult}]{\setlength{\rightskip}{0pt plus 5cm}QStringList mdtModbusTcpPortManager::readScanResult (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_ab4d0a994973af6008faf489ca9ddb03d}


Read scan result stored in cache file. 

The file stored by \hyperlink{classmdt_modbus_tcp_port_manager_a3a1f5a54c93fa90ba83dea8785407da3}{saveScanResult()} is readen (if exists) and content returned.

\begin{DoxyReturn}{Returns}
List of lines or empty list if file not exists or on error. 
\end{DoxyReturn}


Definition at line 291 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a99a13b5250a8523aa63869991581e56a}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!registerValues@{registerValues}}
\index{registerValues@{registerValues}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{registerValues}]{\setlength{\rightskip}{0pt plus 5cm}const QList$<$ int $>$ \& mdtModbusTcpPortManager::registerValues (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_modbus_tcp_port_manager_a99a13b5250a8523aa63869991581e56a}


Helper method for register service. 

Return result set by \hyperlink{classmdt_modbus_tcp_port_manager_ab5e780409492b5f56326a870bc4262ec}{getRegisterValues()}. Note that values are keeped until next call of \hyperlink{classmdt_modbus_tcp_port_manager_ab5e780409492b5f56326a870bc4262ec}{getRegisterValues()}. 

Definition at line 413 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a3a1f5a54c93fa90ba83dea8785407da3}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!saveScanResult@{saveScanResult}}
\index{saveScanResult@{saveScanResult}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{saveScanResult}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtModbusTcpPortManager::saveScanResult (
\begin{DoxyParamCaption}
\item[{const QList$<$ {\bf mdtPortInfo} $\ast$ $>$}]{scanResult}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_a3a1f5a54c93fa90ba83dea8785407da3}


Save a scan result into the known hosts file. 

The file will be written to the \$HOME/.mdt/cache directory, and contains lines with format host:port.


\begin{DoxyParams}{Parameters}
{\em scanResult} & List of port informations returned by a \hyperlink{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}{scan()} method. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True on successfull write. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Manager must no running 
\end{DoxyPrecond}


Q\_\-ASSERT(!isRunning()); 



Definition at line 257 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a216ee2495440be4eefb2faf9da3c9e47}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!scan@{scan}}
\index{scan@{scan}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtModbusTcpPortManager::scan (
\begin{DoxyParamCaption}
\item[{const QStringList \&}]{hosts, }
\item[{int}]{timeout = {\ttfamily 500}}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_a216ee2495440be4eefb2faf9da3c9e47}


Scan for available hosts with a MODBUS/TCP compatible device attached. 


\begin{DoxyParams}{Parameters}
{\em hosts} & A list of hosts to scan. Each host must be set with format hostname:port, or ip:port. Note that MODBUS/TCP default port is 502. \\
\hline
{\em timeout} & Maximum wait time \mbox{[}ms\mbox{]}. Must be a multiple of 50 \mbox{[}ms\mbox{]}\\
\hline
\end{DoxyParams}
Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).

\begin{DoxyPrecond}{Precondition}
Manager must no running 
\end{DoxyPrecond}


Definition at line 73 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a7cfd5dcde142cd262925974b43e58bff}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!scan@{scan}}
\index{scan@{scan}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtModbusTcpPortManager::scan (
\begin{DoxyParamCaption}
\item[{const QNetworkInterface \&}]{iface, }
\item[{quint16}]{port = {\ttfamily 502}, }
\item[{int}]{timeout = {\ttfamily 500}}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_a7cfd5dcde142cd262925974b43e58bff}


Scan for available hosts with a MODBUS/TCP compatible device attached. 


\begin{DoxyParams}{Parameters}
{\em iface} & Scan will be done for all IP addresses available for given intarface. Note that only IPv4 is implemented. \\
\hline
{\em port} & Port. Note that MODBUS/TCP default port is 502. \\
\hline
{\em timeout} & Maximum wait time \mbox{[}ms\mbox{]}. Must be a multiple of 50 \mbox{[}ms\mbox{]}\\
\hline
\end{DoxyParams}
Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).

\begin{DoxyPrecond}{Precondition}
Manager must no running 
\end{DoxyPrecond}


portInfo-\/$>$setDisplayText(currentIp.toString() + \char`\"{}:\char`\"{} + QString::number(port));

qDebug() $<$$<$ \char`\"{}mdtModbusTcpPortManager::scan(): add port: \char`\"{} $<$$<$ portInfo-\/$>$\hyperlink{classmdt_port_manager_af4fcab6aaad98d74aeabfc972da1d406}{portName()}; 



Definition at line 119 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a2f1128e1f564a785e35b2e9b16bc990f}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!scan@{scan}}
\index{scan@{scan}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtModbusTcpPortManager::scan (
\begin{DoxyParamCaption}
\item[{const QList$<$ QNetworkInterface $>$ \&}]{ifaces, }
\item[{quint16}]{port = {\ttfamily 502}, }
\item[{int}]{timeout = {\ttfamily 500}, }
\item[{bool}]{ignoreLoopback = {\ttfamily true}}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_a2f1128e1f564a785e35b2e9b16bc990f}


Scan for available hosts with a MODBUS/TCP compatible device attached. 


\begin{DoxyParams}{Parameters}
{\em ifaces} & Scan will be done for all IP addresses available for all given intarfaces. Note that only IPv4 is implemented. \\
\hline
{\em port} & Port. Note that MODBUS/TCP default port is 502. \\
\hline
{\em timeout} & Maximum wait time \mbox{[}ms\mbox{]}. Must be a multiple of 50 \mbox{[}ms\mbox{]} \\
\hline
{\em ignoreLoopback} & If true, loopback interface will be ignored.\\
\hline
\end{DoxyParams}
Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).

\begin{DoxyPrecond}{Precondition}
Manager must no running 
\end{DoxyPrecond}


Definition at line 194 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_ab04f69b660487a7c59d309df7a8f5baa}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!tryToConnect@{tryToConnect}}
\index{tryToConnect@{tryToConnect}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{tryToConnect}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtModbusTcpPortManager::tryToConnect (
\begin{DoxyParamCaption}
\item[{const QString \&}]{hostName, }
\item[{quint16}]{port, }
\item[{int}]{timeout}
\end{DoxyParamCaption}
)}}
\label{classmdt_modbus_tcp_port_manager_ab04f69b660487a7c59d309df7a8f5baa}


Try to connect to a host. 


\begin{DoxyParams}{Parameters}
{\em hostName} & Host name or a IP address \\
\hline
{\em port} & Port. Note that MODBUS/TCP default port is 502. \\
\hline
{\em timeout} & Maximum wait time \mbox{[}ms\mbox{]}. Must be a multiple of 50 \mbox{[}ms\mbox{]} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True on successfull connection. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Manager must no running 
\end{DoxyPrecond}


Definition at line 219 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_afdee5f0444f7f6b258a23733cc134684}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!writeData@{writeData}}
\index{writeData@{writeData}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{writeData}]{\setlength{\rightskip}{0pt plus 5cm}int mdtModbusTcpPortManager::writeData (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_modbus_tcp_port_manager_afdee5f0444f7f6b258a23733cc134684}


Write PDU by copy. 

Data will be encoded regarding MODBUS/TCP standard and passed to the mdtTcpSocket's write queue by copy. This method returns immediatly after enqueue, and don't wait until data was written.

Internally, the transaction ID is incremented at each request and returned.


\begin{DoxyParams}{Parameters}
{\em pdu} & MODBUS PDU (see the MODBUS Application Protocol Specification for details) \\
\hline
{\em transaction} & A valid pointer to a \hyperlink{classmdt_port_transaction}{mdtPortTransaction} object. The id is set internally. Transaction's data is get as PDU. If isQueryReplyMode is set true, transaction will be keeped in done queue until \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame(int)} is called. For all cases, signal newReadenFrame(mdtPortTransaction$\ast$) is emitted when data comes in. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transaction ID on success. If the maximum of authorized transactions are reached, mdtAbstractPort::WriteQueueEmpty ($<$ 0) is returned. Note: internally, the writeFramesPool size of \hyperlink{classmdt_abstract_port}{mdtAbstractPort} is used to fix maximum transactions, and this is configurable in \hyperlink{classmdt_port_config}{mdtPortConfig}. See \hyperlink{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{mdtPortManager::config()} . On failure, the transaction is restored to pool. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


\begin{Desc}
\item[\hyperlink{todo__todo000016}{Todo}]Handle this ? \end{Desc}




Reimplemented from \hyperlink{classmdt_port_manager_a328abc7f5f2677c19ea11567df6597da}{mdtPortManager}.



Definition at line 418 of file mdtModbusTcpPortManager.cpp.

\hypertarget{classmdt_modbus_tcp_port_manager_a5e687204475d788170b9b61a1f06eecf}{
\index{mdtModbusTcpPortManager@{mdtModbusTcpPortManager}!writeData@{writeData}}
\index{writeData@{writeData}!mdtModbusTcpPortManager@{mdtModbusTcpPortManager}}
\subsubsection[{writeData}]{\setlength{\rightskip}{0pt plus 5cm}int mdtModbusTcpPortManager::writeData (
\begin{DoxyParamCaption}
\item[{const QByteArray \&}]{pdu, }
\item[{bool}]{queryReplyMode = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_modbus_tcp_port_manager_a5e687204475d788170b9b61a1f06eecf}


Write PDU by copy. 

Will get a new transaction, setup it with pdu as data and queryReplyMode flag, then send it with \hyperlink{classmdt_modbus_tcp_port_manager_afdee5f0444f7f6b258a23733cc134684}{writeData(mdtPortTransaction$\ast$)}. 

Reimplemented from \hyperlink{classmdt_port_manager_a9b902a60c8b21585904bcb1d6e604369}{mdtPortManager}.



Definition at line 456 of file mdtModbusTcpPortManager.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtModbusTcpPortManager.h\item 
src/mdtport/mdtModbusTcpPortManager.cpp\end{DoxyCompactItemize}
