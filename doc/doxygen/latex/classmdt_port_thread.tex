\hypertarget{classmdt_port_thread}{
\section{mdtPortThread Class Reference}
\label{classmdt_port_thread}\index{mdtPortThread@{mdtPortThread}}
}


Inheritance diagram for mdtPortThread:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=318pt]{classmdt_port_thread__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtPortThread:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=168pt]{classmdt_port_thread__coll__graph}
\end{center}
\end{figure}
\subsection*{Signals}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_port_thread_a8f3d8f3d70839e5ae7b108a3a199e94d}{ioProcessBegin} ()
\begin{DoxyCompactList}\small\item\em Emitted when a I/O process begins. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_thread_a7fc2245c753fd65e1beffec211c41461}{newFrameReaden} ()
\begin{DoxyCompactList}\small\item\em Emited when a new frame is available. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_thread_ab31cbe1a85aa830cd368654d1f806326}{errorOccured} (int error)
\begin{DoxyCompactList}\small\item\em Emitted on error. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_port_thread_aa20869c68d7a016f9e547464f0d8b71e}{
{\bfseries mdtPortThread} (QObject $\ast$parent=0)}
\label{classmdt_port_thread_aa20869c68d7a016f9e547464f0d8b71e}

\item 
void \hyperlink{classmdt_port_thread_acd51474c3a2683676423317bc9cb31b2}{setPort} (\hyperlink{classmdt_abstract_port}{mdtAbstractPort} $\ast$port)
\begin{DoxyCompactList}\small\item\em Set the port instance. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_port_thread_a29b434534a5564efbd9dfe570a61b143}{detachPort} (bool releaseMemory)
\begin{DoxyCompactList}\small\item\em Detach the port from thread. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_thread_a9c45f260b8d58b7475151df79b3d8510}{start} ()
\begin{DoxyCompactList}\small\item\em Start the thread. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_port_thread_a5746ea96689ed80179751ad1353f0b39}{stop} ()
\begin{DoxyCompactList}\small\item\em Stop the running thread. \end{DoxyCompactList}\item 
\hypertarget{classmdt_port_thread_ae1becf17263dd9fbf5dfcc6c51eddd72}{
bool \hyperlink{classmdt_port_thread_ae1becf17263dd9fbf5dfcc6c51eddd72}{isRunning} () const }
\label{classmdt_port_thread_ae1becf17263dd9fbf5dfcc6c51eddd72}

\begin{DoxyCompactList}\small\item\em Returns true if the thread is running This function overloads the QThread::isRunning() function. Note for subclass: when the thread is started and ready, the private member pvRunning must be set to true. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_port_thread_a55d7ef615447823bf9878492a2c88fd4}{isFinished} () const 
\begin{DoxyCompactList}\small\item\em Returns false if the thread is running. \end{DoxyCompactList}\item 
virtual bool \hyperlink{classmdt_port_thread_a3d57f15a864ae45c98eb40dd89f4cec6}{isReader} () const =0
\begin{DoxyCompactList}\small\item\em Returns true if this thread reads data and send the \hyperlink{classmdt_port_thread_a7fc2245c753fd65e1beffec211c41461}{newFrameReaden()} signal. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_frame}{mdtFrame} $\ast$ \hyperlink{classmdt_port_thread_a611211e56620ec9c699019452716e4fc}{getNewFrameRead} ()
\begin{DoxyCompactList}\small\item\em Get a new frame for reading data from port. \end{DoxyCompactList}\item 
\hyperlink{classmdt_frame}{mdtFrame} $\ast$ \hyperlink{classmdt_port_thread_a7e6e152839e35b8fbd1eb299c1d0b2fe}{readFromPort} (\hyperlink{classmdt_frame}{mdtFrame} $\ast$frame)
\begin{DoxyCompactList}\small\item\em Read data from port. \end{DoxyCompactList}\item 
\hyperlink{classmdt_frame}{mdtFrame} $\ast$ \hyperlink{classmdt_port_thread_acba4fce38a633da68ec23fe191ba6105}{getNewFrameWrite} ()
\begin{DoxyCompactList}\small\item\em Get a new frame for writing data to port. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \hyperlink{classmdt_port_thread_a9372a53561362b0c86f499b8a36805e1}{writeToPort} (\hyperlink{classmdt_frame}{mdtFrame} $\ast$frame, bool bytePerByteWrite, int interByteTime)
\begin{DoxyCompactList}\small\item\em Write data to port. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \hyperlink{classmdt_port_thread_aaea2513ab1611574111dd1c2b7e61b7c}{reconnect} (int timeout, int maxTry)
\begin{DoxyCompactList}\small\item\em Try to reconnect to device/peer. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_port_thread_a01d2362e0dfcece4cba242cb586d8d1c}{
static void {\bfseries sigactionHandle} (int signum)}
\label{classmdt_port_thread_a01d2362e0dfcece4cba242cb586d8d1c}

\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_port_thread_a59735ef01b761361b1055a0356be525a}{
volatile bool {\bfseries pvRunning}}
\label{classmdt_port_thread_a59735ef01b761361b1055a0356be525a}

\item 
\hypertarget{classmdt_port_thread_af5c4bed0c9fb012f220fba013d0f69b8}{
\hyperlink{classmdt_abstract_port}{mdtAbstractPort} $\ast$ {\bfseries pvPort}}
\label{classmdt_port_thread_af5c4bed0c9fb012f220fba013d0f69b8}

\item 
\hypertarget{classmdt_port_thread_a7154af7d387eecaea113ddb5900ff23c}{
pthread\_\-t {\bfseries pvNativePthreadObject}}
\label{classmdt_port_thread_a7154af7d387eecaea113ddb5900ff23c}

\item 
\hypertarget{classmdt_port_thread_ae22f83fd56b06cdaa9b77abafe85a6b4}{
struct sigaction {\bfseries pvSigaction}}
\label{classmdt_port_thread_ae22f83fd56b06cdaa9b77abafe85a6b4}

\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 36 of file mdtPortThread.h.



\subsection{Member Function Documentation}
\hypertarget{classmdt_port_thread_a29b434534a5564efbd9dfe570a61b143}{
\index{mdtPortThread@{mdtPortThread}!detachPort@{detachPort}}
\index{detachPort@{detachPort}!mdtPortThread@{mdtPortThread}}
\subsubsection[{detachPort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::detachPort (
\begin{DoxyParamCaption}
\item[{bool}]{releaseMemory}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_thread_a29b434534a5564efbd9dfe570a61b143}


Detach the port from thread. 


\begin{DoxyParams}{Parameters}
{\em releaseMemory} & If true, the port object that was set with \hyperlink{classmdt_port_thread_acd51474c3a2683676423317bc9cb31b2}{setPort()} will be deleted. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The thread must not running 
\end{DoxyPrecond}


Definition at line 61 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_ab31cbe1a85aa830cd368654d1f806326}{
\index{mdtPortThread@{mdtPortThread}!errorOccured@{errorOccured}}
\index{errorOccured@{errorOccured}!mdtPortThread@{mdtPortThread}}
\subsubsection[{errorOccured}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::errorOccured (
\begin{DoxyParamCaption}
\item[{int}]{error}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_thread_ab31cbe1a85aa830cd368654d1f806326}


Emitted on error. 

\begin{Desc}
\item[\hyperlink{todo__todo000029}{Todo}]Adapt threads + port managers\end{Desc}


When a error occurs, this signal is emited.

The error is one of the \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t}.

\hyperlink{classmdt_port_manager}{mdtPortManager} uses this signal. If the \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea8b70726d03f75a691ac4ad65722a5f3c}{mdtAbstractPort::Disconnected} error happens, the port manager stops the thread and closes the port. Optionnaly, it can try to re-\/open the port, and start the thread again on success. \hypertarget{classmdt_port_thread_a611211e56620ec9c699019452716e4fc}{
\index{mdtPortThread@{mdtPortThread}!getNewFrameRead@{getNewFrameRead}}
\index{getNewFrameRead@{getNewFrameRead}!mdtPortThread@{mdtPortThread}}
\subsubsection[{getNewFrameRead}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtFrame} $\ast$ mdtPortThread::getNewFrameRead (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_thread_a611211e56620ec9c699019452716e4fc}


Get a new frame for reading data from port. 

This is a helper method for subclass to get a new frame in port's read frames pool.

It can hapen that the read frames pool is empty. In this case, a error will be generated in the \hyperlink{classmdt_error}{mdtError} log system, the signal \hyperlink{classmdt_port_thread_ab31cbe1a85aa830cd368654d1f806326}{errorOccured()} will be emited with MDT\_\-PORT\_\-QUEUE\_\-EMPTY\_\-ERROR value, and method will go sleep until a new frame is available in pool.

\begin{Desc}
\item[\hyperlink{todo__todo000030}{Todo}]Currently implemented in polling, should be done with a wait condition.\end{Desc}


Note about port mutex handling:\par
 The port mutext must be locked before calling this method. Internally, it will be unlocked during wait, and will be locked again. So, the port mutex is allways locked when this method returns.

\begin{DoxyReturn}{Returns}
A pointer to a new frame. This frame is cleared (with \hyperlink{classmdt_frame_acdf8a921a3f36ca91af88b55b90febdc}{mdtFrame::clear()} ). If the runnig flag becomes false, a Null pointer is returned, and thread should stop.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_thread_acd51474c3a2683676423317bc9cb31b2}{setPort()} before using this method. 
\end{DoxyPrecond}


Definition at line 173 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_acba4fce38a633da68ec23fe191ba6105}{
\index{mdtPortThread@{mdtPortThread}!getNewFrameWrite@{getNewFrameWrite}}
\index{getNewFrameWrite@{getNewFrameWrite}!mdtPortThread@{mdtPortThread}}
\subsubsection[{getNewFrameWrite}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtFrame} $\ast$ mdtPortThread::getNewFrameWrite (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_thread_acba4fce38a633da68ec23fe191ba6105}


Get a new frame for writing data to port. 

This is a helper method for subclass to get a new frame in port's write frames.

If no frame is available for write, this method will block the caller thread until one is avaliable.

Note about port mutex handling:\par
 The port mutext must be locked before calling this method. Internally, it will be unlocked during wait, and will be locked again. So, the port mutex is allways locked when this method returns.

\begin{DoxyReturn}{Returns}
A pointer to a new frame, or Null on stop request.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_thread_acd51474c3a2683676423317bc9cb31b2}{setPort()} before using this method. 
\end{DoxyPrecond}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_abstract_port}{mdtAbstractPort} 
\end{DoxySeeAlso}


Definition at line 278 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_a8f3d8f3d70839e5ae7b108a3a199e94d}{
\index{mdtPortThread@{mdtPortThread}!ioProcessBegin@{ioProcessBegin}}
\index{ioProcessBegin@{ioProcessBegin}!mdtPortThread@{mdtPortThread}}
\subsubsection[{ioProcessBegin}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::ioProcessBegin (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_thread_a8f3d8f3d70839e5ae7b108a3a199e94d}


Emitted when a I/O process begins. 

This can be used to display read/write state. Please consider that this signal is emitted each time the I/O process begins, and not when it ends. This is because asynch I/O calls are fast, and nothing will be seen from user if we update state before/after I/O call. To handle this, use this signal as trigger, and hold the state some stime (f.ex. 100 \mbox{[}ms\mbox{]}) \hypertarget{classmdt_port_thread_a55d7ef615447823bf9878492a2c88fd4}{
\index{mdtPortThread@{mdtPortThread}!isFinished@{isFinished}}
\index{isFinished@{isFinished}!mdtPortThread@{mdtPortThread}}
\subsubsection[{isFinished}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortThread::isFinished (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_port_thread_a55d7ef615447823bf9878492a2c88fd4}


Returns false if the thread is running. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_thread_ae1becf17263dd9fbf5dfcc6c51eddd72}{isRunning()} 
\end{DoxySeeAlso}


Definition at line 159 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_a3d57f15a864ae45c98eb40dd89f4cec6}{
\index{mdtPortThread@{mdtPortThread}!isReader@{isReader}}
\index{isReader@{isReader}!mdtPortThread@{mdtPortThread}}
\subsubsection[{isReader}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool mdtPortThread::isReader (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}pure virtual\mbox{]}}}}
\label{classmdt_port_thread_a3d57f15a864ae45c98eb40dd89f4cec6}


Returns true if this thread reads data and send the \hyperlink{classmdt_port_thread_a7fc2245c753fd65e1beffec211c41461}{newFrameReaden()} signal. 

\hyperlink{classmdt_port_manager}{mdtPortManager} can handle many threads. It needs to know wich one will send the \hyperlink{classmdt_port_thread_a7fc2245c753fd65e1beffec211c41461}{newFrameReaden()} signal, so it can connect it to his slot.

This method must be implemented in subclass. 

Implemented in \hyperlink{classmdt_port_read_thread_a0138d613b61056c9f8373331de2d9a84}{mdtPortReadThread}, \hyperlink{classmdt_port_write_thread_ac37bb988773f624def51e841998a2f1e}{mdtPortWriteThread}, \hyperlink{classmdt_tcp_socket_thread_a3224f12c8ff8d695975030f3f6215010}{mdtTcpSocketThread}, \hyperlink{classmdt_usb_port_thread_aed82b57c84745f1e2391750697db1022}{mdtUsbPortThread}, and \hyperlink{classmdt_serial_port_ctl_thread_ab87413cedc8d0540eac553e55a3f6407}{mdtSerialPortCtlThread}.

\hypertarget{classmdt_port_thread_a7fc2245c753fd65e1beffec211c41461}{
\index{mdtPortThread@{mdtPortThread}!newFrameReaden@{newFrameReaden}}
\index{newFrameReaden@{newFrameReaden}!mdtPortThread@{mdtPortThread}}
\subsubsection[{newFrameReaden}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::newFrameReaden (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}signal\mbox{]}}}}
\label{classmdt_port_thread_a7fc2245c753fd65e1beffec211c41461}


Emited when a new frame is available. 

This signal is emited when a new frame is available.

To get the frame, the simplest way is to use a \hyperlink{classmdt_port_manager}{mdtPortManager}.

It's also possible to use \hyperlink{classmdt_port}{mdtPort}, but this solution needs to handle the mutex, verify the readen queue state, ...

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_port_manager}{mdtPortManager} 

\hyperlink{classmdt_port}{mdtPort} 
\end{DoxySeeAlso}
\hypertarget{classmdt_port_thread_a7e6e152839e35b8fbd1eb299c1d0b2fe}{
\index{mdtPortThread@{mdtPortThread}!readFromPort@{readFromPort}}
\index{readFromPort@{readFromPort}!mdtPortThread@{mdtPortThread}}
\subsubsection[{readFromPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtFrame} $\ast$ mdtPortThread::readFromPort (
\begin{DoxyParamCaption}
\item[{{\bf mdtFrame} $\ast$}]{frame}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_thread_a7e6e152839e35b8fbd1eb299c1d0b2fe}


Read data from port. 

This is a helper method for subclass to store chunk of data into a frame.

Note about port mutex handling:\par
 The port mutext must be locked before calling this method. Internally, it will be unlocked during wait, and will be locked again. So, the port mutex is allways locked when this method returns.


\begin{DoxyParams}{Parameters}
{\em frame} & Data readen from port will be stored in this frame.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the current frame (can be different from frame passed as argument!). It can happen that a Null pointer is returned, and this is a fatal error, and thread should be stopped.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_thread_acd51474c3a2683676423317bc9cb31b2}{setPort()} before using this method. 

frame must be a valid pointer (not Null). 
\end{DoxyPrecond}


Definition at line 206 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_aaea2513ab1611574111dd1c2b7e61b7c}{
\index{mdtPortThread@{mdtPortThread}!reconnect@{reconnect}}
\index{reconnect@{reconnect}!mdtPortThread@{mdtPortThread}}
\subsubsection[{reconnect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtPortThread::reconnect (
\begin{DoxyParamCaption}
\item[{int}]{timeout, }
\item[{int}]{maxTry}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_thread_aaea2513ab1611574111dd1c2b7e61b7c}


Try to reconnect to device/peer. 

This is a helper method for subclass. When a port method returns a Disconnected error, the thread can call this method, wich will try to reconnect (using \hyperlink{classmdt_abstract_port_aec74b2db1a629d98a95d8f042ea96653}{mdtAbstractPort::reconnect()} ) until max retry was reached.


\begin{DoxyParams}{Parameters}
{\em timeout} & Timeout per try \mbox{[}ms\mbox{]} \\
\hline
{\em maxTry} & Maximum try \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
NoError if reconnection worked or UnhandledError else.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_thread_acd51474c3a2683676423317bc9cb31b2}{setPort()} before using this method. 
\end{DoxyPrecond}


Definition at line 349 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_acd51474c3a2683676423317bc9cb31b2}{
\index{mdtPortThread@{mdtPortThread}!setPort@{setPort}}
\index{setPort@{setPort}!mdtPortThread@{mdtPortThread}}
\subsubsection[{setPort}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::setPort (
\begin{DoxyParamCaption}
\item[{{\bf mdtAbstractPort} $\ast$}]{port}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_thread_acd51474c3a2683676423317bc9cb31b2}


Set the port instance. 

\begin{DoxyPrecond}{Precondition}
port must be a valid pointer 

The thread must not running 
\end{DoxyPrecond}


Definition at line 53 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_a9c45f260b8d58b7475151df79b3d8510}{
\index{mdtPortThread@{mdtPortThread}!start@{start}}
\index{start@{start}!mdtPortThread@{mdtPortThread}}
\subsubsection[{start}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtPortThread::start (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_port_thread_a9c45f260b8d58b7475151df79b3d8510}


Start the thread. 

\begin{DoxyReturn}{Returns}
True on sucsessfull start, or flase on start timeout 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Serial port instance must be defined. 
\end{DoxyPrecond}
\begin{DoxySeeAlso}{See also}
setSerialPort() 
\end{DoxySeeAlso}


Definition at line 71 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_a5746ea96689ed80179751ad1353f0b39}{
\index{mdtPortThread@{mdtPortThread}!stop@{stop}}
\index{stop@{stop}!mdtPortThread@{mdtPortThread}}
\subsubsection[{stop}]{\setlength{\rightskip}{0pt plus 5cm}void mdtPortThread::stop (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_port_thread_a5746ea96689ed80179751ad1353f0b39}


Stop the running thread. 

\begin{DoxyPrecond}{Precondition}
Serial port instance must be defined. 
\end{DoxyPrecond}
\begin{DoxySeeAlso}{See also}
setSerialPort() 
\end{DoxySeeAlso}


Reimplemented in \hyperlink{classmdt_port_write_thread_a69702ab3a95c238fb451f866efc7cb34}{mdtPortWriteThread}, \hyperlink{classmdt_tcp_socket_thread_a0fd2b3f8b497427d84ae358c6f72122e}{mdtTcpSocketThread}, and \hyperlink{classmdt_usb_port_thread_a0be9bce0248ada81087282deea70505b}{mdtUsbPortThread}.



Definition at line 98 of file mdtPortThread.cpp.

\hypertarget{classmdt_port_thread_a9372a53561362b0c86f499b8a36805e1}{
\index{mdtPortThread@{mdtPortThread}!writeToPort@{writeToPort}}
\index{writeToPort@{writeToPort}!mdtPortThread@{mdtPortThread}}
\subsubsection[{writeToPort}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtPortThread::writeToPort (
\begin{DoxyParamCaption}
\item[{{\bf mdtFrame} $\ast$}]{frame, }
\item[{bool}]{bytePerByteWrite, }
\item[{int}]{interByteTime}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}
\label{classmdt_port_thread_a9372a53561362b0c86f499b8a36805e1}


Write data to port. 

This is a helper method for subclass to write a frame to the port. Internally, it will call \hyperlink{classmdt_abstract_port_a35e4686f50e2c53c7e3618cf2c485d92}{mdtAbstractPort::waitEventWriteReady()} before writing.

Note about port mutex handling:\par
 The port mutex must be locked before calling this method. Internally, it will be unlocked during wait, and will be locked again. So, the port mutex is allways locked when this method returns.


\begin{DoxyParams}{Parameters}
{\em frame} & Data stored in this frame will be written to port. \\
\hline
{\em bytePerByteWrite} & If true, one byte will be written once. \\
\hline
{\em interByteTime} & Time between each byte write \mbox{[}ms\mbox{]} (has only effect if bytePerByteWrite is true)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
NoError on success or a \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} error.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_thread_acd51474c3a2683676423317bc9cb31b2}{setPort()} before using this method. 

frame must be a valid pointer (not Null). 
\end{DoxyPrecond}


Definition at line 285 of file mdtPortThread.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtPortThread.h\item 
src/mdtport/mdtPortThread.cpp\end{DoxyCompactItemize}
