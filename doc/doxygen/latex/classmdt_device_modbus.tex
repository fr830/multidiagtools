\hypertarget{classmdt_device_modbus}{
\section{mdtDeviceModbus Class Reference}
\label{classmdt_device_modbus}\index{mdtDeviceModbus@{mdtDeviceModbus}}
}


Represent a MODBUS device.  




{\ttfamily \#include $<$mdtDeviceModbus.h$>$}



Inheritance diagram for mdtDeviceModbus:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=204pt]{classmdt_device_modbus__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtDeviceModbus:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{classmdt_device_modbus__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_device_modbus_ac69cfbe26681342ba05672ab63de2a1f}{mdtDeviceModbus} (QObject $\ast$parent=0)
\item 
\hypertarget{classmdt_device_modbus_aed892b501f8cbd372ccfda1a4fafa536}{
\hyperlink{classmdt_port_manager}{mdtPortManager} $\ast$ \hyperlink{classmdt_device_modbus_aed892b501f8cbd372ccfda1a4fafa536}{portManager} ()}
\label{classmdt_device_modbus_aed892b501f8cbd372ccfda1a4fafa536}

\begin{DoxyCompactList}\small\item\em Get internal port manager instance. \end{DoxyCompactList}\item 
\hypertarget{classmdt_device_modbus_ac547788aa95d46c00ddb1342eb46ef93}{
\hyperlink{classmdt_modbus_tcp_port_manager}{mdtModbusTcpPortManager} $\ast$ \hyperlink{classmdt_device_modbus_ac547788aa95d46c00ddb1342eb46ef93}{modbusTcpPortManager} ()}
\label{classmdt_device_modbus_ac547788aa95d46c00ddb1342eb46ef93}

\begin{DoxyCompactList}\small\item\em Get internal port manager instance. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} \hyperlink{classmdt_device_modbus_a323b16687f448a4e45eb0b313635b77f}{connectToDevice} (const QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \&scanResult, int hardwareNodeId, int bitsCount, int startFrom=0)
\begin{DoxyCompactList}\small\item\em Search and connect to physical device. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_device_modbus_a89d41c6b33a3dd2a92a0956d8e6b3b14}{getRegisterValues} (int address, int n)
\begin{DoxyCompactList}\small\item\em Helper method for register service. \end{DoxyCompactList}\item 
const QList$<$ int $>$ \& \hyperlink{classmdt_device_modbus_a83cb2a28111653fbcbbe748f7a1a2e3d}{registerValues} () const 
\begin{DoxyCompactList}\small\item\em Helper method for register service. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{classmdt_device_modbus_aa2a024793ae2a5e81c7e92260a70cd9e}{readAnalogInput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read one analog input on physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a846af6dbf80bbf747f3f966420ef6f92}{readAnalogInputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all analog inputs on physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a30c815cbe5e603e8114dcbc09849e322}{readAnalogOutput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read one analog output on physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_ae02dd44f1d873fcc15ff75d781b62b0b}{readAnalogOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all analog outputs on physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_ac63297a31205759622f341525c34251f}{writeAnalogOutput} (int value, \hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write value on a analog output to physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a87af02c83cede03d6ee988c678e0fc00}{writeAnalogOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write all analog outputs to physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a9dd05e51223ee5bb79970fbe84c501f9}{readDigitalInput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read one digital input on physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a3fba9e113092f9da187cf684fb62b132}{readDigitalInputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all digital inputs on physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a13a334ac86135751893f37064d8f548d}{readDigitalOutput} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read one digital output on physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a8915a036472bff0f356756992c1eae51}{readDigitalOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Read all digital outputs on physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_a6950c10fc521b193fb3c754223879694}{writeDigitalOutput} (bool state, \hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write state on a digital output to physical device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_device_modbus_aad3ce85a19307e3056b940da99fe512b}{writeDigitalOutputs} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Write all digital outputs to physical device. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_device_modbus_a3b83b926ed1f9c3bdf7024de2745c285}{queriesSequence} ()
\begin{DoxyCompactList}\small\item\em Sequence of queries to send periodically. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_device_modbus_a9ecbac63c29b229ab01f5fdb26008c95}{
\hyperlink{classmdt_modbus_tcp_port_manager}{mdtModbusTcpPortManager} $\ast$ {\bfseries pvTcpPortManager}}
\label{classmdt_device_modbus_a9ecbac63c29b229ab01f5fdb26008c95}

\item 
\hypertarget{classmdt_device_modbus_a2171d37ea720d546934f1c841e3c4d26}{
\hyperlink{classmdt_frame_codec_modbus}{mdtFrameCodecModbus} $\ast$ {\bfseries pvCodec}}
\label{classmdt_device_modbus_a2171d37ea720d546934f1c841e3c4d26}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Represent a MODBUS device. 

References:
\begin{DoxyItemize}
\item MODBUS Application Protocol Specification V1.1b
\item \href{http://www.Modbus-IDA.org}{\tt http://www.Modbus-\/IDA.org} 
\end{DoxyItemize}

Definition at line 41 of file mdtDeviceModbus.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_device_modbus_ac69cfbe26681342ba05672ab63de2a1f}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!mdtDeviceModbus@{mdtDeviceModbus}}
\index{mdtDeviceModbus@{mdtDeviceModbus}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{mdtDeviceModbus}]{\setlength{\rightskip}{0pt plus 5cm}mdtDeviceModbus::mdtDeviceModbus (
\begin{DoxyParamCaption}
\item[{QObject $\ast$}]{parent = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_modbus_ac69cfbe26681342ba05672ab63de2a1f}


connect(pvTcpPortManager, SIGNAL(errorStateChanged(int, const QString\&, const QString\&)), this, SLOT(setStateFromPortError(int, const QString\&, const QString\&)));

connect(pvTcpPortManager, SIGNAL(statusMessageChanged(const QString\&, int)), this, SIGNAL(statusMessageChanged(const QString\&, int)));

\begin{DoxyNote}{Note}
Provisoire !! pvTcpPortManager-\/$>$setPortName(\char`\"{}192.168.1.110:502\char`\"{}); pvTcpPortManager-\/$>$setPortName(\char`\"{}192.168.1.103:502\char`\"{}); connect(this, SIGNAL(\hyperlink{classmdt_device_aecd2d9d2cc3665f2084d0fd20eb3db2d}{stateChanged(int)}), this, SLOT(onStateChanged(int))); pvTcpPortManager-\/$>$openPort(); pvTcpPortManager-\/$>$\hyperlink{classmdt_device_a721c5bf2cfa0eef5304333f08da182f7}{start()}; setStateReady(); 
\end{DoxyNote}




Definition at line 30 of file mdtDeviceModbus.cpp.



\subsection{Member Function Documentation}
\hypertarget{classmdt_device_modbus_a323b16687f448a4e45eb0b313635b77f}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!connectToDevice@{connectToDevice}}
\index{connectToDevice@{connectToDevice}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{connectToDevice}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtDeviceModbus::connectToDevice (
\begin{DoxyParamCaption}
\item[{const QList$<$ {\bf mdtPortInfo} $\ast$ $>$ \&}]{scanResult, }
\item[{int}]{hardwareNodeId, }
\item[{int}]{bitsCount, }
\item[{int}]{startFrom = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_modbus_a323b16687f448a4e45eb0b313635b77f}


Search and connect to physical device. 

Will try to connect to device listed in scanResult until hardwareNodeId is found.


\begin{DoxyParams}{Parameters}
{\em scanResult} & List of \hyperlink{classmdt_port_info}{mdtPortInfo} containing a port name in format host:port. \\
\hline
{\em hardwareNodeId} & See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{mdtModbusTcpPortManager::getHardwareNodeAddress()}. \\
\hline
{\em bitsCount} & See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{mdtModbusTcpPortManager::getHardwareNodeAddress()}. \\
\hline
{\em startFrom} & See \hyperlink{classmdt_modbus_tcp_port_manager_a4f52a477c264f809984e25abbc856db8}{mdtModbusTcpPortManager::getHardwareNodeAddress()}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A error listed in \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} (NoError on success). 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
scanResult must contain valid pointers. 

Internal port manager not runnig and port must be closed before calling this method. 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_device_modbus_wago_a12ad1f1ef34b16be5903d1d6232a7c6d}{mdtDeviceModbusWago}.



Definition at line 74 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a89d41c6b33a3dd2a92a0956d8e6b3b14}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!getRegisterValues@{getRegisterValues}}
\index{getRegisterValues@{getRegisterValues}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{getRegisterValues}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtDeviceModbus::getRegisterValues (
\begin{DoxyParamCaption}
\item[{int}]{address, }
\item[{int}]{n}
\end{DoxyParamCaption}
)}}
\label{classmdt_device_modbus_a89d41c6b33a3dd2a92a0956d8e6b3b14}


Helper method for register service. 

Usefull to get resgister values (f.ex. configurations regsisters, ...).

Note: to get analog I/O values, the \hyperlink{classmdt_device}{mdtDevice} API should be used.

\begin{DoxyReturn}{Returns}
True on success. Values are the available with \hyperlink{classmdt_device_modbus_a83cb2a28111653fbcbbe748f7a1a2e3d}{registerValues()} 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
address and n must be $>$ 0 
\end{DoxyPrecond}
\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_modbus_tcp_port_manager_ab5e780409492b5f56326a870bc4262ec}{mdtModbusTcpPortManager::getRegisterValues()} 
\end{DoxySeeAlso}


Q\_\-ASSERT(address $>$= 0); Q\_\-ASSERT(n $>$ 0);

int transactionId; \hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction; QByteArray pdu; int i;

Clear previous results pvRegisterValues.clear(); Setup MODBUS PDU pdu = pvCodec-\/$>$encodeReadInputRegisters(address, n); if(pdu.isEmpty())\{ return false; \} Get a new transaction transaction = \hyperlink{classmdt_device_a0e57cc8b749581cff447d514b9a1ff8e}{getNewTransaction()}; Send query transaction-\/$>$setQueryReplyMode(true); transactionId = pvTcpPortManager-\/$>$writeData(pdu, transaction); if(transactionId $<$ 0)\{ restoreTransaction(transaction); return false; \} Wait on result (use device's defined timeout) if(!pvTcpPortManager-\/$>$waitOnFrame(transactionId))\{ restoreTransaction(transaction); return false; \} At this state, transaction will be restored by readenFrame() if(pvCodec-\/$>$decode(pvTcpPortManager-\/$>$readenFrame(transactionId)) $<$ 0)\{ return false; \} Store values if(pvCodec-\/$>$values().size() != n)\{ \hyperlink{classmdt_error}{mdtError} e(MDT\_\-DEVICE\_\-ERROR, \char`\"{}Device \char`\"{} + \hyperlink{classmdt_device_a7ad893c6885dbaef5a6cb980bfe627e0}{name()} + \char`\"{}: received unexptected count of values\char`\"{}, mdtError::Error); MDT\_\-ERROR\_\-SET\_\-SRC(e, \char`\"{}mdtDeviceModbusWago\char`\"{}); e.commit(); return false; \} for(i=0; i$<$n; i++)\{ pvRegisterValues.append(pvCodec-\/$>$values().at(i).toInt()); \}

return true;



Definition at line 104 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a3b83b926ed1f9c3bdf7024de2745c285}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!queriesSequence@{queriesSequence}}
\index{queriesSequence@{queriesSequence}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{queriesSequence}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtDeviceModbus::queriesSequence (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a3b83b926ed1f9c3bdf7024de2745c285}


Sequence of queries to send periodically. 

This method is called from \hyperlink{classmdt_device_a14634fec6cd6bae810562b3bd88a5c05}{runQueries()}.

\begin{DoxyReturn}{Returns}
true if all queries are sent successfully.
\end{DoxyReturn}
Subclass notes:\par

\begin{DoxyItemize}
\item This default implementation does nothing and allways returns false.
\item This method can be reimplemented periodic queries must be sent to device. 
\end{DoxyItemize}

Reimplemented from \hyperlink{classmdt_device_acba50968d201ad95c4eaa2ab2ed48b4f}{mdtDevice}.



Definition at line 312 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_aa2a024793ae2a5e81c7e92260a70cd9e}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readAnalogInput@{readAnalogInput}}
\index{readAnalogInput@{readAnalogInput}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readAnalogInput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readAnalogInput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_aa2a024793ae2a5e81c7e92260a70cd9e}


Read one analog input on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from getAnalogInput().


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details). 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_acecf7934ce29b3a957accb0f4c98c746}{mdtDevice}.



Definition at line 324 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a846af6dbf80bbf747f3f966420ef6f92}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readAnalogInputs@{readAnalogInputs}}
\index{readAnalogInputs@{readAnalogInputs}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readAnalogInputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readAnalogInputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a846af6dbf80bbf747f3f966420ef6f92}


Read all analog inputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a585cc32f6aac4d5788928ecf1fdacf51}{getAnalogInputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_a40674e7bf0c367bb3edb407d73a5bd8e}{mdtDevice}.



Definition at line 340 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a30c815cbe5e603e8114dcbc09849e322}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readAnalogOutput@{readAnalogOutput}}
\index{readAnalogOutput@{readAnalogOutput}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readAnalogOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readAnalogOutput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a30c815cbe5e603e8114dcbc09849e322}


Read one analog output on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a7085491cf2d96fd2afd3004de6caef0d}{getAnalogOutputValue()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_a7934063c3f41a742515f1232c9598c2a}{mdtDevice}.



Definition at line 355 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_ae02dd44f1d873fcc15ff75d781b62b0b}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readAnalogOutputs@{readAnalogOutputs}}
\index{readAnalogOutputs@{readAnalogOutputs}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readAnalogOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readAnalogOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_ae02dd44f1d873fcc15ff75d781b62b0b}


Read all analog outputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a7085491cf2d96fd2afd3004de6caef0d}{getAnalogOutputValue()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_ab0232ac83c38bc93d3bc2aa91d94c291}{mdtDevice}.



Definition at line 371 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a9dd05e51223ee5bb79970fbe84c501f9}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readDigitalInput@{readDigitalInput}}
\index{readDigitalInput@{readDigitalInput}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readDigitalInput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readDigitalInput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a9dd05e51223ee5bb79970fbe84c501f9}


Read one digital input on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_aad589d5c8c769299fdf0ea4e34d3bc0a}{getDigitalInputState()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_af128b606050035abaf8d049bb2227015}{mdtDevice}.



Definition at line 418 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a3fba9e113092f9da187cf684fb62b132}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readDigitalInputs@{readDigitalInputs}}
\index{readDigitalInputs@{readDigitalInputs}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readDigitalInputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readDigitalInputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a3fba9e113092f9da187cf684fb62b132}


Read all digital inputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital inputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_ae482b28263b2ce61735f42f1245c1e99}{getDigitalInputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


pdu = pvCodec-\/$>$encodeReadDiscreteInputs(pvDigitalOutputAddressOffset, pvIos-\/$>$digitalInputsCount());

pdu = pvCodec-\/$>$encodeReadDiscreteInputs(0x0000, 16); 



Reimplemented from \hyperlink{classmdt_device_a150e3abae6db5bf1ad11017bf2b76c14}{mdtDevice}.



Definition at line 434 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a13a334ac86135751893f37064d8f548d}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readDigitalOutput@{readDigitalOutput}}
\index{readDigitalOutput@{readDigitalOutput}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readDigitalOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readDigitalOutput (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a13a334ac86135751893f37064d8f548d}


Read one digital output on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a719401fec13501047ffdf7f51583937c}{getDigitalOutputState()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_a1faee6ab31b094731211ea0943544501}{mdtDevice}.



Definition at line 452 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a8915a036472bff0f356756992c1eae51}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!readDigitalOutputs@{readDigitalOutputs}}
\index{readDigitalOutputs@{readDigitalOutputs}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{readDigitalOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::readDigitalOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a8915a036472bff0f356756992c1eae51}


Read all digital outputs on physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a6bd6ad4f8d07121dd8b988594927e9c8}{getDigitalOutputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_aac038c24c3b91757584bdf0d09fb8b02}{mdtDevice}.



Definition at line 468 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a83cb2a28111653fbcbbe748f7a1a2e3d}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!registerValues@{registerValues}}
\index{registerValues@{registerValues}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{registerValues}]{\setlength{\rightskip}{0pt plus 5cm}const QList$<$ int $>$ \& mdtDeviceModbus::registerValues (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_device_modbus_a83cb2a28111653fbcbbe748f7a1a2e3d}


Helper method for register service. 

Return result set by \hyperlink{classmdt_device_modbus_a89d41c6b33a3dd2a92a0956d8e6b3b14}{getRegisterValues()}. Note that values are keeped until next call of \hyperlink{classmdt_device_modbus_a89d41c6b33a3dd2a92a0956d8e6b3b14}{getRegisterValues()}.

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_modbus_tcp_port_manager_a99a13b5250a8523aa63869991581e56a}{mdtModbusTcpPortManager::registerValues()} 
\end{DoxySeeAlso}


Definition at line 156 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_ac63297a31205759622f341525c34251f}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!writeAnalogOutput@{writeAnalogOutput}}
\index{writeAnalogOutput@{writeAnalogOutput}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{writeAnalogOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::writeAnalogOutput (
\begin{DoxyParamCaption}
\item[{int}]{value, }
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_ac63297a31205759622f341525c34251f}


Write value on a analog output to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a4b01925cfbbb62e32a3e85a9c4b1538a}{setAnalogOutputValue()}.


\begin{DoxyParams}{Parameters}
{\em value} & Value encoded regarding device format. \\
\hline
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_ae764634bba2b321ac2b4731c0353e45f}{mdtDevice}.



Definition at line 386 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a87af02c83cede03d6ee988c678e0fc00}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!writeAnalogOutputs@{writeAnalogOutputs}}
\index{writeAnalogOutputs@{writeAnalogOutputs}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{writeAnalogOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::writeAnalogOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a87af02c83cede03d6ee988c678e0fc00}


Write all analog outputs to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has analog outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_ae45c39c2ef38b5952171fdc1c3284748}{setAnalogOutputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_abc52b797df29945bf0a6358aab1b7245}{mdtDevice}.



Definition at line 402 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_a6950c10fc521b193fb3c754223879694}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!writeDigitalOutput@{writeDigitalOutput}}
\index{writeDigitalOutput@{writeDigitalOutput}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{writeDigitalOutput}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::writeDigitalOutput (
\begin{DoxyParamCaption}
\item[{bool}]{state, }
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_a6950c10fc521b193fb3c754223879694}


Write state on a digital output to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_a702a5f49680b03f04a9f58ae6906bf83}{setDigitalOutputState()}.


\begin{DoxyParams}{Parameters}
{\em state} & State (ON/OFF). \\
\hline
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_device_a0fbe57503d86554829e708b2b83d73f1}{mdtDevice}.



Definition at line 484 of file mdtDeviceModbus.cpp.

\hypertarget{classmdt_device_modbus_aad3ce85a19307e3056b940da99fe512b}{
\index{mdtDeviceModbus@{mdtDeviceModbus}!writeDigitalOutputs@{writeDigitalOutputs}}
\index{writeDigitalOutputs@{writeDigitalOutputs}!mdtDeviceModbus@{mdtDeviceModbus}}
\subsubsection[{writeDigitalOutputs}]{\setlength{\rightskip}{0pt plus 5cm}int mdtDeviceModbus::writeDigitalOutputs (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}
\label{classmdt_device_modbus_aad3ce85a19307e3056b940da99fe512b}


Write all digital outputs to physical device. 

This is the device specific implementation to send the query. If device handled by subclass has digital outputs, this method should be implemented.

This method is called from \hyperlink{classmdt_device_ae68a400d5f27fe142d41b674f473bf98}{setDigitalOutputs()}.


\begin{DoxyParams}{Parameters}
{\em transaction} & Contains some flags used during query/reply process (address, id, I/O object, ...). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 or a ID on success, value $<$ 0 on error (see \hyperlink{classmdt_port_manager_a8b60d53d6e553f15dedec916f9c1614b}{mdtPortManager::writeData()} for details) 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
I/O's must be set with \hyperlink{classmdt_device_a9f1de62ef54974b0636dee673bd819e2}{setIos()}. 

transaction must be a valid pointer. 
\end{DoxyPrecond}


qDebug() $<$$<$ \char`\"{}mdtDeviceModbus::writeDigitalOutputs(): states: \char`\"{} $<$$<$ pvIos-\/$>$digitalOutputsStates(); pdu = pvCodec-\/$>$encodeWriteMultipleCoils(pvDigitalOutputAddressOffset, pvIos-\/$>$digitalOutputsStates()); 



Reimplemented from \hyperlink{classmdt_device_aa9e8ae7b4ff2455b4105d280d8523fc1}{mdtDevice}.



Definition at line 500 of file mdtDeviceModbus.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtdevice/mdtDeviceModbus.h\item 
src/mdtdevice/mdtDeviceModbus.cpp\end{DoxyCompactItemize}
