\hypertarget{classmdt_usb_port}{
\section{mdtUsbPort Class Reference}
\label{classmdt_usb_port}\index{mdtUsbPort@{mdtUsbPort}}
}


USB port I/O port class.  




{\ttfamily \#include $<$mdtUsbPort.h$>$}



Inheritance diagram for mdtUsbPort:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=168pt]{classmdt_usb_port__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtUsbPort:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=168pt]{classmdt_usb_port__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_usb_port_a311650f4b2d29b6f16336c8777196d1c}{
{\bfseries mdtUsbPort} (QObject $\ast$parent=0)}
\label{classmdt_usb_port_a311650f4b2d29b6f16336c8777196d1c}

\item 
\hypertarget{classmdt_usb_port_afa9f1942ca4ae384887441e01b362c16}{
\hyperlink{classmdt_usb_port_afa9f1942ca4ae384887441e01b362c16}{$\sim$mdtUsbPort} ()}
\label{classmdt_usb_port_afa9f1942ca4ae384887441e01b362c16}

\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_af2399348faf1abc20130eab20cfc36ee}{reconnect} (int timeout)
\begin{DoxyCompactList}\small\item\em Reconnect device. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_a44ed5024a81a573b5196b8f64c42cd6a}{setReadTimeout} (int timeout)
\begin{DoxyCompactList}\small\item\em Set the read data timeout. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_a592af88bd7e7f45dd80df0ecab375ace}{setWriteTimeout} (int timeout)
\begin{DoxyCompactList}\small\item\em Set the write data timeout. \end{DoxyCompactList}\item 
QQueue$<$ \hyperlink{classmdt_frame_usb_control}{mdtFrameUsbControl} $\ast$ $>$ \& \hyperlink{classmdt_usb_port_af146b08006ddbe18fb537ae1a75b622e}{controlFramesPool} ()
\begin{DoxyCompactList}\small\item\em Get the control pool queue. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_a4fbcd0fcc179335c55c6d7ccc40a7c31}{addControlRequest} (\hyperlink{classmdt_frame_usb_control}{mdtFrameUsbControl} $\ast$frame, bool setwIndexAsbInterfaceNumber=false)
\begin{DoxyCompactList}\small\item\em Add a control request. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_ae79bbc2a33a8cd8f055323d882804d36}{handleControlQueries} ()
\begin{DoxyCompactList}\small\item\em Check about pending control queries and init a new transfer if needed. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a6566e654df8a1c3503941702593db3c5}{cancelControlTransfer} ()
\begin{DoxyCompactList}\small\item\em Cancel current control transfer. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_ac91970d3fcb07b80200d0e549adbab3a}{handleControlResponses} ()
\begin{DoxyCompactList}\small\item\em Check pending control transfer. \end{DoxyCompactList}\item 
QQueue$<$ \hyperlink{classmdt_frame_usb_control}{mdtFrameUsbControl} $\ast$ $>$ \& \hyperlink{classmdt_usb_port_a304825c7d9173a3dcb5e26a412f1038b}{controlResponseFrames} ()
\begin{DoxyCompactList}\small\item\em Get the control responses queue. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a5e380852b8726f71e8558c86cba5bd1f}{initReadTransfer} (qint64 maxSize)
\begin{DoxyCompactList}\small\item\em Request a new bulk/interrupt input transfer. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a3570b708f9f51408e4bbf2f61cc8c881}{cancelReadTransfer} ()
\begin{DoxyCompactList}\small\item\em Cancel current bulk/interrupt input transfer. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_ab8ddd4ebee603ac381e8da0383a61e36}{waitForReadyRead} ()
\begin{DoxyCompactList}\small\item\em Wait until data is available on port. \end{DoxyCompactList}\item 
qint64 \hyperlink{classmdt_usb_port_abce257345c8af47494215cd7ee75f82d}{read} (char $\ast$data, qint64 maxSize)
\begin{DoxyCompactList}\small\item\em Read data from port. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a4e1b2c251dea880f699b6568f7fe7b6b}{initMessageInTransfer} (qint64 maxSize)
\begin{DoxyCompactList}\small\item\em Request a new interrupt input transfer for additional message input. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_afddcb02a1e2bd87609fd2b6305534560}{cancelMessageInTransfer} ()
\begin{DoxyCompactList}\small\item\em Cancel current interrupt message input transfer. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a4bce45f4e7b4cc238b2d68b9f5066f86}{handleMessageIn} ()
\begin{DoxyCompactList}\small\item\em Read message inputs (additional interrupt IN) \end{DoxyCompactList}\item 
QQueue$<$ \hyperlink{classmdt_frame}{mdtFrame} $\ast$ $>$ \& \hyperlink{classmdt_usb_port_a3ad4385983122fcaf6d2560b6bd43acf}{messageInFramesPool} ()
\begin{DoxyCompactList}\small\item\em Get the message IN frames pool. \end{DoxyCompactList}\item 
QQueue$<$ \hyperlink{classmdt_frame}{mdtFrame} $\ast$ $>$ \& \hyperlink{classmdt_usb_port_a3365431076a3197540cbc99278658bda}{messageInFrames} ()
\begin{DoxyCompactList}\small\item\em Get the message IN frames. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a3340dc3f53e857e39053988e4925fc97}{initWriteTransfer} (const char $\ast$data, qint64 maxSize)
\begin{DoxyCompactList}\small\item\em Request a new bulk/interrupt out transfer. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a7cbe1cd3649861aac5e6a14830f06cf9}{cancelWriteTransfer} ()
\begin{DoxyCompactList}\small\item\em Cancel current bulk/interrupt input transfer. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a3be875f6f10ae94fd3a94f925bb935e7}{waitEventWriteReady} ()
\begin{DoxyCompactList}\small\item\em Wait until data can be written to port. \end{DoxyCompactList}\item 
qint64 \hyperlink{classmdt_usb_port_af81c0fc2955ed2778ccdf6c7206f2b16}{write} (const char $\ast$data, qint64 maxSize)
\begin{DoxyCompactList}\small\item\em Write data to port. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_afe5b473e1df8b828c17f83a45a3902fb}{cancelTransfers} ()
\begin{DoxyCompactList}\small\item\em Cancel pending transfers. \end{DoxyCompactList}\item 
\hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{error\_\-t} \hyperlink{classmdt_usb_port_a7f8bf2b599a0c83988153de3945e1d65}{handleUsbEvents} (struct timeval $\ast$timeout)
\begin{DoxyCompactList}\small\item\em Calle libusb handle\_\-event$\ast$() function. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \hyperlink{classmdt_usb_port_ab1d37a64b7b4e471b4b9790e3c25d853}{transferCallback} (struct libusb\_\-transfer $\ast$transfer)
\begin{DoxyCompactList}\small\item\em Transfert callback for asynch I/O. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
USB port I/O port class. 

Built on top of libusb-\/1.x API

Note about the port name (set with \hyperlink{classmdt_abstract_port_a0ca143d32fc677bac7c1cf0e04144932}{setPortName()} ):\par
 Because it can happen that multiple devices with same vendor ID and product ID can be attached to system, this class must provide a unique identifier when (re-\/)open the port. Because of this, the choosen format is: VID=0x1234:PID=0x1234:SID=0x1234:bInterfaceNumber=0. VID is the Vendor ID, PID the Product ID, SID the Serial ID (also called Serial Number) and bInterfaceNumber the interface number (some devices have mor than one interface, f.ex. sound cards, keboard/mouse receiver, ...). SID and bInterfaceNumber are optional. In this case, the first port with given vendor ID and device ID is open. In brief, following names are allowed:
\begin{DoxyItemize}
\item VID=0x1234:PID=0x5678 (Open the first port with given Vendor ID and Product ID. bInterfaceNumber is 0)
\item VID=0x1234:PID=0x5678:SID=ABC1234 (Open the first port with given Vendor ID, Product ID and Serial ID. bInterfaceNumber is 0)
\item VID=0x1234:PID=0x5678:bInterfaceNumber=1 (Open the first port with given Vendor ID and Product ID. bInterfaceNumber is 1)
\item VID=0x1234:PID=0x5678:SID=ABC1234:bInterfaceNumber=1 (Open the first port with given Vendor ID, Product ID and Serial ID. bInterfaceNumber is 1) The last example in the above list is the format returned by \hyperlink{classmdt_usb_port_manager_a3a2370c3a2d0353a880bf9b777728c3b}{mdtUsbPortManager::scan()}.
\end{DoxyItemize}

For read and write of data, the mdtAbstractPort's API is used.

The control transfer is a little bit different:
\begin{DoxyItemize}
\item If the main thread (f.ex. GUI thread) wants to send a request, it locks the mutex using \hyperlink{classmdt_abstract_port_a6bf2ecdcf894da3929a22eb8793a9fe3}{lockMutex()}, then it takes a frame in pool with \hyperlink{classmdt_usb_port_af146b08006ddbe18fb537ae1a75b622e}{controlFramesPool()}. Finaly, query is submitted using \hyperlink{classmdt_usb_port_a4fbcd0fcc179335c55c6d7ccc40a7c31}{addControlRequest()}, witch will wake the write wait condition, and main thread unlocks the mutex with \hyperlink{classmdt_abstract_port_a3523c72a06e4d950338f91e56c286e84}{unlockMutex()}.
\item The thread calls \hyperlink{classmdt_usb_port_ae79bbc2a33a8cd8f055323d882804d36}{handleControlQueries()} periodically, witch will init a new control transfer if a query is available in queries queue.
\item Each time \hyperlink{classmdt_usb_port_a3be875f6f10ae94fd3a94f925bb935e7}{waitEventWriteReady()} and \hyperlink{classmdt_usb_port_ab8ddd4ebee603ac381e8da0383a61e36}{waitForReadyRead()} are called, \hyperlink{classmdt_usb_port_ac91970d3fcb07b80200d0e549adbab3a}{handleControlResponses()} is called to check if a control response is available. If true, it will be enqueued in control responses queue.
\item The thread periodically checks if a response is available using \hyperlink{classmdt_usb_port_a304825c7d9173a3dcb5e26a412f1038b}{controlResponseFrames()} queue's size, and emit\begin{Desc}
\item[\hyperlink{todo__todo000045}{Todo}]signalName if a control response is available.\end{Desc}

\end{DoxyItemize}

If a additional (to read and write) interrupt IN endpoint exists, it is handled as message IN as follow:
\begin{DoxyItemize}
\item Each time \hyperlink{classmdt_usb_port_a3be875f6f10ae94fd3a94f925bb935e7}{waitEventWriteReady()} or \hyperlink{classmdt_usb_port_ab8ddd4ebee603ac381e8da0383a61e36}{waitForReadyRead()} is called, \hyperlink{classmdt_usb_port_a4bce45f4e7b4cc238b2d68b9f5066f86}{handleMessageIn()} is called, witch will initiate a new transfer if needed. If a transfer is complete, frame will be enqueued in message IN queue.
\item The thread periodically checks if a message IN is available using \hyperlink{classmdt_usb_port_a3365431076a3197540cbc99278658bda}{messageInFrames()} queue's size, and emit\begin{Desc}
\item[\hyperlink{todo__todo000046}{Todo}]signalName if a message IN is available. \end{Desc}

\end{DoxyItemize}

Definition at line 70 of file mdtUsbPort.h.



\subsection{Member Function Documentation}
\hypertarget{classmdt_usb_port_a4fbcd0fcc179335c55c6d7ccc40a7c31}{
\index{mdtUsbPort@{mdtUsbPort}!addControlRequest@{addControlRequest}}
\index{addControlRequest@{addControlRequest}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{addControlRequest}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::addControlRequest (
\begin{DoxyParamCaption}
\item[{{\bf mdtFrameUsbControl} $\ast$}]{frame, }
\item[{bool}]{setwIndexAsbInterfaceNumber = {\ttfamily false}}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a4fbcd0fcc179335c55c6d7ccc40a7c31}


Add a control request. 

Once the frame is added to the control queries queue, waiting thread will be woken up (if waiting) and will send the frame.

The mutex must be locked before calling this method, and still locked inside.


\begin{DoxyParams}{Parameters}
{\em frame} & Control frame \\
\hline
{\em setwIndexAsbInterfaceNumber} & If true, wIndex will be set with current bInterfaceNumber\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
frame must be a valid pointer. 
\end{DoxyPrecond}


Definition at line 139 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a6566e654df8a1c3503941702593db3c5}{
\index{mdtUsbPort@{mdtUsbPort}!cancelControlTransfer@{cancelControlTransfer}}
\index{cancelControlTransfer@{cancelControlTransfer}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{cancelControlTransfer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::cancelControlTransfer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a6566e654df8a1c3503941702593db3c5}


Cancel current control transfer. 

If a control transfer is pending it will be cancelled.

Mutex is not handled by this method. 

Definition at line 206 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_afddcb02a1e2bd87609fd2b6305534560}{
\index{mdtUsbPort@{mdtUsbPort}!cancelMessageInTransfer@{cancelMessageInTransfer}}
\index{cancelMessageInTransfer@{cancelMessageInTransfer}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{cancelMessageInTransfer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::cancelMessageInTransfer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_afddcb02a1e2bd87609fd2b6305534560}


Cancel current interrupt message input transfer. 

If a input message transfer is pending it will be cancelled.

Mutex is not handled by this method. 

Definition at line 550 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a3570b708f9f51408e4bbf2f61cc8c881}{
\index{mdtUsbPort@{mdtUsbPort}!cancelReadTransfer@{cancelReadTransfer}}
\index{cancelReadTransfer@{cancelReadTransfer}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{cancelReadTransfer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::cancelReadTransfer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a3570b708f9f51408e4bbf2f61cc8c881}


Cancel current bulk/interrupt input transfer. 

If a input transfer is pending it will be cancelled.

Mutex is not handled by this method. 

Definition at line 383 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_afe5b473e1df8b828c17f83a45a3902fb}{
\index{mdtUsbPort@{mdtUsbPort}!cancelTransfers@{cancelTransfers}}
\index{cancelTransfers@{cancelTransfers}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{cancelTransfers}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::cancelTransfers (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_afe5b473e1df8b828c17f83a45a3902fb}


Cancel pending transfers. 

Will call \hyperlink{classmdt_usb_port_a3570b708f9f51408e4bbf2f61cc8c881}{cancelReadTransfer()} , \hyperlink{classmdt_usb_port_a3570b708f9f51408e4bbf2f61cc8c881}{cancelReadTransfer()}.

This method locks the mutex. 

Definition at line 880 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a7cbe1cd3649861aac5e6a14830f06cf9}{
\index{mdtUsbPort@{mdtUsbPort}!cancelWriteTransfer@{cancelWriteTransfer}}
\index{cancelWriteTransfer@{cancelWriteTransfer}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{cancelWriteTransfer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::cancelWriteTransfer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a7cbe1cd3649861aac5e6a14830f06cf9}


Cancel current bulk/interrupt input transfer. 

If a input transfer is pending it will be cancelled.

Mutex is not handled by this method. 

Definition at line 727 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_af146b08006ddbe18fb537ae1a75b622e}{
\index{mdtUsbPort@{mdtUsbPort}!controlFramesPool@{controlFramesPool}}
\index{controlFramesPool@{controlFramesPool}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{controlFramesPool}]{\setlength{\rightskip}{0pt plus 5cm}QQueue$<$ {\bf mdtFrameUsbControl} $\ast$ $>$ \& mdtUsbPort::controlFramesPool (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_af146b08006ddbe18fb537ae1a75b622e}


Get the control pool queue. 

This queue contains the pool of control frames.

Mutex is not handled by this method. 

Definition at line 151 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a304825c7d9173a3dcb5e26a412f1038b}{
\index{mdtUsbPort@{mdtUsbPort}!controlResponseFrames@{controlResponseFrames}}
\index{controlResponseFrames@{controlResponseFrames}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{controlResponseFrames}]{\setlength{\rightskip}{0pt plus 5cm}QQueue$<$ {\bf mdtFrameUsbControl} $\ast$ $>$ \& mdtUsbPort::controlResponseFrames (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a304825c7d9173a3dcb5e26a412f1038b}


Get the control responses queue. 

This queue contains the response frames returned from device.

Mutex is not handled by this method. 

Definition at line 330 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_ae79bbc2a33a8cd8f055323d882804d36}{
\index{mdtUsbPort@{mdtUsbPort}!handleControlQueries@{handleControlQueries}}
\index{handleControlQueries@{handleControlQueries}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{handleControlQueries}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::handleControlQueries (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_ae79bbc2a33a8cd8f055323d882804d36}


Check about pending control queries and init a new transfer if needed. 

If a frame is available in control query queue, a transfer will be initialized and submitted to libusb.

The thread can call this method periodically. If nothing is to do, it will simply return NoError.

The mutex must be locked before calling this method, and still locked inside. 

Definition at line 156 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_ac91970d3fcb07b80200d0e549adbab3a}{
\index{mdtUsbPort@{mdtUsbPort}!handleControlResponses@{handleControlResponses}}
\index{handleControlResponses@{handleControlResponses}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{handleControlResponses}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::handleControlResponses (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_ac91970d3fcb07b80200d0e549adbab3a}


Check pending control transfer. 

If a control transfer is pending, complete flag will be checked. If transfer is complete, some flags are checked, and frame is enqueued in response queue if Ok.

This method is called by \hyperlink{classmdt_usb_port_a3be875f6f10ae94fd3a94f925bb935e7}{waitEventWriteReady()} and \hyperlink{classmdt_usb_port_ab8ddd4ebee603ac381e8da0383a61e36}{waitForReadyRead()}, witch are called from port thread.

Mutex is not handled by this method. 

Definition at line 235 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a4bce45f4e7b4cc238b2d68b9f5066f86}{
\index{mdtUsbPort@{mdtUsbPort}!handleMessageIn@{handleMessageIn}}
\index{handleMessageIn@{handleMessageIn}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{handleMessageIn}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::handleMessageIn (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a4bce45f4e7b4cc238b2d68b9f5066f86}


Read message inputs (additional interrupt IN) 

This method is called from \hyperlink{classmdt_usb_port_thread}{mdtUsbPortThread} , and should not be used directly.

This method differs from \hyperlink{classmdt_usb_port_abce257345c8af47494215cd7ee75f82d}{read()} and \hyperlink{classmdt_usb_port_af81c0fc2955ed2778ccdf6c7206f2b16}{write()}. It will automatically init a message IN transfer if additional interrupt IN is used, and no transfer is pending. There is no wait method associated to additional interrupt IN, it will be complete during \hyperlink{classmdt_usb_port_a3be875f6f10ae94fd3a94f925bb935e7}{waitEventWriteReady()} or \hyperlink{classmdt_usb_port_ab8ddd4ebee603ac381e8da0383a61e36}{waitForReadyRead()}.qint64 readMessageIn(char $\ast$data, qint64 maxSize);

Handle message IN

Will init a new message IN transfer if needed. If one is pending, it will check about its completion, and enqueue the data to message IN frames queue if complete. 

Definition at line 579 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a7f8bf2b599a0c83988153de3945e1d65}{
\index{mdtUsbPort@{mdtUsbPort}!handleUsbEvents@{handleUsbEvents}}
\index{handleUsbEvents@{handleUsbEvents}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{handleUsbEvents}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::handleUsbEvents (
\begin{DoxyParamCaption}
\item[{struct timeval $\ast$}]{timeout}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a7f8bf2b599a0c83988153de3945e1d65}


Calle libusb handle\_\-event$\ast$() function. 

Notes: must be called only by I/O thread (typically \hyperlink{classmdt_usb_port_thread}{mdtUsbPortThread}). This method unlocks the mutex during wait (must be locked by call, is locked again before return)


\begin{DoxyParams}{Parameters}
{\em timeout} & Wait timeout. If null, the port's internal devined read timeout is used. \\
\hline
\end{DoxyParams}


Definition at line 910 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a4e1b2c251dea880f699b6568f7fe7b6b}{
\index{mdtUsbPort@{mdtUsbPort}!initMessageInTransfer@{initMessageInTransfer}}
\index{initMessageInTransfer@{initMessageInTransfer}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{initMessageInTransfer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::initMessageInTransfer (
\begin{DoxyParamCaption}
\item[{qint64}]{maxSize}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a4e1b2c251dea880f699b6568f7fe7b6b}


Request a new interrupt input transfer for additional message input. 

Will fill and init a new interrupt transfer and submit it to libusb. 

\begin{Desc}
\item[\hyperlink{todo__todo000041}{Todo}]Handle retval \end{Desc}




Definition at line 512 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a5e380852b8726f71e8558c86cba5bd1f}{
\index{mdtUsbPort@{mdtUsbPort}!initReadTransfer@{initReadTransfer}}
\index{initReadTransfer@{initReadTransfer}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{initReadTransfer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::initReadTransfer (
\begin{DoxyParamCaption}
\item[{qint64}]{maxSize}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a5e380852b8726f71e8558c86cba5bd1f}


Request a new bulk/interrupt input transfer. 

Will fill and init a new bulk/interrupt (depending setup) transfer and submit it to libusb. 

\begin{Desc}
\item[\hyperlink{todo__todo000040}{Todo}]Handle retval \end{Desc}




Definition at line 335 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a3340dc3f53e857e39053988e4925fc97}{
\index{mdtUsbPort@{mdtUsbPort}!initWriteTransfer@{initWriteTransfer}}
\index{initWriteTransfer@{initWriteTransfer}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{initWriteTransfer}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::initWriteTransfer (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{data, }
\item[{qint64}]{maxSize}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a3340dc3f53e857e39053988e4925fc97}


Request a new bulk/interrupt out transfer. 

Will fill and init a new bulk/interrupt (depending setup) transfer and submit it to libusb. 

Definition at line 676 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a3365431076a3197540cbc99278658bda}{
\index{mdtUsbPort@{mdtUsbPort}!messageInFrames@{messageInFrames}}
\index{messageInFrames@{messageInFrames}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{messageInFrames}]{\setlength{\rightskip}{0pt plus 5cm}QQueue$<$ {\bf mdtFrame} $\ast$ $>$ \& mdtUsbPort::messageInFrames (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a3365431076a3197540cbc99278658bda}


Get the message IN frames. 

This queue contains the message IN frames.

Mutex is not handled by this method. 

Definition at line 671 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a3ad4385983122fcaf6d2560b6bd43acf}{
\index{mdtUsbPort@{mdtUsbPort}!messageInFramesPool@{messageInFramesPool}}
\index{messageInFramesPool@{messageInFramesPool}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{messageInFramesPool}]{\setlength{\rightskip}{0pt plus 5cm}QQueue$<$ {\bf mdtFrame} $\ast$ $>$ \& mdtUsbPort::messageInFramesPool (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_a3ad4385983122fcaf6d2560b6bd43acf}


Get the message IN frames pool. 

This queue contains the pool of message IN frames.

Mutex is not handled by this method. 

Definition at line 666 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_abce257345c8af47494215cd7ee75f82d}{
\index{mdtUsbPort@{mdtUsbPort}!read@{read}}
\index{read@{read}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}qint64 mdtUsbPort::read (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{data, }
\item[{qint64}]{maxSize}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_abce257345c8af47494215cd7ee75f82d}


Read data from port. 

This method is called from \hyperlink{classmdt_usb_port_thread}{mdtUsbPortThread} , and should not be used directly.

Mutex is not handled by this method.

\begin{DoxyPrecond}{Precondition}
A transfert must be initialized with \hyperlink{classmdt_usb_port_a5e380852b8726f71e8558c86cba5bd1f}{initReadTransfer()} before using this method. 
\end{DoxyPrecond}


Implements \hyperlink{classmdt_abstract_port_a9d9c45220d5328c9856a2445557fe970}{mdtAbstractPort}.



Definition at line 491 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_af2399348faf1abc20130eab20cfc36ee}{
\index{mdtUsbPort@{mdtUsbPort}!reconnect@{reconnect}}
\index{reconnect@{reconnect}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{reconnect}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::reconnect (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_af2399348faf1abc20130eab20cfc36ee}


Reconnect device. 

If one of the method returns a Disconnected error, the thread will call this method to try to reconnect.


\begin{DoxyParams}{Parameters}
{\em timeout} & Timeout \mbox{[}ms\mbox{]} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
NoError if connection could be done. Disconnected if connection could not be done, in wich case the thread will retry (until max retry). A UnhandledError can be returned. 
\end{DoxyReturn}


Reimplemented from \hyperlink{classmdt_abstract_port_aec74b2db1a629d98a95d8f042ea96653}{mdtAbstractPort}.



Definition at line 88 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a44ed5024a81a573b5196b8f64c42cd6a}{
\index{mdtUsbPort@{mdtUsbPort}!setReadTimeout@{setReadTimeout}}
\index{setReadTimeout@{setReadTimeout}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{setReadTimeout}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::setReadTimeout (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_a44ed5024a81a573b5196b8f64c42cd6a}


Set the read data timeout. 

The mutex is not handled by this method. 

Implements \hyperlink{classmdt_abstract_port_a6589b04467e0073d18ba872201bdcd84}{mdtAbstractPort}.



Definition at line 113 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a592af88bd7e7f45dd80df0ecab375ace}{
\index{mdtUsbPort@{mdtUsbPort}!setWriteTimeout@{setWriteTimeout}}
\index{setWriteTimeout@{setWriteTimeout}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{setWriteTimeout}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::setWriteTimeout (
\begin{DoxyParamCaption}
\item[{int}]{timeout}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_a592af88bd7e7f45dd80df0ecab375ace}


Set the write data timeout. 

The mutex is not handled by this method. 

Implements \hyperlink{classmdt_abstract_port_a12eb422d52ebb09a650f8497b258c2e7}{mdtAbstractPort}.



Definition at line 126 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_ab1d37a64b7b4e471b4b9790e3c25d853}{
\index{mdtUsbPort@{mdtUsbPort}!transferCallback@{transferCallback}}
\index{transferCallback@{transferCallback}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{transferCallback}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPort::transferCallback (
\begin{DoxyParamCaption}
\item[{struct libusb\_\-transfer $\ast$}]{transfer}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{classmdt_usb_port_ab1d37a64b7b4e471b4b9790e3c25d853}


Transfert callback for asynch I/O. 



mdt\_\-usb\_\-port\_\-transfer\_\-data $\ast$data = (mdt\_\-usb\_\-port\_\-transfer\_\-data$\ast$)transfer-\/$>$user\_\-data; Q\_\-ASSERT(data != 0); data-\/$>$flag1 = transfer-\/$>$status;



Definition at line 853 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_a3be875f6f10ae94fd3a94f925bb935e7}{
\index{mdtUsbPort@{mdtUsbPort}!waitEventWriteReady@{waitEventWriteReady}}
\index{waitEventWriteReady@{waitEventWriteReady}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{waitEventWriteReady}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::waitEventWriteReady (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_a3be875f6f10ae94fd3a94f925bb935e7}


Wait until data can be written to port. 

This method is called from \hyperlink{classmdt_port_write_thread}{mdtPortWriteThread} , and should not be used directly.\par
 Mutex must be locked before calling this method with \hyperlink{classmdt_abstract_port_a6bf2ecdcf894da3929a22eb8793a9fe3}{lockMutex()}. The mutex is locked when method returns. 

Implements \hyperlink{classmdt_abstract_port_a35e4686f50e2c53c7e3618cf2c485d92}{mdtAbstractPort}.



Definition at line 757 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_ab8ddd4ebee603ac381e8da0383a61e36}{
\index{mdtUsbPort@{mdtUsbPort}!waitForReadyRead@{waitForReadyRead}}
\index{waitForReadyRead@{waitForReadyRead}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{waitForReadyRead}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mdtAbstractPort::error\_\-t} mdtUsbPort::waitForReadyRead (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_ab8ddd4ebee603ac381e8da0383a61e36}


Wait until data is available on port. 

This method is called from \hyperlink{classmdt_port_read_thread}{mdtPortReadThread} , and should not be used directly.\par
 Mutex must be locked before calling this method with \hyperlink{classmdt_abstract_port_a6bf2ecdcf894da3929a22eb8793a9fe3}{lockMutex()}. The mutex is locked when method returns. 

Implements \hyperlink{classmdt_abstract_port_aeda364cb191da1038a22dd1fc06a1d49}{mdtAbstractPort}.



Definition at line 413 of file mdtUsbPort.cpp.

\hypertarget{classmdt_usb_port_af81c0fc2955ed2778ccdf6c7206f2b16}{
\index{mdtUsbPort@{mdtUsbPort}!write@{write}}
\index{write@{write}!mdtUsbPort@{mdtUsbPort}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}qint64 mdtUsbPort::write (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{data, }
\item[{qint64}]{maxSize}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_af81c0fc2955ed2778ccdf6c7206f2b16}


Write data to port. 

This method is called from \hyperlink{classmdt_port_write_thread}{mdtPortWriteThread} , and should not be used directly.

Mutex is not handled by this method. 

Implements \hyperlink{classmdt_abstract_port_a64d4802975a76474b9196c91f57a6d90}{mdtAbstractPort}.



Definition at line 834 of file mdtUsbPort.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtUsbPort.h\item 
src/mdtport/mdtUsbPort.cpp\end{DoxyCompactItemize}
