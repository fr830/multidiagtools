\hypertarget{classmdt_usb_port_manager}{
\section{mdtUsbPortManager Class Reference}
\label{classmdt_usb_port_manager}\index{mdtUsbPortManager@{mdtUsbPortManager}}
}


Helper class that simplify access to USB port API.  




{\ttfamily \#include $<$mdtUsbPortManager.h$>$}



Inheritance diagram for mdtUsbPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=202pt]{classmdt_usb_port_manager__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtUsbPortManager:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{classmdt_usb_port_manager__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Slots}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_usb_port_manager_af043c75c74665b23d13f3cb73150935c}{fromThreadControlResponseReaden} ()
\begin{DoxyCompactList}\small\item\em Called from USB thread when a control reply was received. \end{DoxyCompactList}\item 
\hypertarget{classmdt_usb_port_manager_a9b7154590a4eb267aff4e11ba53dd7aa}{
void \hyperlink{classmdt_usb_port_manager_a9b7154590a4eb267aff4e11ba53dd7aa}{fromThreadMessageInReaden} ()}
\label{classmdt_usb_port_manager_a9b7154590a4eb267aff4e11ba53dd7aa}

\begin{DoxyCompactList}\small\item\em Called from USB thread when a message IN was received ( on additionnal interrupt IN endpoint). \end{DoxyCompactList}\item 
\hypertarget{classmdt_usb_port_manager_a8f53dc5445b7f8f4a077f3cc25880b5d}{
void \hyperlink{classmdt_usb_port_manager_a8f53dc5445b7f8f4a077f3cc25880b5d}{fromThreadReadUntilShortPacketReceivedFinished} ()}
\label{classmdt_usb_port_manager_a8f53dc5445b7f8f4a077f3cc25880b5d}

\begin{DoxyCompactList}\small\item\em Called by thread when the read until a short packet process is finished. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_usb_port_manager_a7f82574e84d0a99d1c8bef7fd79283e3}{mdtUsbPortManager} (QObject $\ast$parent=0)
\begin{DoxyCompactList}\small\item\em Contruct a USB port manager. \end{DoxyCompactList}\item 
virtual \hyperlink{classmdt_usb_port_manager_ac0da1cf62e664b78fe91b873da5835ce}{$\sim$mdtUsbPortManager} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
virtual QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_usb_port_manager_a3a2370c3a2d0353a880bf9b777728c3b}{scan} ()
\begin{DoxyCompactList}\small\item\em Get a list of attached USB devices. \end{DoxyCompactList}\item 
QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_usb_port_manager_ab28253c46c80bb12cbbd116b05c4bcd3}{scan} (int bDeviceClass, int bDeviceSubClass, int bDeviceProtocol)
\begin{DoxyCompactList}\small\item\em Get a list of attached USB devices. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_usb_port_manager_ac656805c6de08c9c6a2487291cf3f347}{start} ()
\begin{DoxyCompactList}\small\item\em Open the port. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_manager_adff8a1f8ed2b0e68229e2016c75e04a6}{readUntilShortPacketReceived} ()
\begin{DoxyCompactList}\small\item\em Check if port manager is ready. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_usb_port_manager_aea4a67550effcba13acfc110d6d30c3e}{sendControlRequest} (const \hyperlink{classmdt_frame_usb_control}{mdtFrameUsbControl} \&request, bool setwIndexAsbInterfaceNumber=false)
\begin{DoxyCompactList}\small\item\em Send a control request by copy. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_usb_port_manager_a34bf0ac118e586bf2547a98964a2230c}{waitReadenControlResponse} ()
\begin{DoxyCompactList}\small\item\em Wait until a control response is readen. \end{DoxyCompactList}\item 
QList$<$ \hyperlink{classmdt_frame_usb_control}{mdtFrameUsbControl} $>$ \hyperlink{classmdt_usb_port_manager_a84c26fee7dfb26290659aa002e0842c6}{readenControlResponses} ()
\begin{DoxyCompactList}\small\item\em Get all readen control responses. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_manager_a982256ed17db155e1c95d544683a6dba}{flushIn} (bool flushPortManagerBuffers, bool flushPortBuffers)
\begin{DoxyCompactList}\small\item\em Flush input buffers. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_usb_port_manager_ab723086376175c40635df44adf358985}{flushOut} (bool flushPortManagerBuffers, bool flushPortBuffers)
\begin{DoxyCompactList}\small\item\em Flush output buffers. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Slots}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_usb_port_manager_ad6cbef2c218efe73fdad6d5f598f743f}{onThreadsErrorOccured} (int error)
\begin{DoxyCompactList}\small\item\em Manage errors comming from usb port thread. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Helper class that simplify access to USB port API. 

Based on \hyperlink{classmdt_port_manager}{mdtPortManager}, some USB specific methods are added. The internal configuration (a \hyperlink{classmdt_port_config}{mdtPortConfig} object) is keeped default. 

Definition at line 33 of file mdtUsbPortManager.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_usb_port_manager_a7f82574e84d0a99d1c8bef7fd79283e3}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!mdtUsbPortManager@{mdtUsbPortManager}}
\index{mdtUsbPortManager@{mdtUsbPortManager}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{mdtUsbPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtUsbPortManager::mdtUsbPortManager (
\begin{DoxyParamCaption}
\item[{QObject $\ast$}]{parent = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_manager_a7f82574e84d0a99d1c8bef7fd79283e3}


Contruct a USB port manager. 

Will create \hyperlink{classmdt_usb_port}{mdtUsbPort} and setup. Thread will be created at first call of \hyperlink{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{openPort()}. 

pvReadUntilShortPacketReceivedFinished = false; 



Definition at line 34 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_ac0da1cf62e664b78fe91b873da5835ce}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!$\sim$mdtUsbPortManager@{$\sim$mdtUsbPortManager}}
\index{$\sim$mdtUsbPortManager@{$\sim$mdtUsbPortManager}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{$\sim$mdtUsbPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtUsbPortManager::$\sim$mdtUsbPortManager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_manager_ac0da1cf62e664b78fe91b873da5835ce}


Destructor. 

Stop the manager (if running), and close the port (if open). All internal objects (port, config and threads) are deleted here. 

Definition at line 47 of file mdtUsbPortManager.cpp.



\subsection{Member Function Documentation}
\hypertarget{classmdt_usb_port_manager_a982256ed17db155e1c95d544683a6dba}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!flushIn@{flushIn}}
\index{flushIn@{flushIn}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{flushIn}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPortManager::flushIn (
\begin{DoxyParamCaption}
\item[{bool}]{flushPortManagerBuffers, }
\item[{bool}]{flushPortBuffers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_manager_a982256ed17db155e1c95d544683a6dba}


Flush input buffers. 


\begin{DoxyParams}{Parameters}
{\em flushPortManagerBuffers} & If true, port manager buffers will be cleared. \\
\hline
{\em flushPortBuffers} & If true, port's buffers will be cleared. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before calling this method. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_port_manager_ac0844a5cd4043a95a479d458ac7ce590}{mdtPortManager}.



Definition at line 342 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_ab723086376175c40635df44adf358985}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!flushOut@{flushOut}}
\index{flushOut@{flushOut}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{flushOut}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPortManager::flushOut (
\begin{DoxyParamCaption}
\item[{bool}]{flushPortManagerBuffers, }
\item[{bool}]{flushPortBuffers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_manager_ab723086376175c40635df44adf358985}


Flush output buffers. 


\begin{DoxyParams}{Parameters}
{\em flushPortManagerBuffers} & If true, port manager buffers will be cleared. (Has no effect in this implementation, but some subclass can have output buffers). \\
\hline
{\em flushPortBuffers} & If true, port's buffers will be cleared. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before calling this method. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_port_manager_a3f0c2722a41c49de2bea9013bccd049c}{mdtPortManager}.



Definition at line 353 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_af043c75c74665b23d13f3cb73150935c}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!fromThreadControlResponseReaden@{fromThreadControlResponseReaden}}
\index{fromThreadControlResponseReaden@{fromThreadControlResponseReaden}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{fromThreadControlResponseReaden}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPortManager::fromThreadControlResponseReaden (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}slot\mbox{]}}}}
\label{classmdt_usb_port_manager_af043c75c74665b23d13f3cb73150935c}


Called from USB thread when a control reply was received. 

Will add a copy of received control responses to internal queue and restore frame back to port's pool. 

Definition at line 360 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_ad6cbef2c218efe73fdad6d5f598f743f}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!onThreadsErrorOccured@{onThreadsErrorOccured}}
\index{onThreadsErrorOccured@{onThreadsErrorOccured}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{onThreadsErrorOccured}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPortManager::onThreadsErrorOccured (
\begin{DoxyParamCaption}
\item[{int}]{error}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual, slot\mbox{]}}}}
\label{classmdt_usb_port_manager_ad6cbef2c218efe73fdad6d5f598f743f}


Manage errors comming from usb port thread. 

This implementation will handle some USB specific errors, change the current state emiting transistion signal. If state has changed, \hyperlink{classmdt_port_manager_a01da0634bc52a71c0df0d83fc166eeda}{stateChanged()} signal is emited.

Some errors are handled here. For others, \hyperlink{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}{mdtPortManager::onThreadsErrorOccured()} is called. 

emit(handledError());

emit(busy()); 



Reimplemented from \hyperlink{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}{mdtPortManager}.



Definition at line 405 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_a84c26fee7dfb26290659aa002e0842c6}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!readenControlResponses@{readenControlResponses}}
\index{readenControlResponses@{readenControlResponses}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{readenControlResponses}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtFrameUsbControl} $>$ mdtUsbPortManager::readenControlResponses (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_manager_a84c26fee7dfb26290659aa002e0842c6}


Get all readen control responses. 

Note that calling this methode will clear the internal queue. (A second call will return a empty list). 

Definition at line 332 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_adff8a1f8ed2b0e68229e2016c75e04a6}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!readUntilShortPacketReceived@{readUntilShortPacketReceived}}
\index{readUntilShortPacketReceived@{readUntilShortPacketReceived}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{readUntilShortPacketReceived}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbPortManager::readUntilShortPacketReceived (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_manager_adff8a1f8ed2b0e68229e2016c75e04a6}


Check if port manager is ready. 

Because \hyperlink{classmdt_usb_port_manager}{mdtUsbPortManager} is a base class, it acts like \hyperlink{classmdt_port_manager_a6dc2798324521d177fb8f79d4f6c5f0f}{mdtPortManager::isReady()} . A specific subclass (like \hyperlink{classmdt_usbtmc_port_manager}{mdtUsbtmcPortManager} will reimplement \hyperlink{classmdt_port_manager_a6dc2798324521d177fb8f79d4f6c5f0f}{isReady()} ).

Request port to read until a short frame is received

This is, for example, used by USBTMC bulk in abort process. If such request is pending, thread will read until a short frame is received.

Will send the request and wait until it is finished (will not break GUI event loop).

\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} with a \hyperlink{classmdt_usb_port}{mdtUsbPort} (or subclass) before use of this method. 
\end{DoxyPrecond}


msleep(50); Q\_\-ASSERT(pvPort != 0); qApp-\/$>$processEvents();



Definition at line 206 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_ab28253c46c80bb12cbbd116b05c4bcd3}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!scan@{scan}}
\index{scan@{scan}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtUsbPortManager::scan (
\begin{DoxyParamCaption}
\item[{int}]{bDeviceClass, }
\item[{int}]{bDeviceSubClass, }
\item[{int}]{bDeviceProtocol}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_manager_ab28253c46c80bb12cbbd116b05c4bcd3}


Get a list of attached USB devices. 

Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).


\begin{DoxyParams}{Parameters}
{\em bDeviceClass} & If $>$= 0, only devices with matching bDeviceClass are listed \\
\hline
{\em bDeviceSubClass} & If $>$= 0, only devices with matching bDeviceSubClass are listed \\
\hline
{\em bDeviceProtocol} & If $>$= 0, only devices with matching bDeviceProtocol are listed\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Port manager must be closed 
\end{DoxyPrecond}


Definition at line 63 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_a3a2370c3a2d0353a880bf9b777728c3b}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!scan@{scan}}
\index{scan@{scan}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtUsbPortManager::scan (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_manager_a3a2370c3a2d0353a880bf9b777728c3b}


Get a list of attached USB devices. 

Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).

\begin{DoxyPrecond}{Precondition}
Port manager must be closed 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_port_manager_ad56afb411ab5468005fca04767557ece}{mdtPortManager}.



Reimplemented in \hyperlink{classmdt_usbtmc_port_manager_a992d1227810186d3c7dc166452e2e3b6}{mdtUsbtmcPortManager}.



Definition at line 56 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_aea4a67550effcba13acfc110d6d30c3e}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!sendControlRequest@{sendControlRequest}}
\index{sendControlRequest@{sendControlRequest}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{sendControlRequest}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbPortManager::sendControlRequest (
\begin{DoxyParamCaption}
\item[{const {\bf mdtFrameUsbControl} \&}]{request, }
\item[{bool}]{setwIndexAsbInterfaceNumber = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_manager_aea4a67550effcba13acfc110d6d30c3e}


Send a control request by copy. 

Request will be passed to the mdtPort's control request queue by copy. This method returns immediatly after enqueue, and don't wait until data was written.


\begin{DoxyParams}{Parameters}
{\em frame} & Frame containing request to send. \\
\hline
{\em setwIndexAsbInterfaceNumber} & If true, wIndex will be set with USB port's current bInterfaceNumber \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success or value $<$ 0 on error. In this implementation, the only possible error is mdtAbstractPort::WriteQueueEmpty . Some subclass can return a frame ID on success, or a other error. See subclass documentation for details. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} with a \hyperlink{classmdt_usb_port}{mdtUsbPort} (or subclass) before use of this method.
\end{DoxyPrecond}
Subclass notes:\par
 This method can be reimplemented in subclass if needed. Typically usefull if a frame ID must be generated for each request (f.ex. bTag on USBTMC). A frame must be taken from port's request frames pool with mdtAbstractPort::controlFramesPool() dequeue() method (see Qt's QQueue documentation for more details on dequeue() ), then added to port's request queue with mdtAbstractPort::addControlRequest() . If protocol supports frame identification (like USBTMC's bTag), it should be returned here and incremented. 

\hyperlink{classmdt_port_manager_a3107b7121dfe5b9686d9b3b3a48a0af0}{lockPortMutex()}; if(port-\/$>$controlFramesPool().size() $<$ 1)\{ \hyperlink{classmdt_port_manager_a882e6bf95dac9cd4ab8cc93ecc524874}{unlockPortMutex()}; \hyperlink{classmdt_error}{mdtError} e(MDT\_\-PORT\_\-IO\_\-ERROR, \char`\"{}No frame available in control frames pool\char`\"{}, mdtError::Error); MDT\_\-ERROR\_\-SET\_\-SRC(e, \char`\"{}mdtUsbPortManager\char`\"{}); e.commit(); return \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85ea823db75227ad56b6aa74ea2f160c0693}{mdtAbstractPort::WritePoolEmpty}; \}



Definition at line 236 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_ac656805c6de08c9c6a2487291cf3f347}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!start@{start}}
\index{start@{start}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{start}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtUsbPortManager::start (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usb_port_manager_ac656805c6de08c9c6a2487291cf3f347}


Open the port. 

Overloads \hyperlink{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{mdtPortManager::start()}.

Will construct the thread if not allready exists. This is because \hyperlink{classmdt_usbtmc_port_manager}{mdtUsbtmcPortManager} uses a different thread, so this task can not be done in constructor.

Internally, \hyperlink{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{mdtPortManager::start()} is called. 

connect(portThread, SIGNAL(messageInReaden()), this, SLOT(\hyperlink{classmdt_usb_port_manager_a9b7154590a4eb267aff4e11ba53dd7aa}{fromThreadMessageInReaden()})); connect(portThread, SIGNAL(readUntilShortPacketReceivedFinished()), this, SLOT(\hyperlink{classmdt_usb_port_manager_a8f53dc5445b7f8f4a077f3cc25880b5d}{fromThreadReadUntilShortPacketReceivedFinished()})); 



Reimplemented from \hyperlink{classmdt_port_manager_af1fb103ffafc227337a59c7e82f44fbc}{mdtPortManager}.



Definition at line 181 of file mdtUsbPortManager.cpp.

\hypertarget{classmdt_usb_port_manager_a34bf0ac118e586bf2547a98964a2230c}{
\index{mdtUsbPortManager@{mdtUsbPortManager}!waitReadenControlResponse@{waitReadenControlResponse}}
\index{waitReadenControlResponse@{waitReadenControlResponse}!mdtUsbPortManager@{mdtUsbPortManager}}
\subsubsection[{waitReadenControlResponse}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtUsbPortManager::waitReadenControlResponse (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usb_port_manager_a34bf0ac118e586bf2547a98964a2230c}


Wait until a control response is readen. 

This method will return when a control response was readen.

Internally, a couple of sleep and process event are called, so Qt's event loop will not be broken.

This method can return if timeout occurs, or for other reason depending on specific port (port timeout, read canceled, ...).

\begin{DoxyReturn}{Returns}
True if Ok, false on timeout
\end{DoxyReturn}
\begin{Desc}
\item[\hyperlink{todo__todo000040}{Todo}]Adapt using internal timeouts + errors system \end{Desc}


int maxIter;

if(timeout == 0)\{ timeout = adjustedReadTimeout(timeout, false); \}else\{ timeout = adjustedReadTimeout(timeout); \} maxIter = timeout / 50;

if(readWaitCanceled())\{ return false; \}

if(maxIter $<$= 0)\{ return false; \} Q\_\-ASSERT(pvPort != 0); qApp-\/$>$processEvents(); msleep(50); maxIter-\/-\/;



Definition at line 293 of file mdtUsbPortManager.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtUsbPortManager.h\item 
src/mdtport/mdtUsbPortManager.cpp\end{DoxyCompactItemize}
