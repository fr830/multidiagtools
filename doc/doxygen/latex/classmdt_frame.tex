\hypertarget{classmdt_frame}{
\section{mdtFrame Class Reference}
\label{classmdt_frame}\index{mdtFrame@{mdtFrame}}
}


Provide an array of bytes.  




{\ttfamily \#include $<$mdtFrame.h$>$}



Inheritance diagram for mdtFrame:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{classmdt_frame__inherit__graph}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17}{type\_\-t} \{ \par
\hyperlink{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17aeb10e33f775c33799273fcb130fee86f}{FT\_\-RAW}, 
\hyperlink{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17ac91a1c1827fa634eadaddb861f805c96}{FT\_\-RAW\_\-TOP}, 
\hyperlink{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17ac649559564652abbe656b97d4a84b722}{FT\_\-ASCII}, 
\hyperlink{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17a72c8ddaf29839f4037b686bdc346828a}{FT\_\-MODBUS\_\-TCP}, 
\par
\hyperlink{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17aca438ff6b553a819f22090facc562c86}{FT\_\-USBTMC}
 \}
\begin{DoxyCompactList}\small\item\em Frame type. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_frame_ac1a8ad77ce7bd6d08032056c3610d5c0}{setIgnoreNullValues} (bool ignoreNullValues)
\begin{DoxyCompactList}\small\item\em Set the ignore null values flag. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_frame_af03d60dadc6bd33b3a333cf484463113}{putUntil} (const char $\ast$data, char token, int maxLen)
\begin{DoxyCompactList}\small\item\em Put data until EOF token was reached. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_frame_aaa5c15df5aaf026b02f34639438036ad}{putUntil} (const char $\ast$data, QByteArray \&token, int maxLen)
\begin{DoxyCompactList}\small\item\em Put data until EOF token was reached. \end{DoxyCompactList}\item 
\hypertarget{classmdt_frame_ab4e0fee7198c94c16f2fa6eb4b6b1562}{
bool \hyperlink{classmdt_frame_ab4e0fee7198c94c16f2fa6eb4b6b1562}{isFull} ()}
\label{classmdt_frame_ab4e0fee7198c94c16f2fa6eb4b6b1562}

\begin{DoxyCompactList}\small\item\em Returns true if frame is full. \end{DoxyCompactList}\item 
\hypertarget{classmdt_frame_aa1cd5c914c36efb3f441b7f6e782dc24}{
int \hyperlink{classmdt_frame_aa1cd5c914c36efb3f441b7f6e782dc24}{remainCapacity} ()}
\label{classmdt_frame_aa1cd5c914c36efb3f441b7f6e782dc24}

\begin{DoxyCompactList}\small\item\em Returns the remain capacity. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_frame_a8526b227a56562fddf8445060e8095d4}{bytesToStore} ()
\begin{DoxyCompactList}\small\item\em Returns the bytes to store into the frame. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_frame_abfd6de396626f01ebf972b7d6cd26957}{setDirectlyComplete} (bool dc)
\begin{DoxyCompactList}\small\item\em Set the complete flag directly. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_frame_ab8db9882c095091109115afb8e448b37}{setComplete} ()
\begin{DoxyCompactList}\small\item\em Set the frame as complete. \end{DoxyCompactList}\item 
\hypertarget{classmdt_frame_a2a8fb9f36c941282881bba0c538d1ce5}{
bool \hyperlink{classmdt_frame_a2a8fb9f36c941282881bba0c538d1ce5}{isComplete} ()}
\label{classmdt_frame_a2a8fb9f36c941282881bba0c538d1ce5}

\begin{DoxyCompactList}\small\item\em Returns true if EOF condition was reached. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_frame_acdf8a921a3f36ca91af88b55b90febdc}{clear} ()
\begin{DoxyCompactList}\small\item\em Overloaded function. \end{DoxyCompactList}\item 
virtual void \hyperlink{classmdt_frame_aecc64d3846dee0049ee7b10b73a402f4}{clearSub} ()
\begin{DoxyCompactList}\small\item\em \hyperlink{classmdt_frame}{mdtFrame} subclass specific clear \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_frame_ae63af784d2fc54430ea5db4dc80b7ec8}{putData} (const char $\ast$data, int len)
\begin{DoxyCompactList}\small\item\em Put data into the frame. \end{DoxyCompactList}\item 
virtual int \hyperlink{classmdt_frame_a0e0dcfb9d284ac0dae550db33f0fbece}{eofSeqLen} ()
\begin{DoxyCompactList}\small\item\em Get the length of the end of frame sequence. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_frame_a36e4b85a3c671902ac3c8cc318ca726c}{take} (char $\ast$data, int len)
\begin{DoxyCompactList}\small\item\em Take some data. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_frame_ad8b184e6eb07a26fe84deaf233c1aa9b}{take} (int len)
\begin{DoxyCompactList}\small\item\em Take some data. \end{DoxyCompactList}\item 
void \hyperlink{classmdt_frame_a3b9a331858df9061879592fab1b346f5}{setWaitAnAnswer} (bool wait)
\begin{DoxyCompactList}\small\item\em Tell a write/read thread that an answer is needed after a write frame. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_frame_ab27455f2fa3415a96482786c0ec27e55}{waitAnAnswer} () const 
\begin{DoxyCompactList}\small\item\em Know if an answer is needed after a write frame. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classmdt_frame_a883c4de8f2c961310366d5a72b6e6dd8}{
bool {\bfseries pvIgnoreNullValues}}
\label{classmdt_frame_a883c4de8f2c961310366d5a72b6e6dd8}

\item 
\hypertarget{classmdt_frame_a1862e197bad6e9887cfedc54a768e88d}{
bool {\bfseries pvEOFcondition}}
\label{classmdt_frame_a1862e197bad6e9887cfedc54a768e88d}

\item 
\hypertarget{classmdt_frame_aac030954a872c41f7fb917912e16a77f}{
bool {\bfseries pvWaitAnAnswer}}
\label{classmdt_frame_aac030954a872c41f7fb917912e16a77f}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Provide an array of bytes. 

\hyperlink{classmdt_frame}{mdtFrame} is based on Qt's QByteArray, that provide a array of bytes. To store data, the QByteArray's methods append() can be used.\par
 For ASCII frames reception, the end is a special char/string on most case. \hyperlink{classmdt_frame}{mdtFrame} provide the functions \hyperlink{classmdt_frame_af03d60dadc6bd33b3a333cf484463113}{putUntil()} for that purpose.\par
 During data reception, for exemple from serial port, the best way to check if more data can be stored is to use \hyperlink{classmdt_frame_a8526b227a56562fddf8445060e8095d4}{bytesToStore()}. It returns the remain capacity of the frame, and 0 if the end of frame (EOF) condition was reached. To know if the frame is complete (i.e. end of frame condition ok), use \hyperlink{classmdt_frame_a2a8fb9f36c941282881bba0c538d1ce5}{isComplete()}\par
 Here are the states of a frame with return values of both functions:\par
 \begin{TabularC}{3}
\hline
State&\hyperlink{classmdt_frame_a8526b227a56562fddf8445060e8095d4}{bytesToStore()}&\hyperlink{classmdt_frame_a2a8fb9f36c941282881bba0c538d1ce5}{isComplete()} \\\cline{1-3}
Frame is not full, and EOF condition not reached&\hyperlink{classmdt_frame_aa1cd5c914c36efb3f441b7f6e782dc24}{remainCapacity()}&false \\\cline{1-3}
Frame is full, and EOF condition not reached&0&false \\\cline{1-3}
Frame is not full, and EOF condition reached&0&true \\\cline{1-3}
Frame is full, and EOF condition reached&0&true \\\cline{1-3}
\end{TabularC}
At this state, whenn \hyperlink{classmdt_frame_a8526b227a56562fddf8445060e8095d4}{bytesToStore()} returns 0 and \hyperlink{classmdt_frame_a2a8fb9f36c941282881bba0c538d1ce5}{isComplete()} is true, the received frame is ok. The next step is to decode it, according to the used protocol (modbus, ...).\par
 Note that these states are only set when using \hyperlink{classmdt_frame_af03d60dadc6bd33b3a333cf484463113}{putUntil()} and \hyperlink{classmdt_frame_ae63af784d2fc54430ea5db4dc80b7ec8}{putData()} functions. 

Definition at line 48 of file mdtFrame.h.



\subsection{Member Enumeration Documentation}
\hypertarget{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17}{
\index{mdtFrame@{mdtFrame}!type\_\-t@{type\_\-t}}
\index{type\_\-t@{type\_\-t}!mdtFrame@{mdtFrame}}
\subsubsection[{type\_\-t}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf mdtFrame::type\_\-t}}}
\label{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17}


Frame type. 

\begin{Desc}
\item[Enumerator: ]\par
\begin{description}
\index{FT\_\-RAW@{FT\_\-RAW}!mdtFrame@{mdtFrame}}\index{mdtFrame@{mdtFrame}!FT\_\-RAW@{FT\_\-RAW}}\item[{\em 
\hypertarget{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17aeb10e33f775c33799273fcb130fee86f}{
FT\_\-RAW}
\label{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17aeb10e33f775c33799273fcb130fee86f}
}]Raw binary data \index{FT\_\-RAW\_\-TOP@{FT\_\-RAW\_\-TOP}!mdtFrame@{mdtFrame}}\index{mdtFrame@{mdtFrame}!FT\_\-RAW\_\-TOP@{FT\_\-RAW\_\-TOP}}\item[{\em 
\hypertarget{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17ac91a1c1827fa634eadaddb861f805c96}{
FT\_\-RAW\_\-TOP}
\label{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17ac91a1c1827fa634eadaddb861f805c96}
}]Raw binary data for usage with timeout protocol \index{FT\_\-ASCII@{FT\_\-ASCII}!mdtFrame@{mdtFrame}}\index{mdtFrame@{mdtFrame}!FT\_\-ASCII@{FT\_\-ASCII}}\item[{\em 
\hypertarget{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17ac649559564652abbe656b97d4a84b722}{
FT\_\-ASCII}
\label{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17ac649559564652abbe656b97d4a84b722}
}]ASCII frame type \index{FT\_\-MODBUS\_\-TCP@{FT\_\-MODBUS\_\-TCP}!mdtFrame@{mdtFrame}}\index{mdtFrame@{mdtFrame}!FT\_\-MODBUS\_\-TCP@{FT\_\-MODBUS\_\-TCP}}\item[{\em 
\hypertarget{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17a72c8ddaf29839f4037b686bdc346828a}{
FT\_\-MODBUS\_\-TCP}
\label{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17a72c8ddaf29839f4037b686bdc346828a}
}]MODBUS/TCP frame type \index{FT\_\-USBTMC@{FT\_\-USBTMC}!mdtFrame@{mdtFrame}}\index{mdtFrame@{mdtFrame}!FT\_\-USBTMC@{FT\_\-USBTMC}}\item[{\em 
\hypertarget{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17aca438ff6b553a819f22090facc562c86}{
FT\_\-USBTMC}
\label{classmdt_frame_af936e37d5fe4c066c0fb0161fafd4a17aca438ff6b553a819f22090facc562c86}
}]USBTMC frame type \end{description}
\end{Desc}



Definition at line 57 of file mdtFrame.h.



\subsection{Member Function Documentation}
\hypertarget{classmdt_frame_a8526b227a56562fddf8445060e8095d4}{
\index{mdtFrame@{mdtFrame}!bytesToStore@{bytesToStore}}
\index{bytesToStore@{bytesToStore}!mdtFrame@{mdtFrame}}
\subsubsection[{bytesToStore}]{\setlength{\rightskip}{0pt plus 5cm}int mdtFrame::bytesToStore (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_frame_a8526b227a56562fddf8445060e8095d4}


Returns the bytes to store into the frame. 

Bytes to store can be the \hyperlink{classmdt_frame_aa1cd5c914c36efb3f441b7f6e782dc24}{remainCapacity()} value if frame is not full and EOF condition was not reached. Else, it returns 0. 

Definition at line 156 of file mdtFrame.cpp.

\hypertarget{classmdt_frame_acdf8a921a3f36ca91af88b55b90febdc}{
\index{mdtFrame@{mdtFrame}!clear@{clear}}
\index{clear@{clear}!mdtFrame@{mdtFrame}}
\subsubsection[{clear}]{\setlength{\rightskip}{0pt plus 5cm}void mdtFrame::clear (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_frame_acdf8a921a3f36ca91af88b55b90febdc}


Overloaded function. 

Internally, it calls QByteArray's \hyperlink{classmdt_frame_acdf8a921a3f36ca91af88b55b90febdc}{clear()} and reserve() methods. The goal is to keep the same capacity and reset some \hyperlink{classmdt_frame}{mdtFrame} and subclass specific flags 

Definition at line 179 of file mdtFrame.cpp.

\hypertarget{classmdt_frame_aecc64d3846dee0049ee7b10b73a402f4}{
\index{mdtFrame@{mdtFrame}!clearSub@{clearSub}}
\index{clearSub@{clearSub}!mdtFrame@{mdtFrame}}
\subsubsection[{clearSub}]{\setlength{\rightskip}{0pt plus 5cm}void mdtFrame::clearSub (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_frame_aecc64d3846dee0049ee7b10b73a402f4}


\hyperlink{classmdt_frame}{mdtFrame} subclass specific clear 

This method is usefull to clear some specific flags and data in subclasses (such as \hyperlink{classmdt_frame_usb_tmc}{mdtFrameUsbTmc}).

Note that QByteArray's flags and data are not altered.

This method is called from \hyperlink{classmdt_port_thread_a611211e56620ec9c699019452716e4fc}{mdtPortThread::getNewFrameRead()} . Default implementation does nothing.

This class must be implemented is subclass if needed. 

Reimplemented in \hyperlink{classmdt_frame_modbus_tcp_ab1545b25b4c8864056d900c8ddce2719}{mdtFrameModbusTcp}, and \hyperlink{classmdt_frame_usb_tmc_afb0b0e071e328b55ce8e2c73359153d6}{mdtFrameUsbTmc}.



Definition at line 188 of file mdtFrame.cpp.

\hypertarget{classmdt_frame_a0e0dcfb9d284ac0dae550db33f0fbece}{
\index{mdtFrame@{mdtFrame}!eofSeqLen@{eofSeqLen}}
\index{eofSeqLen@{eofSeqLen}!mdtFrame@{mdtFrame}}
\subsubsection[{eofSeqLen}]{\setlength{\rightskip}{0pt plus 5cm}int mdtFrame::eofSeqLen (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_frame_a0e0dcfb9d284ac0dae550db33f0fbece}


Get the length of the end of frame sequence. 

Used for ASCII frames. Default implementation returns 0 

Reimplemented in \hyperlink{classmdt_frame_ascii_a9694c60a807fd2e80e293a66c193baaa}{mdtFrameAscii}.



Definition at line 209 of file mdtFrame.cpp.

\hypertarget{classmdt_frame_ae63af784d2fc54430ea5db4dc80b7ec8}{
\index{mdtFrame@{mdtFrame}!putData@{putData}}
\index{putData@{putData}!mdtFrame@{mdtFrame}}
\subsubsection[{putData}]{\setlength{\rightskip}{0pt plus 5cm}int mdtFrame::putData (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{data, }
\item[{int}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_frame_ae63af784d2fc54430ea5db4dc80b7ec8}


Put data into the frame. 

Must be implemented by specific frame subclass.

This method is called by the read thread.

Default implementation simply stores data, and set the EOF condition to true. This way, it's possible to use \hyperlink{classmdt_frame}{mdtFrame} for raw binary transfers.


\begin{DoxyParams}{Parameters}
{\em data} & Valid pointer to the data \\
\hline
{\em len} & Maximum number of byte to store, must not be more than data size \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes that could really be stored 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
The data pointer must be valid, and not be the internal pointer returned by data(). 
\end{DoxyPrecond}


Reimplemented in \hyperlink{classmdt_frame_ascii_a9ef48ef78d9603a9d8c3be7e39b03745}{mdtFrameAscii}, \hyperlink{classmdt_frame_modbus_tcp_a0f684d77c03e5fb91598c9a10715bedb}{mdtFrameModbusTcp}, and \hyperlink{classmdt_frame_usb_tmc_a06d2743a113bd2b4cf2ee44014ecd710}{mdtFrameUsbTmc}.



Definition at line 192 of file mdtFrame.cpp.

\hypertarget{classmdt_frame_af03d60dadc6bd33b3a333cf484463113}{
\index{mdtFrame@{mdtFrame}!putUntil@{putUntil}}
\index{putUntil@{putUntil}!mdtFrame@{mdtFrame}}
\subsubsection[{putUntil}]{\setlength{\rightskip}{0pt plus 5cm}int mdtFrame::putUntil (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{data, }
\item[{char}]{token, }
\item[{int}]{maxLen}
\end{DoxyParamCaption}
)}}
\label{classmdt_frame_af03d60dadc6bd33b3a333cf484463113}


Put data until EOF token was reached. 

This function is usefull for ASCII frames reception. Whenn token is reached, the EOF condition will become true (the EOF char is not stored).\par
 When the EOF condition was reached, this function does not store any more data.\par
 Note that this function is slower than QByteArray's append() method, because it compares each byte with the token. 
\begin{DoxyParams}{Parameters}
{\em data} & Pointer to source data \\
\hline
{\em token} & Token that represents the EOF (End Of Frame) \\
\hline
{\em maxLen} & Length of the array pointed by data \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes really stored 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
The data pointer must be valid, and not be the internal pointer returned by data(). 
\end{DoxyPrecond}


Definition at line 41 of file mdtFrame.cpp.

\hypertarget{classmdt_frame_aaa5c15df5aaf026b02f34639438036ad}{
\index{mdtFrame@{mdtFrame}!putUntil@{putUntil}}
\index{putUntil@{putUntil}!mdtFrame@{mdtFrame}}
\subsubsection[{putUntil}]{\setlength{\rightskip}{0pt plus 5cm}int mdtFrame::putUntil (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{data, }
\item[{QByteArray \&}]{token, }
\item[{int}]{maxLen}
\end{DoxyParamCaption}
)}}
\label{classmdt_frame_aaa5c15df5aaf026b02f34639438036ad}


Put data until EOF token was reached. 

This is an overloaded function. The token can be a sequence of bytes.

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_frame_af03d60dadc6bd33b3a333cf484463113}{putUntil()} 
\end{DoxySeeAlso}


Definition at line 88 of file mdtFrame.cpp.

\hypertarget{classmdt_frame_ab8db9882c095091109115afb8e448b37}{
\index{mdtFrame@{mdtFrame}!setComplete@{setComplete}}
\index{setComplete@{setComplete}!mdtFrame@{mdtFrame}}
\subsubsection[{setComplete}]{\setlength{\rightskip}{0pt plus 5cm}void mdtFrame::setComplete (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_frame_ab8db9882c095091109115afb8e448b37}


Set the frame as complete. 

This is used by \hyperlink{classmdt_port_read_thread}{mdtPortReadThread} with timeout protocols. 

Definition at line 169 of file mdtFrame.cpp.

\hypertarget{classmdt_frame_abfd6de396626f01ebf972b7d6cd26957}{
\index{mdtFrame@{mdtFrame}!setDirectlyComplete@{setDirectlyComplete}}
\index{setDirectlyComplete@{setDirectlyComplete}!mdtFrame@{mdtFrame}}
\subsubsection[{setDirectlyComplete}]{\setlength{\rightskip}{0pt plus 5cm}void mdtFrame::setDirectlyComplete (
\begin{DoxyParamCaption}
\item[{bool}]{dc}
\end{DoxyParamCaption}
)}}
\label{classmdt_frame_abfd6de396626f01ebf972b7d6cd26957}


Set the complete flag directly. 

This is usefull for raw mode transfert. If true, the frame is set complete after each call of \hyperlink{classmdt_frame_ae63af784d2fc54430ea5db4dc80b7ec8}{putData()}


\begin{DoxyParams}{Parameters}
{\em dc} & The Directly complete flag \\
\hline
\end{DoxyParams}


Definition at line 164 of file mdtFrame.cpp.

\hypertarget{classmdt_frame_ac1a8ad77ce7bd6d08032056c3610d5c0}{
\index{mdtFrame@{mdtFrame}!setIgnoreNullValues@{setIgnoreNullValues}}
\index{setIgnoreNullValues@{setIgnoreNullValues}!mdtFrame@{mdtFrame}}
\subsubsection[{setIgnoreNullValues}]{\setlength{\rightskip}{0pt plus 5cm}void mdtFrame::setIgnoreNullValues (
\begin{DoxyParamCaption}
\item[{bool}]{ignoreNullValues}
\end{DoxyParamCaption}
)}}
\label{classmdt_frame_ac1a8ad77ce7bd6d08032056c3610d5c0}


Set the ignore null values flag. 

If set true, all null values ('$\backslash$0' or 0) are not stored by \hyperlink{classmdt_frame_af03d60dadc6bd33b3a333cf484463113}{putUntil()} methods 

Definition at line 36 of file mdtFrame.cpp.

\hypertarget{classmdt_frame_a3b9a331858df9061879592fab1b346f5}{
\index{mdtFrame@{mdtFrame}!setWaitAnAnswer@{setWaitAnAnswer}}
\index{setWaitAnAnswer@{setWaitAnAnswer}!mdtFrame@{mdtFrame}}
\subsubsection[{setWaitAnAnswer}]{\setlength{\rightskip}{0pt plus 5cm}void mdtFrame::setWaitAnAnswer (
\begin{DoxyParamCaption}
\item[{bool}]{wait}
\end{DoxyParamCaption}
)}}
\label{classmdt_frame_a3b9a331858df9061879592fab1b346f5}


Tell a write/read thread that an answer is needed after a write frame. 

In some case, typically USB, the host must allways init a transaction, for read and for write. For such case, only one thread manages the write/read process:
\begin{DoxyItemize}
\item Wait until a frame must be sent (can be bypassed with a flag)
\item Init a write transaction, wait until transaction is finish
\item Init a read transaction, wait until something was readen. The last step can be a problem if we have to write a frame (f.ex. a query), but not need an answer. After that, we have to send a second query, but need wait until data was received.
\end{DoxyItemize}

To solve this problem, we must tell the thread if it must init a read transaction after a frame was written (request) or not, and this is the goal of this method.

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_usb_port_thread}{mdtUsbPortThread} 
\end{DoxySeeAlso}


Definition at line 246 of file mdtFrame.cpp.

\hypertarget{classmdt_frame_a36e4b85a3c671902ac3c8cc318ca726c}{
\index{mdtFrame@{mdtFrame}!take@{take}}
\index{take@{take}!mdtFrame@{mdtFrame}}
\subsubsection[{take}]{\setlength{\rightskip}{0pt plus 5cm}int mdtFrame::take (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{data, }
\item[{int}]{len}
\end{DoxyParamCaption}
)}}
\label{classmdt_frame_a36e4b85a3c671902ac3c8cc318ca726c}


Take some data. 


\begin{DoxyParams}{Parameters}
{\em data} & Pointer to data destination \\
\hline
{\em len} & Number of bytes to take \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The data pointer must be valid, and not be the internal pointer returned by data(). 
\end{DoxyPrecond}


Definition at line 214 of file mdtFrame.cpp.

\hypertarget{classmdt_frame_ad8b184e6eb07a26fe84deaf233c1aa9b}{
\index{mdtFrame@{mdtFrame}!take@{take}}
\index{take@{take}!mdtFrame@{mdtFrame}}
\subsubsection[{take}]{\setlength{\rightskip}{0pt plus 5cm}int mdtFrame::take (
\begin{DoxyParamCaption}
\item[{int}]{len}
\end{DoxyParamCaption}
)}}
\label{classmdt_frame_ad8b184e6eb07a26fe84deaf233c1aa9b}


Take some data. 

This method does not copy any data, but is usefull after a copy using QByteArray::data() . The consumed bytes are removed from frame 
\begin{DoxyParams}{Parameters}
{\em data} & Pointer to data destination \\
\hline
{\em len} & Number of bytes to take \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The data pointer must be valid, and not be the internal pointer returned by data(). 
\end{DoxyPrecond}


Definition at line 232 of file mdtFrame.cpp.

\hypertarget{classmdt_frame_ab27455f2fa3415a96482786c0ec27e55}{
\index{mdtFrame@{mdtFrame}!waitAnAnswer@{waitAnAnswer}}
\index{waitAnAnswer@{waitAnAnswer}!mdtFrame@{mdtFrame}}
\subsubsection[{waitAnAnswer}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtFrame::waitAnAnswer (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}
\label{classmdt_frame_ab27455f2fa3415a96482786c0ec27e55}


Know if an answer is needed after a write frame. 

\begin{DoxySeeAlso}{See also}
\hyperlink{classmdt_frame_a3b9a331858df9061879592fab1b346f5}{setWaitAnAnswer()} 
\end{DoxySeeAlso}


Definition at line 251 of file mdtFrame.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtutils/mdtFrame.h\item 
src/mdtutils/mdtBuffer.cpp\item 
src/mdtutils/mdtFrame.cpp\end{DoxyCompactItemize}
