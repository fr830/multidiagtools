\hypertarget{classmdt_usbtmc_port_manager}{
\section{mdtUsbtmcPortManager Class Reference}
\label{classmdt_usbtmc_port_manager}\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
}


USBTMC port manager.  




{\ttfamily \#include $<$mdtUsbtmcPortManager.h$>$}



Inheritance diagram for mdtUsbtmcPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=202pt]{classmdt_usbtmc_port_manager__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for mdtUsbtmcPortManager:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=400pt]{classmdt_usbtmc_port_manager__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Slots}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classmdt_usbtmc_port_manager_aca42b343ae1f6a324e6e45968f03bbea}{fromThreadNewFrameReaden} ()
\begin{DoxyCompactList}\small\item\em Called by the thread whenn a frame was readen. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmdt_usbtmc_port_manager_a99a24e4360e70ffc63677dbe888513f7}{mdtUsbtmcPortManager} (QObject $\ast$parent=0)
\begin{DoxyCompactList}\small\item\em Construct a USBTMC port manager. \end{DoxyCompactList}\item 
\hyperlink{classmdt_usbtmc_port_manager_aad6b2eef9b5cfb5c324affb6962a463b}{$\sim$mdtUsbtmcPortManager} ()
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
QList$<$ \hyperlink{classmdt_port_info}{mdtPortInfo} $\ast$ $>$ \hyperlink{classmdt_usbtmc_port_manager_a992d1227810186d3c7dc166452e2e3b6}{scan} ()
\begin{DoxyCompactList}\small\item\em Scan for available ports with a USBTMC compatible device attached. \end{DoxyCompactList}\item 
bool \hyperlink{classmdt_usbtmc_port_manager_a0b90ceb0bbf424222ec878a355d206d7}{isReady} () const 
\begin{DoxyCompactList}\small\item\em Check if port manager is ready. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usbtmc_port_manager_af6abc4a3693fc386a12f346f57282c11}{sendCommand} (const QByteArray \&command)
\begin{DoxyCompactList}\small\item\em Send a command to device. \end{DoxyCompactList}\item 
QByteArray \hyperlink{classmdt_usbtmc_port_manager_acbbb8539c54034989b2ea6f6071e90bf}{sendQuery} (const QByteArray \&query)
\begin{DoxyCompactList}\small\item\em Send a query to device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usbtmc_port_manager_a205901666c797055bee1902bd1e1e09c}{sendData} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Send data on port. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usbtmc_port_manager_a6d566c68ddeb7c7ca14b5c70ae784efc}{sendData} (const QByteArray \&data)
\begin{DoxyCompactList}\small\item\em Write data by copy. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usbtmc_port_manager_a2920bdd6b189f198f132de9e5555a78b}{sendReadRequest} (\hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction)
\begin{DoxyCompactList}\small\item\em Send a read request to device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usbtmc_port_manager_ab1604a1c8f2e9192714d039dbf9a5158}{sendReadRequest} (bool enqueueResponse)
\begin{DoxyCompactList}\small\item\em Send a read request to device. \end{DoxyCompactList}\item 
int \hyperlink{classmdt_usbtmc_port_manager_a7bcc280bd4a26ed523832550b1e61553}{sendReadStatusByteRequest} ()
\begin{DoxyCompactList}\small\item\em Send a READ\_\-STATUS\_\-BYTE request thru the control endpoint. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
USBTMC port manager. 

\begin{Desc}
\item[\hyperlink{bug__bug000002}{Bug}]abortBulkIn() does not work properly \end{Desc}


This is the easiest way to use the USBTMC port API.

All needed object are created by constructor. To alter configuration, use \hyperlink{classmdt_port_manager_a9cf3ea2da38f81682695b37448712ffd}{config()}. To access the usb port object, use port().

Use \hyperlink{classmdt_usb_port_manager_ac656805c6de08c9c6a2487291cf3f347}{start()} to begin read/write and stop to end. 

Definition at line 44 of file mdtUsbtmcPortManager.h.



\subsection{Constructor \& Destructor Documentation}
\hypertarget{classmdt_usbtmc_port_manager_a99a24e4360e70ffc63677dbe888513f7}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{mdtUsbtmcPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtUsbtmcPortManager::mdtUsbtmcPortManager (
\begin{DoxyParamCaption}
\item[{QObject $\ast$}]{parent = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_a99a24e4360e70ffc63677dbe888513f7}


Construct a USBTMC port manager. 

Create a thread and setup port. 

connect(portThread, SIGNAL(controlResponseReaden()), this, SLOT(\hyperlink{classmdt_usb_port_manager_af043c75c74665b23d13f3cb73150935c}{fromThreadControlResponseReaden()})); connect(portThread, SIGNAL(messageInReaden()), this, SLOT(\hyperlink{classmdt_usb_port_manager_a9b7154590a4eb267aff4e11ba53dd7aa}{fromThreadMessageInReaden()})); 



Definition at line 37 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_aad6b2eef9b5cfb5c324affb6962a463b}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!$\sim$mdtUsbtmcPortManager@{$\sim$mdtUsbtmcPortManager}}
\index{$\sim$mdtUsbtmcPortManager@{$\sim$mdtUsbtmcPortManager}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{$\sim$mdtUsbtmcPortManager}]{\setlength{\rightskip}{0pt plus 5cm}mdtUsbtmcPortManager::$\sim$mdtUsbtmcPortManager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_aad6b2eef9b5cfb5c324affb6962a463b}


Destructor. 

Stop the manager (if running), and close the port (if open). All internal objects (port, config and threads) are deleted here. 

Definition at line 68 of file mdtUsbtmcPortManager.cpp.



\subsection{Member Function Documentation}
\hypertarget{classmdt_usbtmc_port_manager_aca42b343ae1f6a324e6e45968f03bbea}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!fromThreadNewFrameReaden@{fromThreadNewFrameReaden}}
\index{fromThreadNewFrameReaden@{fromThreadNewFrameReaden}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{fromThreadNewFrameReaden}]{\setlength{\rightskip}{0pt plus 5cm}void mdtUsbtmcPortManager::fromThreadNewFrameReaden (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual, slot\mbox{]}}}}
\label{classmdt_usbtmc_port_manager_aca42b343ae1f6a324e6e45968f03bbea}


Called by the thread whenn a frame was readen. 

\begin{Desc}
\item[\hyperlink{todo__todo000060}{Todo}]On complete frame, check bTag/bTagInverse, and INITIATE\_\-CLEAR on error. $<$-\/ Should be done in thread.. \end{Desc}


\begin{Desc}
\item[\hyperlink{todo__todo000061}{Todo}]Check ID coherence ? Should be a assertion ? \end{Desc}




Reimplemented from \hyperlink{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{mdtPortManager}.



Definition at line 346 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_a0b90ceb0bbf424222ec878a355d206d7}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!isReady@{isReady}}
\index{isReady@{isReady}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{isReady}]{\setlength{\rightskip}{0pt plus 5cm}bool mdtUsbtmcPortManager::isReady (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usbtmc_port_manager_a0b90ceb0bbf424222ec878a355d206d7}


Check if port manager is ready. 

Internally, the currentState is used to check if port manager is ready. This implementation returns true if currentState is Ready. 

Reimplemented from \hyperlink{classmdt_port_manager_a6dc2798324521d177fb8f79d4f6c5f0f}{mdtPortManager}.



Definition at line 101 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_a992d1227810186d3c7dc166452e2e3b6}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!scan@{scan}}
\index{scan@{scan}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{scan}]{\setlength{\rightskip}{0pt plus 5cm}QList$<$ {\bf mdtPortInfo} $\ast$ $>$ mdtUsbtmcPortManager::scan (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usbtmc_port_manager_a992d1227810186d3c7dc166452e2e3b6}


Scan for available ports with a USBTMC compatible device attached. 

Note that returned list must be freed by user after usage. (for.ex. with qDeletAll() and QList::clear() ).

\begin{DoxyPrecond}{Precondition}
Manager must be closed 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_usb_port_manager_a3a2370c3a2d0353a880bf9b777728c3b}{mdtUsbPortManager}.



Definition at line 72 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_af6abc4a3693fc386a12f346f57282c11}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!sendCommand@{sendCommand}}
\index{sendCommand@{sendCommand}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{sendCommand}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbtmcPortManager::sendCommand (
\begin{DoxyParamCaption}
\item[{const QByteArray \&}]{command}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_af6abc4a3693fc386a12f346f57282c11}


Send a command to device. 

At first, this method waits until the ready state is set calling \hyperlink{classmdt_usbtmc_port_manager_a0b90ceb0bbf424222ec878a355d206d7}{isReady()} , a frame is available in port's write frames pool, and until a transaction is possible (see \hyperlink{classmdt_port_manager_ac04a12f8aa20ba04695083afce45a6cc}{waitTransactionPossible()} ). This wait will not break event loop, so no GUI freeze occurs. If port manager is stopped during this wait (unhandled error, stop request), this method returns.

Note that the wait will not break the GUI's event loop (see mdtPortManager::waitOnWriteReady() for details).


\begin{DoxyParams}{Parameters}
{\em command} & Command to send. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bTag on success, or a error $<$ 0 (see mdtUsbtmcPortManager::writeData() for details). 
\end{DoxyReturn}


Definition at line 106 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_a205901666c797055bee1902bd1e1e09c}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!sendData@{sendData}}
\index{sendData@{sendData}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{sendData}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbtmcPortManager::sendData (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}
\label{classmdt_usbtmc_port_manager_a205901666c797055bee1902bd1e1e09c}


Send data on port. 

At first, this method waits until the ready state is set calling \hyperlink{classmdt_usbtmc_port_manager_a0b90ceb0bbf424222ec878a355d206d7}{isReady()} , a frame is available in port's write frames pool, and until a transaction is possible (see \hyperlink{classmdt_port_manager_ac04a12f8aa20ba04695083afce45a6cc}{waitTransactionPossible()} ). This wait will not break event loop, so no GUI freeze occurs. If port manager is stopped during this wait (unhandled error, stop request), this method returns.

Then, data contained in transaction will be passed to the mdtPort's write queue by copy. This method returns immediatly after enqueue, and don't wait until data was written.


\begin{DoxyParams}{Parameters}
{\em transaction} & Transaction used to send data. Following members are used by this method:
\begin{DoxyItemize}
\item id : transaction will be added to pending transactions with this id, and currentTransactionId will be set with it.
\item data : will be sent to port.
\item isQueryReplyMode : if true, the transaction will be keeped in transactions done queue until \hyperlink{classmdt_port_manager_a830ae182d06dd6a52c43a7f45b9240ac}{readenFrame()} or \hyperlink{classmdt_port_manager_addd5dcae9644cea42a9871205af41796}{readenFrames()} is called. Note: it's possible to force keeping all incomming data (wich also owerwrite this flag) by setting the global keepTransactionsDone flag.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bTag on success or value $<$ 0 on error. In this implementation, the only possible error is \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eae50ff4a9393507ad39005ddc7d5be42f}{mdtAbstractPort::WriteCanceled}, witch typically occurs when port manager stops. Note: on failure, the transaction is restored to pool. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 

transaction must be a valid pointer, and not allready exists in transactions pending or transactions done queue. 
\end{DoxyPrecond}


Reimplemented from \hyperlink{classmdt_port_manager_ad98399edba146af5cf32a9002094385c}{mdtPortManager}.



Definition at line 138 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_a6d566c68ddeb7c7ca14b5c70ae784efc}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!sendData@{sendData}}
\index{sendData@{sendData}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{sendData}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbtmcPortManager::sendData (
\begin{DoxyParamCaption}
\item[{const QByteArray \&}]{data}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_a6d566c68ddeb7c7ca14b5c70ae784efc}


Write data by copy. 

At first, this method waits until the ready state is set calling \hyperlink{classmdt_usbtmc_port_manager_a0b90ceb0bbf424222ec878a355d206d7}{isReady()} , a frame is available in port's write frames pool, and until a transaction is possible (see \hyperlink{classmdt_port_manager_ac04a12f8aa20ba04695083afce45a6cc}{waitTransactionPossible()} ). This wait will not break event loop, so no GUI freeze occurs. If port manager is stopped during this wait (unhandled error, stop request), this method returns.

Then, data will be encoded regarding USBTMC standard and passed to the mdtUsbPort's write queue by copy. This method returns immediatly after enqueue, and don't wait until data was written.

This method does not use transaction, because no response will be returned.


\begin{DoxyParams}{Parameters}
{\em data} & Data to write \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bTag ID on success or \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eae50ff4a9393507ad39005ddc7d5be42f}{mdtAbstractPort::WriteCanceled} ($<$ 0). 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
Port must be set with \hyperlink{classmdt_port_manager_afcd156b2d0c9d340999935efb6cd8cb6}{setPort()} before use of this method. 
\end{DoxyPrecond}


Definition at line 190 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_acbbb8539c54034989b2ea6f6071e90bf}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!sendQuery@{sendQuery}}
\index{sendQuery@{sendQuery}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{sendQuery}]{\setlength{\rightskip}{0pt plus 5cm}QByteArray mdtUsbtmcPortManager::sendQuery (
\begin{DoxyParamCaption}
\item[{const QByteArray \&}]{query}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_acbbb8539c54034989b2ea6f6071e90bf}


Send a query to device. 

Will wait until it's possible to write. See \hyperlink{classmdt_usbtmc_port_manager_a205901666c797055bee1902bd1e1e09c}{sendData()} and \hyperlink{classmdt_usbtmc_port_manager_a2920bdd6b189f198f132de9e5555a78b}{sendReadRequest()} for details (used internally).


\begin{DoxyParams}{Parameters}
{\em query} & Query to send. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Result as string (empty string on error) Note that \hyperlink{classmdt_frame_codec_scpi}{mdtFrameCodecScpi} can be helpful to decode returned result. 
\end{DoxyReturn}


Definition at line 111 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_a2920bdd6b189f198f132de9e5555a78b}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!sendReadRequest@{sendReadRequest}}
\index{sendReadRequest@{sendReadRequest}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{sendReadRequest}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbtmcPortManager::sendReadRequest (
\begin{DoxyParamCaption}
\item[{{\bf mdtPortTransaction} $\ast$}]{transaction}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_a2920bdd6b189f198f132de9e5555a78b}


Send a read request to device. 

USBTMC standard need that a read request is sent to device before we can read any data.

At first, this method waits until the ready state is set calling \hyperlink{classmdt_usbtmc_port_manager_a0b90ceb0bbf424222ec878a355d206d7}{isReady()} , and a frame is available in port's write frames pool. This wait will not break event loop, so no GUI freeze occurs. If port manager is stopped during this wait (unhandled error, stop request), this method returns.


\begin{DoxyParams}{Parameters}
{\em transaction} & A pointer to a valid transaction, with queryReplyMode set. (id will be set internally). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bTag ID on success or \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eae50ff4a9393507ad39005ddc7d5be42f}{mdtAbstractPort::WriteCanceled} ($<$ 0). On failure, the transaction is restored to pool. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
port must be set 

transaction must be a valid pointer
\end{DoxyPrecond}
int \hyperlink{classmdt_usbtmc_port_manager_a6d566c68ddeb7c7ca14b5c70ae784efc}{mdtUsbtmcPortManager::sendData(const QByteArray \&data)} \{ Q\_\-ASSERT(pvPort != 0);

\hyperlink{classmdt_frame_usb_tmc}{mdtFrameUsbTmc} $\ast$frame;

Wait until we can write while(1)\{ If port manager was stopped, we return if(\hyperlink{classmdt_port_manager_aeecbec49376838ab3547729636166d97}{isClosed()})\{ return \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eae50ff4a9393507ad39005ddc7d5be42f}{mdtAbstractPort::WriteCanceled}; \} if(\hyperlink{classmdt_usbtmc_port_manager_a0b90ceb0bbf424222ec878a355d206d7}{isReady()})\{ \hyperlink{classmdt_port_manager_a3107b7121dfe5b9686d9b3b3a48a0af0}{lockPortMutex()}; if(pvPort-\/$>$writeFramesPool().size() $>$ 0)\{ frame = dynamic\_\-cast$<$mdtFrameUsbTmc$\ast$$>$ (pvPort-\/$>$writeFramesPool().dequeue()); Q\_\-ASSERT(frame != 0); Here we are ready to write -\/ we keep port mutext locked break; \} \hyperlink{classmdt_port_manager_a882e6bf95dac9cd4ab8cc93ecc524874}{unlockPortMutex()}; \} QCoreApplication::processEvents(QEventLoop::AllEvents $|$ QEventLoop::WaitForMoreEvents); \} if(!waitTransactionPossible())\{ \hyperlink{classmdt_port_manager_a882e6bf95dac9cd4ab8cc93ecc524874}{unlockPortMutex()}; return \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85eae50ff4a9393507ad39005ddc7d5be42f}{mdtAbstractPort::WriteCanceled}; \} We are ready to write Q\_\-ASSERT(frame != 0); frame-\/$>$clear(); frame-\/$>$clearSub(); Store data and add frame to write queue frame-\/$>$setWaitAnAnswer(false); frame-\/$>$setMsgID(mdtFrameUsbTmc::DEV\_\-DEP\_\-MSG\_\-OUT); Increment bTag and enshure it's in correct range (1-\/255) incrementCurrentTransactionId(1, 255); frame-\/$>$setbTag(\hyperlink{classmdt_port_manager_a19abf29c8948cde0337d67c9722c25aa}{currentTransactionId()}); frame-\/$>$setMessageData(data); frame-\/$>$setEOM(true); frame-\/$>$encode(); pvPort-\/$>$addFrameToWrite(frame); \hyperlink{classmdt_port_manager_a882e6bf95dac9cd4ab8cc93ecc524874}{unlockPortMutex()};

return \hyperlink{classmdt_port_manager_a19abf29c8948cde0337d67c9722c25aa}{currentTransactionId()}; \} 

Definition at line 253 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_ab1604a1c8f2e9192714d039dbf9a5158}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!sendReadRequest@{sendReadRequest}}
\index{sendReadRequest@{sendReadRequest}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{sendReadRequest}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbtmcPortManager::sendReadRequest (
\begin{DoxyParamCaption}
\item[{bool}]{enqueueResponse}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_ab1604a1c8f2e9192714d039dbf9a5158}


Send a read request to device. 

USBTMC standard need that a read request is sent to device before we can read any data.


\begin{DoxyParams}{Parameters}
{\em enqueueResponse} & When data comes in,\\
\hline
\end{DoxyParams}
\begin{Desc}
\item[\hyperlink{todo__todo000062}{Todo}]SigName is emited. In blocking mode, data must (additionally) be enqueued until there are readen. So, for blocking mode (\char`\"{}script\char`\"{}), set this parameter true. \end{Desc}
\begin{DoxyReturn}{Returns}
bTag ID on success or value $<$ 0 if write queue is full. 
\end{DoxyReturn}


Definition at line 306 of file mdtUsbtmcPortManager.cpp.

\hypertarget{classmdt_usbtmc_port_manager_a7bcc280bd4a26ed523832550b1e61553}{
\index{mdtUsbtmcPortManager@{mdtUsbtmcPortManager}!sendReadStatusByteRequest@{sendReadStatusByteRequest}}
\index{sendReadStatusByteRequest@{sendReadStatusByteRequest}!mdtUsbtmcPortManager@{mdtUsbtmcPortManager}}
\subsubsection[{sendReadStatusByteRequest}]{\setlength{\rightskip}{0pt plus 5cm}int mdtUsbtmcPortManager::sendReadStatusByteRequest (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}
\label{classmdt_usbtmc_port_manager_a7bcc280bd4a26ed523832550b1e61553}


Send a READ\_\-STATUS\_\-BYTE request thru the control endpoint. 

\begin{DoxyReturn}{Returns}
bTag on success or WriteQueueEmpty on error.
\end{DoxyReturn}
\begin{Desc}
\item[\hyperlink{todo__todo000059}{Todo}]finish ! \end{Desc}


m.sendControlRequest(f); End Sandbox ! 



Definition at line 318 of file mdtUsbtmcPortManager.cpp.



The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
src/mdtport/mdtUsbtmcPortManager.h\item 
src/mdtport/mdtUsbtmcPortManager.cpp\end{DoxyCompactItemize}
