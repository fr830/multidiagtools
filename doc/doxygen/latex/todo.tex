\label{todo__todo000009}
\hypertarget{todo__todo000009}{}
 
\begin{DoxyDescription}
\item[Class \hyperlink{classmdt_abstract_port}{mdtAbstractPort} ]WaitingCanceled, WriteCanceled, ReadCanceled are not clean defined. The only object that knows when it must stop is the thread itself ! To be a little more clean, thread should check it's running flag each time a function returns a error, and stop if requierd ! 
\end{DoxyDescription}

\label{todo__todo000011}
\hypertarget{todo__todo000011}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_abstract_port_a1ace1a2bd1a04f16952980e247b04800}{mdtAbstractPort::close}() ]Actuellement, les queues sont delet√©e ici, que faire ? 
\end{DoxyDescription}

\label{todo__todo000010}
\hypertarget{todo__todo000010}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} ]add UnhandledError to complete UnknownError (+ adapt in threads) 

add a DeviceDisconnected (+ adapt in threads) 
\end{DoxyDescription}

\label{todo__todo000013}
\hypertarget{todo__todo000013}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_abstract_port_a54b7bfb725c91b2c292a39275b877207}{mdtAbstractPort::flushInRequestPending}() ]Thread are to adapt. 
\end{DoxyDescription}

\label{todo__todo000015}
\hypertarget{todo__todo000015}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_abstract_port_a2cc79d9288bebafaa183753dcf0807f3}{mdtAbstractPort::flushOutRequestPending}() ]Thread are to adapt. 
\end{DoxyDescription}

\label{todo__todo000018}
\hypertarget{todo__todo000018}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_abstract_port_a1667fa938d3a7578b73f54c32015c369}{mdtAbstractPort::pvFlushOut}()=0 ]Obselete this ? This method must be implemented in subclass. The pvCancelWrite flag must be set to true if no other system is used to handle the cancel flag (see waitEventWriteReady() )
\end{DoxyDescription}

\label{todo__todo000012}
\hypertarget{todo__todo000012}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_abstract_port_a9d9c45220d5328c9856a2445557fe970}{mdtAbstractPort::read}(char $\ast$data, qint64 maxSize)=0 ]adapt subclasses 
\end{DoxyDescription}

\label{todo__todo000016}
\hypertarget{todo__todo000016}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_abstract_port_a0fc7317e988d5dea53a999cd1bf4faa9}{mdtAbstractPort::updateReadTimeoutState}(bool state) ]Signal useable ? Note: this method is called from \hyperlink{classmdt_port_read_thread}{mdtPortReadThread} , and should not be used directly\par
 Mutex is not handled by this method. 
\end{DoxyDescription}

\label{todo__todo000017}
\hypertarget{todo__todo000017}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_abstract_port_ab51135de1f7bbc4707c3284f924c98dc}{mdtAbstractPort::updateWriteTimeoutState}(bool state) ]Signal useable ? Note: this method is called from \hyperlink{classmdt_port_write_thread}{mdtPortWriteThread} , and should not be used directly\par
 Mutex is not handled by this method. 
\end{DoxyDescription}

\label{todo__todo000014}
\hypertarget{todo__todo000014}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_abstract_port_a64d4802975a76474b9196c91f57a6d90}{mdtAbstractPort::write}(const char $\ast$data, qint64 maxSize)=0 ]adapt subclasses 
\end{DoxyDescription}

\label{todo__todo000058}
\hypertarget{todo__todo000058}{}
 
\begin{DoxyDescription}
\item[Class \hyperlink{classmdt_abstract_serial_port}{mdtAbstractSerialPort} ]Comment this class 
\end{DoxyDescription}

\label{todo__todo000059}
\hypertarget{todo__todo000059}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_abstract_serial_port_aaeacd26b220ab0f8c521cef74edfafdd}{mdtAbstractSerialPort::getCtlStates}()=0 ]Update name to : updateCtlStates ? 
\end{DoxyDescription}

\label{todo__todo000064}
\hypertarget{todo__todo000064}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_csv_file_af44de864675351a6f22b176e64a4cecc}{mdtCsvFile::parseLine}(const QByteArray \&line, const QByteArray \&separator, const QByteArray \&dataProtection) ]Check new function in mdtAlgorithm 
\end{DoxyDescription}

\label{todo__todo000003}
\hypertarget{todo__todo000003}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_device_a1df875803a3a0eb7324047d33c139621}{mdtDevice::waitTransactionDone}(int id, int timeout, int granularity=50) ]Adapt, comment
\end{DoxyDescription}

\label{todo__todo000020}
\hypertarget{todo__todo000020}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_device_info_afe4bbdc87acff59999905a0eeb812fe1}{mdtDeviceInfo::productName}() const  ]Conficting with \hyperlink{classmdt_usb_device_descriptor}{mdtUsbDeviceDescriptor} 
\end{DoxyDescription}

\label{todo__todo000019}
\hypertarget{todo__todo000019}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_device_info_a207d7b6b49fd65726232e95cd9e0568c}{mdtDeviceInfo::vendorName}() const  ]Conficting with \hyperlink{classmdt_usb_device_descriptor}{mdtUsbDeviceDescriptor} 
\end{DoxyDescription}

\label{todo__todo000005}
\hypertarget{todo__todo000005}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_device_scpi_ae8e886b362cbf9d1bf7064b48348b8e8}{mdtDeviceScpi::connectToDevice}(const \hyperlink{classmdt_device_info}{mdtDeviceInfo} \&devInfo) ]Add DeviceNotFound error ? 
\end{DoxyDescription}

\label{todo__todo000002}
\hypertarget{todo__todo000002}{}
 
\begin{DoxyDescription}
\item[Class \hyperlink{classmdt_device_u3606_a_widget}{mdtDeviceU3606AWidget} ]A supprimer !(?)! 
\end{DoxyDescription}

\label{todo__todo000001}
\hypertarget{todo__todo000001}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_device_u3606_a_widget_a653d85749d67555d8c3a43a779b6d2a2}{mdtDeviceU3606AWidget::mdtDeviceU3606AWidget}(QWidget $\ast$parent=0) ]A supprimer !(?)! 
\end{DoxyDescription}

\label{todo__todo000065}
\hypertarget{todo__todo000065}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_frame_codec_k8055_a9dfe60529b0e80d5bbd3852fdea51b18}{mdtFrameCodecK8055::decode}(QByteArray \&data) ]check statu field ?? 
\end{DoxyDescription}

\label{todo__todo000066}
\hypertarget{todo__todo000066}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_frame_codec_modbus_a426f465363a49d70890a462b40677787}{mdtFrameCodecModbus::decode}(const QByteArray \&pdu) ]Base 16 ?? 
\end{DoxyDescription}

\label{todo__todo000067}
\hypertarget{todo__todo000067}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_frame_codec_scpi_aa6596dc898438be704191ad282d02100}{mdtFrameCodecScpi::decodeIEEEdataAscii}(const QByteArray \&data) ]Not implemented yet 
\end{DoxyDescription}

\label{todo__todo000068}
\hypertarget{todo__todo000068}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_frame_codec_scpi_ab70c6c3d2d91ddff065952b6c2db8345}{mdtFrameCodecScpi::decodeIEEEdataByte}(const QByteArray \&data) ]Not implemented yet 
\end{DoxyDescription}

\label{todo__todo000071}
\hypertarget{todo__todo000071}{}
 
\begin{DoxyDescription}
\item[Class \hyperlink{classmdt_frame_usb_tmc}{mdtFrameUsbTmc} ]Clarify what this class does: USBTMC message or transfer ?
\end{DoxyDescription}

\label{todo__todo000069}
\hypertarget{todo__todo000069}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_frame_usb_tmc_a06d2743a113bd2b4cf2ee44014ecd710}{mdtFrameUsbTmc::putData}(const char $\ast$data, int maxLen) ]Handle error 

other bmTransferAttributes 
\end{DoxyDescription}

\label{todo__todo000023}
\hypertarget{todo__todo000023}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_modbus_tcp_port_manager_ad941ea607f00db54aa6deb2866a539e9}{mdtModbusTcpPortManager::fromThreadNewFrameReaden}() ]Error on incomplete frame 
\end{DoxyDescription}

\label{todo__todo000024}
\hypertarget{todo__todo000024}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_modbus_tcp_port_manager_ac83ea9c640869a4bccb4a4787697c646}{mdtModbusTcpPortManager::writeData}(QByteArray pdu, bool enqueueResponse=false) ]Obelete this version ! 

Obselete version with enqueueResponse 

SigName is emited. In blocking mode, data must (additionally) be enqueued until there are readen. So, for blocking mode (\char`\"{}script\char`\"{}), set this parameter true. 

Delete default enqueueResponse ! 

Handle this ? 
\end{DoxyDescription}

\label{todo__todo000022}
\hypertarget{todo__todo000022}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_modbus_tcp_port_manager_a2a3ade6d3f9a6e7de47b9b089754288f}{mdtModbusTcpPortManager::writeData}(QByteArray pdu, \hyperlink{classmdt_port_transaction}{mdtPortTransaction} $\ast$transaction) ]Handle this ? 
\end{DoxyDescription}

\label{todo__todo000027}
\hypertarget{todo__todo000027}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_port_config_a639c71f90cfeb7e2160ad90e9775054b}{mdtPortConfig::operator==}(const \hyperlink{classmdt_port_config}{mdtPortConfig} \&other) ]Rollback: voir callback libusb, si data, ... 
\end{DoxyDescription}

\label{todo__todo000008}
\hypertarget{todo__todo000008}{}
 
\begin{DoxyDescription}
\item[Class \hyperlink{classmdt_port_lock}{mdtPortLock} ]Implement UUCP format in LCK.. files 
\end{DoxyDescription}

\label{todo__todo000031}
\hypertarget{todo__todo000031}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_port_manager_a4b5300fbf05c2c267ca3a247ac3ab77f}{mdtPortManager::addTransaction}(int id, bool queryReplyMode) ]sigName is emited. 
\end{DoxyDescription}

\label{todo__todo000028}
\hypertarget{todo__todo000028}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_port_manager_a4fcc8f0699b655156e661bb3de6056cc}{mdtPortManager::fromThreadNewFrameReaden}() ]Error on incomplete frame 
\end{DoxyDescription}

\label{todo__todo000029}
\hypertarget{todo__todo000029}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_port_manager_a7e45b8e3475e5182ed12218616664d07}{mdtPortManager::onThreadsErrorOccured}(int error) ]Error handling (in general ...) 

On disconnect, should flush I/O ? 
\end{DoxyDescription}

\label{todo__todo000030}
\hypertarget{todo__todo000030}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_port_manager_aab594613e8985590c835194efbc27b5e}{mdtPortManager::openPort}() ]Should return \hyperlink{classmdt_abstract_port_ad4121bb930c95887e77f8bafa065a85e}{mdtAbstractPort::error\_\-t} 
\end{DoxyDescription}

\label{todo__todo000032}
\hypertarget{todo__todo000032}{}
 
\begin{DoxyDescription}
\item[Class \hyperlink{classmdt_port_read_thread}{mdtPortReadThread} ]suspendTransmission() call is no longer in getNewFrameRead(), must be handled in run() now. 
\end{DoxyDescription}

\label{todo__todo000062}
\hypertarget{todo__todo000062}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_port_term_a7ec568c44f862fe7aee83f1a271ac6bb}{mdtPortTerm::sendCmd}() ]Error handling ! 
\end{DoxyDescription}

\label{todo__todo000034}
\hypertarget{todo__todo000034}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_port_thread_ab31cbe1a85aa830cd368654d1f806326}{mdtPortThread::errorOccured}(int error) ]Adapt threads + port managers
\end{DoxyDescription}

\label{todo__todo000035}
\hypertarget{todo__todo000035}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_port_thread_a611211e56620ec9c699019452716e4fc}{mdtPortThread::getNewFrameRead}() ]Currently implemented in polling, should be done with a wait condition.
\end{DoxyDescription}

\label{todo__todo000036}
\hypertarget{todo__todo000036}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_port_thread_ad2c618a032c0aeed0f0cb3b30bc0aba9}{mdtPortThread::notifyError}(int error) ]Adapt in threads subclasses 
\end{DoxyDescription}

\label{todo__todo000033}
\hypertarget{todo__todo000033}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_port_thread_a2e0c384ae6c909cb40fc0ca1a0189ca6}{mdtPortThread::readFromPort}(\hyperlink{classmdt_frame}{mdtFrame} $\ast$$\ast$frame) ]Handle timeout error ? 
\end{DoxyDescription}

\label{todo__todo000060}
\hypertarget{todo__todo000060}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_serial_port_ctl_widget_a9dce60a846cbf24d7ceab099ff147c18}{mdtSerialPortCtlWidget::makeConnections}(\hyperlink{classmdt_serial_port_manager}{mdtSerialPortManager} $\ast$manager) ]Create threads somwere here, and connect signals/slots 
\end{DoxyDescription}

\label{todo__todo000039}
\hypertarget{todo__todo000039}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_usb_device_descriptor_a626afc71d8e72600f12259ac6f5a5866}{mdtUsbDeviceDescriptor::productName}() const  ]Parsing the usb.ids (see \href{http://www.linux-usb.org}{\tt http://www.linux-\/usb.org}) 
\end{DoxyDescription}

\label{todo__todo000038}
\hypertarget{todo__todo000038}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_usb_device_descriptor_ac2f746ebd5540b65bf00f82c991f5c3b}{mdtUsbDeviceDescriptor::vendorName}() const  ]Parsing the usb.ids (see \href{http://www.linux-usb.org}{\tt http://www.linux-\/usb.org}) 
\end{DoxyDescription}

\label{todo__todo000049}
\hypertarget{todo__todo000049}{}
 
\begin{DoxyDescription}
\item[Class \hyperlink{classmdt_usb_port}{mdtUsbPort} ]Not really true... For read and write of data, the mdtAbstractPort's API is used.
\end{DoxyDescription}

\label{todo__todo000042}
\hypertarget{todo__todo000042}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_usb_port_a551748422808cbb071930e1134bfaad5}{mdtUsbPort::handleUsbEvents}(struct timeval $\ast$timeout, quint8 endpoint) ]Check about pvLastError that was set by transfer callbacks ? 

Think that timeout has no sense here, should be filtered 
\end{DoxyDescription}

\label{todo__todo000044}
\hypertarget{todo__todo000044}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_usb_port_abb66e85fc1366112eeb0a6e86f6e7e32}{mdtUsbPort::handleUsbEvents}() ]Cancel will allways return ControlCanceled , this is not good 
\end{DoxyDescription}

\label{todo__todo000041}
\hypertarget{todo__todo000041}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_usb_port_a897234cc2c7561da323cb124f57bcc28}{mdtUsbPort::initMessageInTransfer}() ]Handle retval 
\end{DoxyDescription}

\label{todo__todo000040}
\hypertarget{todo__todo000040}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_usb_port_a5e380852b8726f71e8558c86cba5bd1f}{mdtUsbPort::initReadTransfer}(qint64 maxSize) ]Handle retval 
\end{DoxyDescription}

\label{todo__todo000054}
\hypertarget{todo__todo000054}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_usbtmc_port_manager_ae845b25c292e83ef9fe01640867c7116}{mdtUsbtmcPortManager::abortBulkIn}(quint8 bTag) ]Should we flushIn() first ? 
\end{DoxyDescription}

\label{todo__todo000057}
\hypertarget{todo__todo000057}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_usbtmc_port_manager_aca42b343ae1f6a324e6e45968f03bbea}{mdtUsbtmcPortManager::fromThreadNewFrameReaden}() ]Essais ... void abort(); 

Error on incomplete frame 
\end{DoxyDescription}

\label{todo__todo000052}
\hypertarget{todo__todo000052}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_usbtmc_port_manager_a99a24e4360e70ffc63677dbe888513f7}{mdtUsbtmcPortManager::mdtUsbtmcPortManager}(QObject $\ast$parent=0) ]Taille provisoire ! pvPort-\/$>$config().setReadFrameSize(10000); pvPort-\/$>$config().setReadQueueSize(3); pvPort-\/$>$config().setWriteFrameSize(512); pvPort-\/$>$config().setWriteQueueSize(1); 
\end{DoxyDescription}

\label{todo__todo000056}
\hypertarget{todo__todo000056}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_usbtmc_port_manager_ab1604a1c8f2e9192714d039dbf9a5158}{mdtUsbtmcPortManager::sendReadRequest}(bool enqueueResponse) ]SigName is emited. In blocking mode, data must (additionally) be enqueued until there are readen. So, for blocking mode (\char`\"{}script\char`\"{}), set this parameter true. 
\end{DoxyDescription}

\label{todo__todo000053}
\hypertarget{todo__todo000053}{}
 
\begin{DoxyDescription}
\item[Member \hyperlink{classmdt_usbtmc_port_manager_a7bcc280bd4a26ed523832550b1e61553}{mdtUsbtmcPortManager::sendReadStatusByteRequest}() ]finish ! 
\end{DoxyDescription}